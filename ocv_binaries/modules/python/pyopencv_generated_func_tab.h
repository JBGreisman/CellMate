    {"Algorithm__create", (PyCFunction)pyopencv_Algorithm__create, METH_VARARGS | METH_KEYWORDS, "Algorithm__create(name) -> retval"},
    {"Algorithm_getList", (PyCFunction)pyopencv_Algorithm_getList, METH_VARARGS | METH_KEYWORDS, "Algorithm_getList() -> algorithms"},
    {"BFMatcher", (PyCFunction)pyopencv_BFMatcher_BFMatcher, METH_VARARGS | METH_KEYWORDS, "BFMatcher([, normType[, crossCheck]]) -> <BFMatcher object>"},
    {"BRISK", (PyCFunction)pyopencv_BRISK_BRISK, METH_VARARGS | METH_KEYWORDS, "BRISK([, thresh[, octaves[, patternScale]]]) -> <BRISK object>  or  BRISK(radiusList, numberList[, dMax[, dMin[, indexChange]]]) -> <BRISK object>"},
    {"CamShift", (PyCFunction)pyopencv_CamShift, METH_VARARGS | METH_KEYWORDS, "CamShift(probImage, window, criteria) -> retval, window"},
    {"Canny", (PyCFunction)pyopencv_Canny, METH_VARARGS | METH_KEYWORDS, "Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]]) -> edges"},
    {"CascadeClassifier", (PyCFunction)pyopencv_CascadeClassifier_CascadeClassifier, METH_VARARGS | METH_KEYWORDS, "CascadeClassifier([filename]) -> <CascadeClassifier object>"},
    {"CascadeClassifier_convert", (PyCFunction)pyopencv_CascadeClassifier_convert, METH_VARARGS | METH_KEYWORDS, "CascadeClassifier_convert(oldcascade, newcascade) -> retval"},
    {"ANN_MLP", (PyCFunction)pyopencv_CvANN_MLP_CvANN_MLP, METH_VARARGS | METH_KEYWORDS, "ANN_MLP([layerSizes[, activateFunc[, fparam1[, fparam2]]]]) -> <ANN_MLP object>"},
    {"Boost", (PyCFunction)pyopencv_CvBoost_CvBoost, METH_VARARGS | METH_KEYWORDS, "Boost([trainData, tflag, responses[, varIdx[, sampleIdx[, varType[, missingDataMask[, params]]]]]]) -> <Boost object>"},
    {"DTree", (PyCFunction)pyopencv_CvDTree_CvDTree, METH_VARARGS | METH_KEYWORDS, "DTree() -> <DTree object>"},
    {"ERTrees", (PyCFunction)pyopencv_CvERTrees_CvERTrees, METH_VARARGS | METH_KEYWORDS, "ERTrees() -> <ERTrees object>"},
    {"GBTrees", (PyCFunction)pyopencv_CvGBTrees_CvGBTrees, METH_VARARGS | METH_KEYWORDS, "GBTrees([trainData, tflag, responses[, varIdx[, sampleIdx[, varType[, missingDataMask[, params]]]]]]) -> <GBTrees object>"},
    {"KNearest", (PyCFunction)pyopencv_CvKNearest_CvKNearest, METH_VARARGS | METH_KEYWORDS, "KNearest([trainData, responses[, sampleIdx[, isRegression[, max_k]]]]) -> <KNearest object>"},
    {"NormalBayesClassifier", (PyCFunction)pyopencv_CvNormalBayesClassifier_CvNormalBayesClassifier, METH_VARARGS | METH_KEYWORDS, "NormalBayesClassifier([trainData, responses[, varIdx[, sampleIdx]]]) -> <NormalBayesClassifier object>"},
    {"RTrees", (PyCFunction)pyopencv_CvRTrees_CvRTrees, METH_VARARGS | METH_KEYWORDS, "RTrees() -> <RTrees object>"},
    {"SVM", (PyCFunction)pyopencv_CvSVM_CvSVM, METH_VARARGS | METH_KEYWORDS, "SVM([trainData, responses[, varIdx[, sampleIdx[, params]]]]) -> <SVM object>"},
    {"DMatch", (PyCFunction)pyopencv_DMatch_DMatch, METH_VARARGS | METH_KEYWORDS, "DMatch() -> <DMatch object>  or  DMatch(_queryIdx, _trainIdx, _distance) -> <DMatch object>  or  DMatch(_queryIdx, _trainIdx, _imgIdx, _distance) -> <DMatch object>"},
    {"DenseFeatureDetector", (PyCFunction)pyopencv_DenseFeatureDetector_DenseFeatureDetector, METH_VARARGS | METH_KEYWORDS, "DenseFeatureDetector([, initFeatureScale[, featureScaleLevels[, featureScaleMul[, initXyStep[, initImgBound[, varyXyStepWithScale[, varyImgBoundWithScale]]]]]]]) -> <DenseFeatureDetector object>"},
    {"DescriptorExtractor_create", (PyCFunction)pyopencv_DescriptorExtractor_create, METH_VARARGS | METH_KEYWORDS, "DescriptorExtractor_create(descriptorExtractorType) -> retval"},
    {"DescriptorMatcher_create", (PyCFunction)pyopencv_DescriptorMatcher_create, METH_VARARGS | METH_KEYWORDS, "DescriptorMatcher_create(descriptorMatcherType) -> retval"},
    {"softcascade_Detector", (PyCFunction)pyopencv_softcascade_Detector_Detector, METH_VARARGS | METH_KEYWORDS, "softcascade_Detector([, minScale[, maxScale[, scales[, rejCriteria]]]]) -> <softcascade_Detector object>"},
    {"EM", (PyCFunction)pyopencv_EM_EM, METH_VARARGS | METH_KEYWORDS, "EM([, nclusters[, covMatType[, termCrit]]]) -> <EM object>"},
    {"FastFeatureDetector", (PyCFunction)pyopencv_FastFeatureDetector_FastFeatureDetector, METH_VARARGS | METH_KEYWORDS, "FastFeatureDetector([, threshold[, nonmaxSuppression]]) -> <FastFeatureDetector object>  or  FastFeatureDetector(threshold, nonmaxSuppression, type) -> <FastFeatureDetector object>"},
    {"Feature2D_create", (PyCFunction)pyopencv_Feature2D_create, METH_VARARGS | METH_KEYWORDS, "Feature2D_create(name) -> retval"},
    {"FeatureDetector_create", (PyCFunction)pyopencv_FeatureDetector_create, METH_VARARGS | METH_KEYWORDS, "FeatureDetector_create(detectorType) -> retval"},
    {"FileNode", (PyCFunction)pyopencv_FileNode_FileNode, METH_VARARGS | METH_KEYWORDS, "FileNode() -> <FileNode object>"},
    {"FileStorage", (PyCFunction)pyopencv_FileStorage_FileStorage, METH_VARARGS | METH_KEYWORDS, "FileStorage([source, flags[, encoding]]) -> <FileStorage object>"},
    {"FlannBasedMatcher", (PyCFunction)pyopencv_FlannBasedMatcher_FlannBasedMatcher, METH_VARARGS | METH_KEYWORDS, "FlannBasedMatcher([, indexParams[, searchParams]]) -> <FlannBasedMatcher object>"},
    {"GFTTDetector", (PyCFunction)pyopencv_GFTTDetector_GFTTDetector, METH_VARARGS | METH_KEYWORDS, "GFTTDetector([, maxCorners[, qualityLevel[, minDistance[, blockSize[, useHarrisDetector[, k]]]]]]) -> <GFTTDetector object>"},
    {"GaussianBlur", (PyCFunction)pyopencv_GaussianBlur, METH_VARARGS | METH_KEYWORDS, "GaussianBlur(src, ksize, sigmaX[, dst[, sigmaY[, borderType]]]) -> dst"},
    {"GridAdaptedFeatureDetector", (PyCFunction)pyopencv_GridAdaptedFeatureDetector_GridAdaptedFeatureDetector, METH_VARARGS | METH_KEYWORDS, "GridAdaptedFeatureDetector([, detector[, maxTotalKeypoints[, gridRows[, gridCols]]]]) -> <GridAdaptedFeatureDetector object>"},
    {"HOGDescriptor", (PyCFunction)pyopencv_HOGDescriptor_HOGDescriptor, METH_VARARGS | METH_KEYWORDS, "HOGDescriptor() -> <HOGDescriptor object>  or  HOGDescriptor(_winSize, _blockSize, _blockStride, _cellSize, _nbins[, _derivAperture[, _winSigma[, _histogramNormType[, _L2HysThreshold[, _gammaCorrection[, _nlevels]]]]]]) -> <HOGDescriptor object>  or  HOGDescriptor(filename) -> <HOGDescriptor object>"},
    {"HOGDescriptor_getDaimlerPeopleDetector", (PyCFunction)pyopencv_HOGDescriptor_getDaimlerPeopleDetector, METH_VARARGS | METH_KEYWORDS, "HOGDescriptor_getDaimlerPeopleDetector() -> retval"},
    {"HOGDescriptor_getDefaultPeopleDetector", (PyCFunction)pyopencv_HOGDescriptor_getDefaultPeopleDetector, METH_VARARGS | METH_KEYWORDS, "HOGDescriptor_getDefaultPeopleDetector() -> retval"},
    {"HoughCircles", (PyCFunction)pyopencv_HoughCircles, METH_VARARGS | METH_KEYWORDS, "HoughCircles(image, method, dp, minDist[, circles[, param1[, param2[, minRadius[, maxRadius]]]]]) -> circles"},
    {"HoughLines", (PyCFunction)pyopencv_HoughLines, METH_VARARGS | METH_KEYWORDS, "HoughLines(image, rho, theta, threshold[, lines[, srn[, stn[, min_theta[, max_theta]]]]]) -> lines"},
    {"HoughLinesP", (PyCFunction)pyopencv_HoughLinesP, METH_VARARGS | METH_KEYWORDS, "HoughLinesP(image, rho, theta, threshold[, lines[, minLineLength[, maxLineGap]]]) -> lines"},
    {"HuMoments", (PyCFunction)pyopencv_HuMoments, METH_VARARGS | METH_KEYWORDS, "HuMoments(m[, hu]) -> hu"},
    {"flann_Index", (PyCFunction)pyopencv_flann_Index_Index, METH_VARARGS | METH_KEYWORDS, "flann_Index([features, params[, distType]]) -> <flann_Index object>"},
    {"KDTree", (PyCFunction)pyopencv_KDTree_KDTree, METH_VARARGS | METH_KEYWORDS, "KDTree() -> <KDTree object>  or  KDTree(points[, copyAndReorderPoints]) -> <KDTree object>  or  KDTree(points, _labels[, copyAndReorderPoints]) -> <KDTree object>"},
    {"KalmanFilter", (PyCFunction)pyopencv_KalmanFilter_KalmanFilter, METH_VARARGS | METH_KEYWORDS, "KalmanFilter([dynamParams, measureParams[, controlParams[, type]]]) -> <KalmanFilter object>"},
    {"KeyPoint", (PyCFunction)pyopencv_KeyPoint_KeyPoint, METH_VARARGS | METH_KEYWORDS, "KeyPoint([x, y, _size[, _angle[, _response[, _octave[, _class_id]]]]]) -> <KeyPoint object>"},
    {"KeyPoint_convert", (PyCFunction)pyopencv_KeyPoint_convert, METH_VARARGS | METH_KEYWORDS, "KeyPoint_convert(keypoints[, keypointIndexes]) -> points2f  or  KeyPoint_convert(points2f[, size[, response[, octave[, class_id]]]]) -> keypoints"},
    {"KeyPoint_overlap", (PyCFunction)pyopencv_KeyPoint_overlap, METH_VARARGS | METH_KEYWORDS, "KeyPoint_overlap(kp1, kp2) -> retval"},
    {"LUT", (PyCFunction)pyopencv_LUT, METH_VARARGS | METH_KEYWORDS, "LUT(src, lut[, dst]) -> dst"},
    {"Laplacian", (PyCFunction)pyopencv_Laplacian, METH_VARARGS | METH_KEYWORDS, "Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]]) -> dst"},
    {"MSER", (PyCFunction)pyopencv_MSER_MSER, METH_VARARGS | METH_KEYWORDS, "MSER([, _delta[, _min_area[, _max_area[, _max_variation[, _min_diversity[, _max_evolution[, _area_threshold[, _min_margin[, _edge_blur_size]]]]]]]]]) -> <MSER object>"},
    {"Mahalanobis", (PyCFunction)pyopencv_Mahalanobis, METH_VARARGS | METH_KEYWORDS, "Mahalanobis(v1, v2, icovar) -> retval"},
    {"ORB", (PyCFunction)pyopencv_ORB_ORB, METH_VARARGS | METH_KEYWORDS, "ORB([, nfeatures[, scaleFactor[, nlevels[, edgeThreshold[, firstLevel[, WTA_K[, scoreType[, patchSize]]]]]]]]) -> <ORB object>"},
    {"PCABackProject", (PyCFunction)pyopencv_PCABackProject, METH_VARARGS | METH_KEYWORDS, "PCABackProject(data, mean, eigenvectors[, result]) -> result"},
    {"PCACompute", (PyCFunction)pyopencv_PCACompute, METH_VARARGS | METH_KEYWORDS, "PCACompute(data, mean[, eigenvectors[, maxComponents]]) -> mean, eigenvectors  or  PCACompute(data, mean, retainedVariance[, eigenvectors]) -> mean, eigenvectors"},
    {"PCAProject", (PyCFunction)pyopencv_PCAProject, METH_VARARGS | METH_KEYWORDS, "PCAProject(data, mean, eigenvectors[, result]) -> result"},
    {"PSNR", (PyCFunction)pyopencv_PSNR, METH_VARARGS | METH_KEYWORDS, "PSNR(src1, src2) -> retval"},
    {"SimpleBlobDetector_Params", (PyCFunction)pyopencv_SimpleBlobDetector_Params_Params, METH_VARARGS | METH_KEYWORDS, "SimpleBlobDetector_Params() -> <SimpleBlobDetector_Params object>"},
    {"PyramidAdaptedFeatureDetector", (PyCFunction)pyopencv_PyramidAdaptedFeatureDetector_PyramidAdaptedFeatureDetector, METH_VARARGS | METH_KEYWORDS, "PyramidAdaptedFeatureDetector(detector[, maxLevel]) -> <PyramidAdaptedFeatureDetector object>"},
    {"RQDecomp3x3", (PyCFunction)pyopencv_RQDecomp3x3, METH_VARARGS | METH_KEYWORDS, "RQDecomp3x3(src[, mtxR[, mtxQ[, Qx[, Qy[, Qz]]]]]) -> retval, mtxR, mtxQ, Qx, Qy, Qz"},
    {"Rodrigues", (PyCFunction)pyopencv_Rodrigues, METH_VARARGS | METH_KEYWORDS, "Rodrigues(src[, dst[, jacobian]]) -> dst, jacobian"},
    {"SIFT", (PyCFunction)pyopencv_SIFT_SIFT, METH_VARARGS | METH_KEYWORDS, "SIFT([, nfeatures[, nOctaveLayers[, contrastThreshold[, edgeThreshold[, sigma]]]]]) -> <SIFT object>"},
    {"SURF", (PyCFunction)pyopencv_SURF_SURF, METH_VARARGS | METH_KEYWORDS, "SURF([hessianThreshold[, nOctaves[, nOctaveLayers[, extended[, upright]]]]]) -> <SURF object>"},
    {"SVBackSubst", (PyCFunction)pyopencv_SVBackSubst, METH_VARARGS | METH_KEYWORDS, "SVBackSubst(w, u, vt, rhs[, dst]) -> dst"},
    {"SVDecomp", (PyCFunction)pyopencv_SVDecomp, METH_VARARGS | METH_KEYWORDS, "SVDecomp(src[, w[, u[, vt[, flags]]]]) -> w, u, vt"},
    {"Scharr", (PyCFunction)pyopencv_Scharr, METH_VARARGS | METH_KEYWORDS, "Scharr(src, ddepth, dx, dy[, dst[, scale[, delta[, borderType]]]]) -> dst"},
    {"SimpleBlobDetector", (PyCFunction)pyopencv_SimpleBlobDetector_SimpleBlobDetector, METH_VARARGS | METH_KEYWORDS, "SimpleBlobDetector([, parameters]) -> <SimpleBlobDetector object>"},
    {"Sobel", (PyCFunction)pyopencv_Sobel, METH_VARARGS | METH_KEYWORDS, "Sobel(src, ddepth, dx, dy[, dst[, ksize[, scale[, delta[, borderType]]]]]) -> dst"},
    {"StarDetector", (PyCFunction)pyopencv_StarDetector_StarDetector, METH_VARARGS | METH_KEYWORDS, "StarDetector([, _maxSize[, _responseThreshold[, _lineThresholdProjected[, _lineThresholdBinarized[, _suppressNonmaxSize]]]]]) -> <StarDetector object>"},
    {"StereoVar", (PyCFunction)pyopencv_StereoVar_StereoVar, METH_VARARGS | METH_KEYWORDS, "StereoVar([levels, pyrScale, nIt, minDisp, maxDisp, poly_n, poly_sigma, fi, lambda, penalization, cycle, flags]) -> <StereoVar object>"},
    {"Subdiv2D", (PyCFunction)pyopencv_Subdiv2D_Subdiv2D, METH_VARARGS | METH_KEYWORDS, "Subdiv2D([rect]) -> <Subdiv2D object>"},
    {"VideoCapture", (PyCFunction)pyopencv_VideoCapture_VideoCapture, METH_VARARGS | METH_KEYWORDS, "VideoCapture() -> <VideoCapture object>  or  VideoCapture(filename) -> <VideoCapture object>  or  VideoCapture(device) -> <VideoCapture object>"},
    {"VideoWriter", (PyCFunction)pyopencv_VideoWriter_VideoWriter, METH_VARARGS | METH_KEYWORDS, "VideoWriter([filename, fourcc, fps, frameSize[, isColor]]) -> <VideoWriter object>"},
    {"VideoWriter_fourcc", (PyCFunction)pyopencv_VideoWriter_fourcc, METH_VARARGS | METH_KEYWORDS, "VideoWriter_fourcc(c1, c2, c3, c4) -> retval"},
    {"absdiff", (PyCFunction)pyopencv_absdiff, METH_VARARGS | METH_KEYWORDS, "absdiff(src1, src2[, dst]) -> dst"},
    {"accumulate", (PyCFunction)pyopencv_accumulate, METH_VARARGS | METH_KEYWORDS, "accumulate(src, dst[, mask]) -> dst"},
    {"accumulateProduct", (PyCFunction)pyopencv_accumulateProduct, METH_VARARGS | METH_KEYWORDS, "accumulateProduct(src1, src2, dst[, mask]) -> dst"},
    {"accumulateSquare", (PyCFunction)pyopencv_accumulateSquare, METH_VARARGS | METH_KEYWORDS, "accumulateSquare(src, dst[, mask]) -> dst"},
    {"accumulateWeighted", (PyCFunction)pyopencv_accumulateWeighted, METH_VARARGS | METH_KEYWORDS, "accumulateWeighted(src, dst, alpha[, mask]) -> dst"},
    {"adaptiveThreshold", (PyCFunction)pyopencv_adaptiveThreshold, METH_VARARGS | METH_KEYWORDS, "adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst]) -> dst"},
    {"add", (PyCFunction)pyopencv_add, METH_VARARGS | METH_KEYWORDS, "add(src1, src2[, dst[, mask[, dtype]]]) -> dst"},
    {"addWeighted", (PyCFunction)pyopencv_addWeighted, METH_VARARGS | METH_KEYWORDS, "addWeighted(src1, alpha, src2, beta, gamma[, dst[, dtype]]) -> dst"},
    {"applyColorMap", (PyCFunction)pyopencv_applyColorMap, METH_VARARGS | METH_KEYWORDS, "applyColorMap(src, colormap[, dst]) -> dst"},
    {"approxPolyDP", (PyCFunction)pyopencv_approxPolyDP, METH_VARARGS | METH_KEYWORDS, "approxPolyDP(curve, epsilon, closed[, approxCurve]) -> approxCurve"},
    {"arcLength", (PyCFunction)pyopencv_arcLength, METH_VARARGS | METH_KEYWORDS, "arcLength(curve, closed) -> retval"},
    {"batchDistance", (PyCFunction)pyopencv_batchDistance, METH_VARARGS | METH_KEYWORDS, "batchDistance(src1, src2, dtype[, dist[, nidx[, normType[, K[, mask[, update[, crosscheck]]]]]]]) -> dist, nidx"},
    {"bilateralFilter", (PyCFunction)pyopencv_bilateralFilter, METH_VARARGS | METH_KEYWORDS, "bilateralFilter(src, d, sigmaColor, sigmaSpace[, dst[, borderType]]) -> dst"},
    {"bitwise_and", (PyCFunction)pyopencv_bitwise_and, METH_VARARGS | METH_KEYWORDS, "bitwise_and(src1, src2[, dst[, mask]]) -> dst"},
    {"bitwise_not", (PyCFunction)pyopencv_bitwise_not, METH_VARARGS | METH_KEYWORDS, "bitwise_not(src[, dst[, mask]]) -> dst"},
    {"bitwise_or", (PyCFunction)pyopencv_bitwise_or, METH_VARARGS | METH_KEYWORDS, "bitwise_or(src1, src2[, dst[, mask]]) -> dst"},
    {"bitwise_xor", (PyCFunction)pyopencv_bitwise_xor, METH_VARARGS | METH_KEYWORDS, "bitwise_xor(src1, src2[, dst[, mask]]) -> dst"},
    {"blur", (PyCFunction)pyopencv_blur, METH_VARARGS | METH_KEYWORDS, "blur(src, ksize[, dst[, anchor[, borderType]]]) -> dst"},
    {"borderInterpolate", (PyCFunction)pyopencv_borderInterpolate, METH_VARARGS | METH_KEYWORDS, "borderInterpolate(p, len, borderType) -> retval"},
    {"boundingRect", (PyCFunction)pyopencv_boundingRect, METH_VARARGS | METH_KEYWORDS, "boundingRect(points) -> retval"},
    {"boxFilter", (PyCFunction)pyopencv_boxFilter, METH_VARARGS | METH_KEYWORDS, "boxFilter(src, ddepth, ksize[, dst[, anchor[, normalize[, borderType]]]]) -> dst"},
    {"boxPoints", (PyCFunction)pyopencv_boxPoints, METH_VARARGS | METH_KEYWORDS, "boxPoints(box[, points]) -> points"},
    {"buildOpticalFlowPyramid", (PyCFunction)pyopencv_buildOpticalFlowPyramid, METH_VARARGS | METH_KEYWORDS, "buildOpticalFlowPyramid(img, winSize, maxLevel[, pyramid[, withDerivatives[, pyrBorder[, derivBorder[, tryReuseInputImage]]]]]) -> retval, pyramid"},
    {"calcBackProject", (PyCFunction)pyopencv_calcBackProject, METH_VARARGS | METH_KEYWORDS, "calcBackProject(images, channels, hist, ranges, scale[, dst]) -> dst"},
    {"calcCovarMatrix", (PyCFunction)pyopencv_calcCovarMatrix, METH_VARARGS | METH_KEYWORDS, "calcCovarMatrix(samples, mean, flags[, covar[, ctype]]) -> covar, mean"},
    {"calcGlobalOrientation", (PyCFunction)pyopencv_calcGlobalOrientation, METH_VARARGS | METH_KEYWORDS, "calcGlobalOrientation(orientation, mask, mhi, timestamp, duration) -> retval"},
    {"calcHist", (PyCFunction)pyopencv_calcHist, METH_VARARGS | METH_KEYWORDS, "calcHist(images, channels, mask, histSize, ranges[, hist[, accumulate]]) -> hist"},
    {"calcMotionGradient", (PyCFunction)pyopencv_calcMotionGradient, METH_VARARGS | METH_KEYWORDS, "calcMotionGradient(mhi, delta1, delta2[, mask[, orientation[, apertureSize]]]) -> mask, orientation"},
    {"calcOpticalFlowFarneback", (PyCFunction)pyopencv_calcOpticalFlowFarneback, METH_VARARGS | METH_KEYWORDS, "calcOpticalFlowFarneback(prev, next, flow, pyr_scale, levels, winsize, iterations, poly_n, poly_sigma, flags) -> flow"},
    {"calcOpticalFlowPyrLK", (PyCFunction)pyopencv_calcOpticalFlowPyrLK, METH_VARARGS | METH_KEYWORDS, "calcOpticalFlowPyrLK(prevImg, nextImg, prevPts, nextPts[, status[, err[, winSize[, maxLevel[, criteria[, flags[, minEigThreshold]]]]]]]) -> nextPts, status, err"},
    {"calcOpticalFlowSF", (PyCFunction)pyopencv_calcOpticalFlowSF, METH_VARARGS | METH_KEYWORDS, "calcOpticalFlowSF(from, to, layers, averaging_block_size, max_flow[, flow]) -> flow  or  calcOpticalFlowSF(from, to, layers, averaging_block_size, max_flow, sigma_dist, sigma_color, postprocess_window, sigma_dist_fix, sigma_color_fix, occ_thr, upscale_averaging_radius, upscale_sigma_dist, upscale_sigma_color, speed_up_thr[, flow]) -> flow"},
    {"calibrateCamera", (PyCFunction)pyopencv_calibrateCamera, METH_VARARGS | METH_KEYWORDS, "calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs[, rvecs[, tvecs[, flags[, criteria]]]]) -> retval, cameraMatrix, distCoeffs, rvecs, tvecs"},
    {"calibrationMatrixValues", (PyCFunction)pyopencv_calibrationMatrixValues, METH_VARARGS | METH_KEYWORDS, "calibrationMatrixValues(cameraMatrix, imageSize, apertureWidth, apertureHeight) -> fovx, fovy, focalLength, principalPoint, aspectRatio"},
    {"cartToPolar", (PyCFunction)pyopencv_cartToPolar, METH_VARARGS | METH_KEYWORDS, "cartToPolar(x, y[, magnitude[, angle[, angleInDegrees]]]) -> magnitude, angle"},
    {"chamerMatching", (PyCFunction)pyopencv_chamerMatching, METH_VARARGS | METH_KEYWORDS, "chamerMatching(img, templ[, templScale[, maxMatches[, minMatchDistance[, padX[, padY[, scales[, minScale[, maxScale[, orientationWeight[, truncate]]]]]]]]]]) -> retval, results, cost"},
    {"checkHardwareSupport", (PyCFunction)pyopencv_checkHardwareSupport, METH_VARARGS | METH_KEYWORDS, "checkHardwareSupport(feature) -> retval"},
    {"checkRange", (PyCFunction)pyopencv_checkRange, METH_VARARGS | METH_KEYWORDS, "checkRange(a[, quiet[, minVal[, maxVal]]]) -> retval, pos"},
    {"circle", (PyCFunction)pyopencv_circle, METH_VARARGS | METH_KEYWORDS, "circle(img, center, radius, color[, thickness[, lineType[, shift]]]) -> img"},
    {"clipLine", (PyCFunction)pyopencv_clipLine, METH_VARARGS | METH_KEYWORDS, "clipLine(imgRect, pt1, pt2) -> retval, pt1, pt2"},
    {"colorChange", (PyCFunction)pyopencv_colorChange, METH_VARARGS | METH_KEYWORDS, "colorChange(src, mask[, dst[, red_mul[, green_mul[, blue_mul]]]]) -> dst"},
    {"compare", (PyCFunction)pyopencv_compare, METH_VARARGS | METH_KEYWORDS, "compare(src1, src2, cmpop[, dst]) -> dst"},
    {"compareHist", (PyCFunction)pyopencv_compareHist, METH_VARARGS | METH_KEYWORDS, "compareHist(H1, H2, method) -> retval"},
    {"completeSymm", (PyCFunction)pyopencv_completeSymm, METH_VARARGS | METH_KEYWORDS, "completeSymm(mtx[, lowerToUpper]) -> mtx"},
    {"composeRT", (PyCFunction)pyopencv_composeRT, METH_VARARGS | METH_KEYWORDS, "composeRT(rvec1, tvec1, rvec2, tvec2[, rvec3[, tvec3[, dr3dr1[, dr3dt1[, dr3dr2[, dr3dt2[, dt3dr1[, dt3dt1[, dt3dr2[, dt3dt2]]]]]]]]]]) -> rvec3, tvec3, dr3dr1, dr3dt1, dr3dr2, dr3dt2, dt3dr1, dt3dt1, dt3dr2, dt3dt2"},
    {"computeCorrespondEpilines", (PyCFunction)pyopencv_computeCorrespondEpilines, METH_VARARGS | METH_KEYWORDS, "computeCorrespondEpilines(points, whichImage, F[, lines]) -> lines"},
    {"connectedComponents", (PyCFunction)pyopencv_connectedComponents, METH_VARARGS | METH_KEYWORDS, "connectedComponents(image[, labels[, connectivity[, ltype]]]) -> retval, labels"},
    {"connectedComponentsWithStats", (PyCFunction)pyopencv_connectedComponentsWithStats, METH_VARARGS | METH_KEYWORDS, "connectedComponentsWithStats(image[, labels[, stats[, centroids[, connectivity[, ltype]]]]]) -> retval, labels, stats, centroids"},
    {"contourArea", (PyCFunction)pyopencv_contourArea, METH_VARARGS | METH_KEYWORDS, "contourArea(contour[, oriented]) -> retval"},
    {"convertMaps", (PyCFunction)pyopencv_convertMaps, METH_VARARGS | METH_KEYWORDS, "convertMaps(map1, map2, dstmap1type[, dstmap1[, dstmap2[, nninterpolation]]]) -> dstmap1, dstmap2"},
    {"convertPointsFromHomogeneous", (PyCFunction)pyopencv_convertPointsFromHomogeneous, METH_VARARGS | METH_KEYWORDS, "convertPointsFromHomogeneous(src[, dst]) -> dst"},
    {"convertPointsToHomogeneous", (PyCFunction)pyopencv_convertPointsToHomogeneous, METH_VARARGS | METH_KEYWORDS, "convertPointsToHomogeneous(src[, dst]) -> dst"},
    {"convertScaleAbs", (PyCFunction)pyopencv_convertScaleAbs, METH_VARARGS | METH_KEYWORDS, "convertScaleAbs(src[, dst[, alpha[, beta]]]) -> dst"},
    {"convexHull", (PyCFunction)pyopencv_convexHull, METH_VARARGS | METH_KEYWORDS, "convexHull(points[, hull[, clockwise[, returnPoints]]]) -> hull"},
    {"convexityDefects", (PyCFunction)pyopencv_convexityDefects, METH_VARARGS | METH_KEYWORDS, "convexityDefects(contour, convexhull[, convexityDefects]) -> convexityDefects"},
    {"copyMakeBorder", (PyCFunction)pyopencv_copyMakeBorder, METH_VARARGS | METH_KEYWORDS, "copyMakeBorder(src, top, bottom, left, right, borderType[, dst[, value]]) -> dst"},
    {"cornerEigenValsAndVecs", (PyCFunction)pyopencv_cornerEigenValsAndVecs, METH_VARARGS | METH_KEYWORDS, "cornerEigenValsAndVecs(src, blockSize, ksize[, dst[, borderType]]) -> dst"},
    {"cornerHarris", (PyCFunction)pyopencv_cornerHarris, METH_VARARGS | METH_KEYWORDS, "cornerHarris(src, blockSize, ksize, k[, dst[, borderType]]) -> dst"},
    {"cornerMinEigenVal", (PyCFunction)pyopencv_cornerMinEigenVal, METH_VARARGS | METH_KEYWORDS, "cornerMinEigenVal(src, blockSize[, dst[, ksize[, borderType]]]) -> dst"},
    {"cornerSubPix", (PyCFunction)pyopencv_cornerSubPix, METH_VARARGS | METH_KEYWORDS, "cornerSubPix(image, corners, winSize, zeroZone, criteria) -> corners"},
    {"correctMatches", (PyCFunction)pyopencv_correctMatches, METH_VARARGS | METH_KEYWORDS, "correctMatches(F, points1, points2[, newPoints1[, newPoints2]]) -> newPoints1, newPoints2"},
    {"countNonZero", (PyCFunction)pyopencv_countNonZero, METH_VARARGS | METH_KEYWORDS, "countNonZero(src) -> retval"},
    {"createAlignMTB", (PyCFunction)pyopencv_createAlignMTB, METH_VARARGS | METH_KEYWORDS, "createAlignMTB([, max_bits[, exclude_range[, cut]]]) -> retval"},
    {"createBackgroundSubtractorGMG", (PyCFunction)pyopencv_createBackgroundSubtractorGMG, METH_VARARGS | METH_KEYWORDS, "createBackgroundSubtractorGMG([, initializationFrames[, decisionThreshold]]) -> retval"},
    {"createBackgroundSubtractorKNN", (PyCFunction)pyopencv_createBackgroundSubtractorKNN, METH_VARARGS | METH_KEYWORDS, "createBackgroundSubtractorKNN([, history[, dist2Threshold[, detectShadows]]]) -> retval"},
    {"createBackgroundSubtractorMOG", (PyCFunction)pyopencv_createBackgroundSubtractorMOG, METH_VARARGS | METH_KEYWORDS, "createBackgroundSubtractorMOG([, history[, nmixtures[, backgroundRatio[, noiseSigma]]]]) -> retval"},
    {"createBackgroundSubtractorMOG2", (PyCFunction)pyopencv_createBackgroundSubtractorMOG2, METH_VARARGS | METH_KEYWORDS, "createBackgroundSubtractorMOG2([, history[, varThreshold[, detectShadows]]]) -> retval"},
    {"createCLAHE", (PyCFunction)pyopencv_createCLAHE, METH_VARARGS | METH_KEYWORDS, "createCLAHE([, clipLimit[, tileGridSize]]) -> retval"},
    {"createCalibrateDebevec", (PyCFunction)pyopencv_createCalibrateDebevec, METH_VARARGS | METH_KEYWORDS, "createCalibrateDebevec([, samples[, lambda[, random]]]) -> retval"},
    {"createCalibrateRobertson", (PyCFunction)pyopencv_createCalibrateRobertson, METH_VARARGS | METH_KEYWORDS, "createCalibrateRobertson([, max_iter[, threshold]]) -> retval"},
    {"createEigenFaceRecognizer", (PyCFunction)pyopencv_createEigenFaceRecognizer, METH_VARARGS | METH_KEYWORDS, "createEigenFaceRecognizer([, num_components[, threshold]]) -> retval"},
    {"createFisherFaceRecognizer", (PyCFunction)pyopencv_createFisherFaceRecognizer, METH_VARARGS | METH_KEYWORDS, "createFisherFaceRecognizer([, num_components[, threshold]]) -> retval"},
    {"createHanningWindow", (PyCFunction)pyopencv_createHanningWindow, METH_VARARGS | METH_KEYWORDS, "createHanningWindow(winSize, type[, dst]) -> dst"},
    {"createLBPHFaceRecognizer", (PyCFunction)pyopencv_createLBPHFaceRecognizer, METH_VARARGS | METH_KEYWORDS, "createLBPHFaceRecognizer([, radius[, neighbors[, grid_x[, grid_y[, threshold]]]]]) -> retval"},
    {"createLineSegmentDetector", (PyCFunction)pyopencv_createLineSegmentDetector, METH_VARARGS | METH_KEYWORDS, "createLineSegmentDetector([, _refine[, _scale[, _sigma_scale[, _quant[, _ang_th[, _log_eps[, _density_th[, _n_bins]]]]]]]]) -> retval"},
    {"createMergeDebevec", (PyCFunction)pyopencv_createMergeDebevec, METH_VARARGS | METH_KEYWORDS, "createMergeDebevec() -> retval"},
    {"createMergeMertens", (PyCFunction)pyopencv_createMergeMertens, METH_VARARGS | METH_KEYWORDS, "createMergeMertens([, contrast_weight[, saturation_weight[, exposure_weight]]]) -> retval"},
    {"createMergeRobertson", (PyCFunction)pyopencv_createMergeRobertson, METH_VARARGS | METH_KEYWORDS, "createMergeRobertson() -> retval"},
    {"createStereoBM", (PyCFunction)pyopencv_createStereoBM, METH_VARARGS | METH_KEYWORDS, "createStereoBM([, numDisparities[, blockSize]]) -> retval"},
    {"createStereoSGBM", (PyCFunction)pyopencv_createStereoSGBM, METH_VARARGS | METH_KEYWORDS, "createStereoSGBM(minDisparity, numDisparities, blockSize[, P1[, P2[, disp12MaxDiff[, preFilterCap[, uniquenessRatio[, speckleWindowSize[, speckleRange[, mode]]]]]]]]) -> retval"},
    {"createTonemap", (PyCFunction)pyopencv_createTonemap, METH_VARARGS | METH_KEYWORDS, "createTonemap([, gamma]) -> retval"},
    {"createTonemapDrago", (PyCFunction)pyopencv_createTonemapDrago, METH_VARARGS | METH_KEYWORDS, "createTonemapDrago([, gamma[, saturation[, bias]]]) -> retval"},
    {"createTonemapDurand", (PyCFunction)pyopencv_createTonemapDurand, METH_VARARGS | METH_KEYWORDS, "createTonemapDurand([, gamma[, contrast[, saturation[, sigma_space[, sigma_color]]]]]) -> retval"},
    {"createTonemapMantiuk", (PyCFunction)pyopencv_createTonemapMantiuk, METH_VARARGS | METH_KEYWORDS, "createTonemapMantiuk([, gamma[, scale[, saturation]]]) -> retval"},
    {"createTonemapReinhard", (PyCFunction)pyopencv_createTonemapReinhard, METH_VARARGS | METH_KEYWORDS, "createTonemapReinhard([, gamma[, intensity[, light_adapt[, color_adapt]]]]) -> retval"},
    {"cubeRoot", (PyCFunction)pyopencv_cubeRoot, METH_VARARGS | METH_KEYWORDS, "cubeRoot(val) -> retval"},
    {"cvtColor", (PyCFunction)pyopencv_cvtColor, METH_VARARGS | METH_KEYWORDS, "cvtColor(src, code[, dst[, dstCn]]) -> dst"},
    {"dct", (PyCFunction)pyopencv_dct, METH_VARARGS | METH_KEYWORDS, "dct(src[, dst[, flags]]) -> dst"},
    {"decolor", (PyCFunction)pyopencv_decolor, METH_VARARGS | METH_KEYWORDS, "decolor(src[, grayscale[, color_boost]]) -> grayscale, color_boost"},
    {"decomposeEssentialMat", (PyCFunction)pyopencv_decomposeEssentialMat, METH_VARARGS | METH_KEYWORDS, "decomposeEssentialMat(E[, R1[, R2[, t]]]) -> R1, R2, t"},
    {"decomposeProjectionMatrix", (PyCFunction)pyopencv_decomposeProjectionMatrix, METH_VARARGS | METH_KEYWORDS, "decomposeProjectionMatrix(projMatrix[, cameraMatrix[, rotMatrix[, transVect[, rotMatrixX[, rotMatrixY[, rotMatrixZ[, eulerAngles]]]]]]]) -> cameraMatrix, rotMatrix, transVect, rotMatrixX, rotMatrixY, rotMatrixZ, eulerAngles"},
    {"demosaicing", (PyCFunction)pyopencv_demosaicing, METH_VARARGS | METH_KEYWORDS, "demosaicing(_src, code[, _dst[, dcn]]) -> _dst"},
    {"destroyAllWindows", (PyCFunction)pyopencv_destroyAllWindows, METH_VARARGS | METH_KEYWORDS, "destroyAllWindows() -> None"},
    {"destroyWindow", (PyCFunction)pyopencv_destroyWindow, METH_VARARGS | METH_KEYWORDS, "destroyWindow(winname) -> None"},
    {"detailEnhance", (PyCFunction)pyopencv_detailEnhance, METH_VARARGS | METH_KEYWORDS, "detailEnhance(src[, dst[, sigma_s[, sigma_r]]]) -> dst"},
    {"determinant", (PyCFunction)pyopencv_determinant, METH_VARARGS | METH_KEYWORDS, "determinant(mtx) -> retval"},
    {"dft", (PyCFunction)pyopencv_dft, METH_VARARGS | METH_KEYWORDS, "dft(src[, dst[, flags[, nonzeroRows]]]) -> dst"},
    {"dilate", (PyCFunction)pyopencv_dilate, METH_VARARGS | METH_KEYWORDS, "dilate(src, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]]) -> dst"},
    {"distanceTransform", (PyCFunction)pyopencv_distanceTransform, METH_VARARGS | METH_KEYWORDS, "distanceTransform(src, distanceType, maskSize[, dst[, dstType]]) -> dst"},
    {"distanceTransformWithLabels", (PyCFunction)pyopencv_distanceTransformWithLabels, METH_VARARGS | METH_KEYWORDS, "distanceTransformWithLabels(src, distanceType, maskSize[, dst[, labels[, labelType]]]) -> dst, labels"},
    {"divide", (PyCFunction)pyopencv_divide, METH_VARARGS | METH_KEYWORDS, "divide(src1, src2[, dst[, scale[, dtype]]]) -> dst  or  divide(scale, src2[, dst[, dtype]]) -> dst"},
    {"drawChessboardCorners", (PyCFunction)pyopencv_drawChessboardCorners, METH_VARARGS | METH_KEYWORDS, "drawChessboardCorners(image, patternSize, corners, patternWasFound) -> image"},
    {"drawContours", (PyCFunction)pyopencv_drawContours, METH_VARARGS | METH_KEYWORDS, "drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset]]]]]) -> image"},
    {"drawDataMatrixCodes", (PyCFunction)pyopencv_drawDataMatrixCodes, METH_VARARGS | METH_KEYWORDS, "drawDataMatrixCodes(image, codes, corners) -> image"},
    {"drawKeypoints", (PyCFunction)pyopencv_drawKeypoints, METH_VARARGS | METH_KEYWORDS, "drawKeypoints(image, keypoints, outImage[, color[, flags]]) -> outImage"},
    {"drawMatches", (PyCFunction)pyopencv_drawMatches, METH_VARARGS | METH_KEYWORDS, "drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) -> outImg"},
    {"drawMatchesKnn", (PyCFunction)pyopencv_drawMatchesKnn, METH_VARARGS | METH_KEYWORDS, "drawMatchesKnn(img1, keypoints1, img2, keypoints2, matches1to2, outImg[, matchColor[, singlePointColor[, matchesMask[, flags]]]]) -> outImg"},
    {"edgePreservingFilter", (PyCFunction)pyopencv_edgePreservingFilter, METH_VARARGS | METH_KEYWORDS, "edgePreservingFilter(src[, dst[, flags[, sigma_s[, sigma_r]]]]) -> dst"},
    {"eigen", (PyCFunction)pyopencv_eigen, METH_VARARGS | METH_KEYWORDS, "eigen(src[, eigenvalues[, eigenvectors]]) -> retval, eigenvalues, eigenvectors"},
    {"ellipse", (PyCFunction)pyopencv_ellipse, METH_VARARGS | METH_KEYWORDS, "ellipse(img, center, axes, angle, startAngle, endAngle, color[, thickness[, lineType[, shift]]]) -> img  or  ellipse(img, box, color[, thickness[, lineType]]) -> img"},
    {"ellipse2Poly", (PyCFunction)pyopencv_ellipse2Poly, METH_VARARGS | METH_KEYWORDS, "ellipse2Poly(center, axes, angle, arcStart, arcEnd, delta) -> pts"},
    {"equalizeHist", (PyCFunction)pyopencv_equalizeHist, METH_VARARGS | METH_KEYWORDS, "equalizeHist(src[, dst]) -> dst"},
    {"erode", (PyCFunction)pyopencv_erode, METH_VARARGS | METH_KEYWORDS, "erode(src, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]]) -> dst"},
    {"estimateAffine3D", (PyCFunction)pyopencv_estimateAffine3D, METH_VARARGS | METH_KEYWORDS, "estimateAffine3D(src, dst[, out[, inliers[, ransacThreshold[, confidence]]]]) -> retval, out, inliers"},
    {"estimateRigidTransform", (PyCFunction)pyopencv_estimateRigidTransform, METH_VARARGS | METH_KEYWORDS, "estimateRigidTransform(src, dst, fullAffine) -> retval"},
    {"exp", (PyCFunction)pyopencv_exp, METH_VARARGS | METH_KEYWORDS, "exp(src[, dst]) -> dst"},
    {"extractChannel", (PyCFunction)pyopencv_extractChannel, METH_VARARGS | METH_KEYWORDS, "extractChannel(src, coi[, dst]) -> dst"},
    {"fastAtan2", (PyCFunction)pyopencv_fastAtan2, METH_VARARGS | METH_KEYWORDS, "fastAtan2(y, x) -> retval"},
    {"fastNlMeansDenoising", (PyCFunction)pyopencv_fastNlMeansDenoising, METH_VARARGS | METH_KEYWORDS, "fastNlMeansDenoising(src[, dst[, h[, templateWindowSize[, searchWindowSize]]]]) -> dst"},
    {"fastNlMeansDenoisingColored", (PyCFunction)pyopencv_fastNlMeansDenoisingColored, METH_VARARGS | METH_KEYWORDS, "fastNlMeansDenoisingColored(src[, dst[, h[, hColor[, templateWindowSize[, searchWindowSize]]]]]) -> dst"},
    {"fastNlMeansDenoisingColoredMulti", (PyCFunction)pyopencv_fastNlMeansDenoisingColoredMulti, METH_VARARGS | METH_KEYWORDS, "fastNlMeansDenoisingColoredMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize[, dst[, h[, hColor[, templateWindowSize[, searchWindowSize]]]]]) -> dst"},
    {"fastNlMeansDenoisingMulti", (PyCFunction)pyopencv_fastNlMeansDenoisingMulti, METH_VARARGS | METH_KEYWORDS, "fastNlMeansDenoisingMulti(srcImgs, imgToDenoiseIndex, temporalWindowSize[, dst[, h[, templateWindowSize[, searchWindowSize]]]]) -> dst"},
    {"fillConvexPoly", (PyCFunction)pyopencv_fillConvexPoly, METH_VARARGS | METH_KEYWORDS, "fillConvexPoly(img, points, color[, lineType[, shift]]) -> img"},
    {"fillPoly", (PyCFunction)pyopencv_fillPoly, METH_VARARGS | METH_KEYWORDS, "fillPoly(img, pts, color[, lineType[, shift[, offset]]]) -> img"},
    {"filter2D", (PyCFunction)pyopencv_filter2D, METH_VARARGS | METH_KEYWORDS, "filter2D(src, ddepth, kernel[, dst[, anchor[, delta[, borderType]]]]) -> dst"},
    {"filterSpeckles", (PyCFunction)pyopencv_filterSpeckles, METH_VARARGS | METH_KEYWORDS, "filterSpeckles(img, newVal, maxSpeckleSize, maxDiff[, buf]) -> img, buf"},
    {"findChessboardCorners", (PyCFunction)pyopencv_findChessboardCorners, METH_VARARGS | METH_KEYWORDS, "findChessboardCorners(image, patternSize[, corners[, flags]]) -> retval, corners"},
    {"findCirclesGrid", (PyCFunction)pyopencv_findCirclesGrid, METH_VARARGS | METH_KEYWORDS, "findCirclesGrid(image, patternSize[, centers[, flags[, blobDetector]]]) -> retval, centers"},
    {"findContours", (PyCFunction)pyopencv_findContours, METH_VARARGS | METH_KEYWORDS, "findContours(image, mode, method[, contours[, hierarchy[, offset]]]) -> image, contours, hierarchy"},
    {"findDataMatrix", (PyCFunction)pyopencv_findDataMatrix, METH_VARARGS | METH_KEYWORDS, "findDataMatrix(image[, corners[, dmtx]]) -> codes, corners, dmtx"},
    {"findEssentialMat", (PyCFunction)pyopencv_findEssentialMat, METH_VARARGS | METH_KEYWORDS, "findEssentialMat(points1, points2[, focal[, pp[, method[, prob[, threshold[, mask]]]]]]) -> retval, mask"},
    {"findFundamentalMat", (PyCFunction)pyopencv_findFundamentalMat, METH_VARARGS | METH_KEYWORDS, "findFundamentalMat(points1, points2[, method[, param1[, param2[, mask]]]]) -> retval, mask"},
    {"findHomography", (PyCFunction)pyopencv_findHomography, METH_VARARGS | METH_KEYWORDS, "findHomography(srcPoints, dstPoints[, method[, ransacReprojThreshold[, mask]]]) -> retval, mask"},
    {"findNonZero", (PyCFunction)pyopencv_findNonZero, METH_VARARGS | METH_KEYWORDS, "findNonZero(src[, idx]) -> idx"},
    {"findTransformECC", (PyCFunction)pyopencv_findTransformECC, METH_VARARGS | METH_KEYWORDS, "findTransformECC(templateImage, inputImage, warpMatrix[, motionType[, criteria]]) -> retval, warpMatrix"},
    {"fitEllipse", (PyCFunction)pyopencv_fitEllipse, METH_VARARGS | METH_KEYWORDS, "fitEllipse(points) -> retval"},
    {"fitLine", (PyCFunction)pyopencv_fitLine, METH_VARARGS | METH_KEYWORDS, "fitLine(points, distType, param, reps, aeps[, line]) -> line"},
    {"flip", (PyCFunction)pyopencv_flip, METH_VARARGS | METH_KEYWORDS, "flip(src, flipCode[, dst]) -> dst"},
    {"floodFill", (PyCFunction)pyopencv_floodFill, METH_VARARGS | METH_KEYWORDS, "floodFill(image, mask, seedPoint, newVal[, loDiff[, upDiff[, flags]]]) -> retval, image, mask, rect"},
    {"gemm", (PyCFunction)pyopencv_gemm, METH_VARARGS | METH_KEYWORDS, "gemm(src1, src2, alpha, src3, gamma[, dst[, flags]]) -> dst"},
    {"getAffineTransform", (PyCFunction)pyopencv_getAffineTransform, METH_VARARGS | METH_KEYWORDS, "getAffineTransform(src, dst) -> retval"},
    {"getBuildInformation", (PyCFunction)pyopencv_getBuildInformation, METH_VARARGS | METH_KEYWORDS, "getBuildInformation() -> retval"},
    {"getCPUTickCount", (PyCFunction)pyopencv_getCPUTickCount, METH_VARARGS | METH_KEYWORDS, "getCPUTickCount() -> retval"},
    {"getDefaultNewCameraMatrix", (PyCFunction)pyopencv_getDefaultNewCameraMatrix, METH_VARARGS | METH_KEYWORDS, "getDefaultNewCameraMatrix(cameraMatrix[, imgsize[, centerPrincipalPoint]]) -> retval"},
    {"getDerivKernels", (PyCFunction)pyopencv_getDerivKernels, METH_VARARGS | METH_KEYWORDS, "getDerivKernels(dx, dy, ksize[, kx[, ky[, normalize[, ktype]]]]) -> kx, ky"},
    {"getGaborKernel", (PyCFunction)pyopencv_getGaborKernel, METH_VARARGS | METH_KEYWORDS, "getGaborKernel(ksize, sigma, theta, lambd, gamma[, psi[, ktype]]) -> retval"},
    {"getGaussianKernel", (PyCFunction)pyopencv_getGaussianKernel, METH_VARARGS | METH_KEYWORDS, "getGaussianKernel(ksize, sigma[, ktype]) -> retval"},
    {"getNumberOfCPUs", (PyCFunction)pyopencv_getNumberOfCPUs, METH_VARARGS | METH_KEYWORDS, "getNumberOfCPUs() -> retval"},
    {"getOptimalDFTSize", (PyCFunction)pyopencv_getOptimalDFTSize, METH_VARARGS | METH_KEYWORDS, "getOptimalDFTSize(vecsize) -> retval"},
    {"getOptimalNewCameraMatrix", (PyCFunction)pyopencv_getOptimalNewCameraMatrix, METH_VARARGS | METH_KEYWORDS, "getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, alpha[, newImgSize[, centerPrincipalPoint]]) -> retval, validPixROI"},
    {"getPerspectiveTransform", (PyCFunction)pyopencv_getPerspectiveTransform, METH_VARARGS | METH_KEYWORDS, "getPerspectiveTransform(src, dst) -> retval"},
    {"getRectSubPix", (PyCFunction)pyopencv_getRectSubPix, METH_VARARGS | METH_KEYWORDS, "getRectSubPix(image, patchSize, center[, patch[, patchType]]) -> patch"},
    {"getRotationMatrix2D", (PyCFunction)pyopencv_getRotationMatrix2D, METH_VARARGS | METH_KEYWORDS, "getRotationMatrix2D(center, angle, scale) -> retval"},
    {"getStructuringElement", (PyCFunction)pyopencv_getStructuringElement, METH_VARARGS | METH_KEYWORDS, "getStructuringElement(shape, ksize[, anchor]) -> retval"},
    {"getTextSize", (PyCFunction)pyopencv_getTextSize, METH_VARARGS | METH_KEYWORDS, "getTextSize(text, fontFace, fontScale, thickness) -> retval, baseLine"},
    {"getTickCount", (PyCFunction)pyopencv_getTickCount, METH_VARARGS | METH_KEYWORDS, "getTickCount() -> retval"},
    {"getTickFrequency", (PyCFunction)pyopencv_getTickFrequency, METH_VARARGS | METH_KEYWORDS, "getTickFrequency() -> retval"},
    {"getTrackbarPos", (PyCFunction)pyopencv_getTrackbarPos, METH_VARARGS | METH_KEYWORDS, "getTrackbarPos(trackbarname, winname) -> retval"},
    {"getValidDisparityROI", (PyCFunction)pyopencv_getValidDisparityROI, METH_VARARGS | METH_KEYWORDS, "getValidDisparityROI(roi1, roi2, minDisparity, numberOfDisparities, SADWindowSize) -> retval"},
    {"getWindowProperty", (PyCFunction)pyopencv_getWindowProperty, METH_VARARGS | METH_KEYWORDS, "getWindowProperty(winname, prop_id) -> retval"},
    {"goodFeaturesToTrack", (PyCFunction)pyopencv_goodFeaturesToTrack, METH_VARARGS | METH_KEYWORDS, "goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance[, corners[, mask[, blockSize[, useHarrisDetector[, k]]]]]) -> corners"},
    {"grabCut", (PyCFunction)pyopencv_grabCut, METH_VARARGS | METH_KEYWORDS, "grabCut(img, mask, rect, bgdModel, fgdModel, iterCount[, mode]) -> mask, bgdModel, fgdModel"},
    {"groupRectangles", (PyCFunction)pyopencv_groupRectangles, METH_VARARGS | METH_KEYWORDS, "groupRectangles(rectList, groupThreshold[, eps]) -> rectList, weights"},
    {"hconcat", (PyCFunction)pyopencv_hconcat, METH_VARARGS | METH_KEYWORDS, "hconcat(src[, dst]) -> dst"},
    {"idct", (PyCFunction)pyopencv_idct, METH_VARARGS | METH_KEYWORDS, "idct(src[, dst[, flags]]) -> dst"},
    {"idft", (PyCFunction)pyopencv_idft, METH_VARARGS | METH_KEYWORDS, "idft(src[, dst[, flags[, nonzeroRows]]]) -> dst"},
    {"illuminationChange", (PyCFunction)pyopencv_illuminationChange, METH_VARARGS | METH_KEYWORDS, "illuminationChange(src, mask[, dst[, alpha[, beta]]]) -> dst"},
    {"imdecode", (PyCFunction)pyopencv_imdecode, METH_VARARGS | METH_KEYWORDS, "imdecode(buf, flags) -> retval"},
    {"imencode", (PyCFunction)pyopencv_imencode, METH_VARARGS | METH_KEYWORDS, "imencode(ext, img[, params]) -> retval, buf"},
    {"imread", (PyCFunction)pyopencv_imread, METH_VARARGS | METH_KEYWORDS, "imread(filename[, flags]) -> retval"},
    {"imshow", (PyCFunction)pyopencv_imshow, METH_VARARGS | METH_KEYWORDS, "imshow(winname, mat) -> None"},
    {"imwrite", (PyCFunction)pyopencv_imwrite, METH_VARARGS | METH_KEYWORDS, "imwrite(filename, img[, params]) -> retval"},
    {"inRange", (PyCFunction)pyopencv_inRange, METH_VARARGS | METH_KEYWORDS, "inRange(src, lowerb, upperb[, dst]) -> dst"},
    {"initCameraMatrix2D", (PyCFunction)pyopencv_initCameraMatrix2D, METH_VARARGS | METH_KEYWORDS, "initCameraMatrix2D(objectPoints, imagePoints, imageSize[, aspectRatio]) -> retval"},
    {"initUndistortRectifyMap", (PyCFunction)pyopencv_initUndistortRectifyMap, METH_VARARGS | METH_KEYWORDS, "initUndistortRectifyMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type[, map1[, map2]]) -> map1, map2"},
    {"initWideAngleProjMap", (PyCFunction)pyopencv_initWideAngleProjMap, METH_VARARGS | METH_KEYWORDS, "initWideAngleProjMap(cameraMatrix, distCoeffs, imageSize, destImageWidth, m1type[, map1[, map2[, projType[, alpha]]]]) -> retval, map1, map2"},
    {"inpaint", (PyCFunction)pyopencv_inpaint, METH_VARARGS | METH_KEYWORDS, "inpaint(src, inpaintMask, inpaintRadius, flags[, dst]) -> dst"},
    {"insertChannel", (PyCFunction)pyopencv_insertChannel, METH_VARARGS | METH_KEYWORDS, "insertChannel(src, dst, coi) -> dst"},
    {"integral", (PyCFunction)pyopencv_integral, METH_VARARGS | METH_KEYWORDS, "integral(src[, sum[, sdepth]]) -> sum"},
    {"integral2", (PyCFunction)pyopencv_integral2, METH_VARARGS | METH_KEYWORDS, "integral2(src[, sum[, sqsum[, sdepth[, sqdepth]]]]) -> sum, sqsum"},
    {"integral3", (PyCFunction)pyopencv_integral3, METH_VARARGS | METH_KEYWORDS, "integral3(src[, sum[, sqsum[, tilted[, sdepth[, sqdepth]]]]]) -> sum, sqsum, tilted"},
    {"intersectConvexConvex", (PyCFunction)pyopencv_intersectConvexConvex, METH_VARARGS | METH_KEYWORDS, "intersectConvexConvex(_p1, _p2[, _p12[, handleNested]]) -> retval, _p12"},
    {"invert", (PyCFunction)pyopencv_invert, METH_VARARGS | METH_KEYWORDS, "invert(src[, dst[, flags]]) -> retval, dst"},
    {"invertAffineTransform", (PyCFunction)pyopencv_invertAffineTransform, METH_VARARGS | METH_KEYWORDS, "invertAffineTransform(M[, iM]) -> iM"},
    {"isContourConvex", (PyCFunction)pyopencv_isContourConvex, METH_VARARGS | METH_KEYWORDS, "isContourConvex(contour) -> retval"},
    {"kmeans", (PyCFunction)pyopencv_kmeans, METH_VARARGS | METH_KEYWORDS, "kmeans(data, K, bestLabels, criteria, attempts, flags[, centers]) -> retval, bestLabels, centers"},
    {"line", (PyCFunction)pyopencv_line, METH_VARARGS | METH_KEYWORDS, "line(img, pt1, pt2, color[, thickness[, lineType[, shift]]]) -> img"},
    {"linearPolar", (PyCFunction)pyopencv_linearPolar, METH_VARARGS | METH_KEYWORDS, "linearPolar(src, center, maxRadius, flags[, dst]) -> dst"},
    {"log", (PyCFunction)pyopencv_log, METH_VARARGS | METH_KEYWORDS, "log(src[, dst]) -> dst"},
    {"logPolar", (PyCFunction)pyopencv_logPolar, METH_VARARGS | METH_KEYWORDS, "logPolar(src, center, M, flags[, dst]) -> dst"},
    {"magnitude", (PyCFunction)pyopencv_magnitude, METH_VARARGS | METH_KEYWORDS, "magnitude(x, y[, magnitude]) -> magnitude"},
    {"matMulDeriv", (PyCFunction)pyopencv_matMulDeriv, METH_VARARGS | METH_KEYWORDS, "matMulDeriv(A, B[, dABdA[, dABdB]]) -> dABdA, dABdB"},
    {"matchShapes", (PyCFunction)pyopencv_matchShapes, METH_VARARGS | METH_KEYWORDS, "matchShapes(contour1, contour2, method, parameter) -> retval"},
    {"matchTemplate", (PyCFunction)pyopencv_matchTemplate, METH_VARARGS | METH_KEYWORDS, "matchTemplate(image, templ, method[, result]) -> result"},
    {"max", (PyCFunction)pyopencv_max, METH_VARARGS | METH_KEYWORDS, "max(src1, src2[, dst]) -> dst"},
    {"mean", (PyCFunction)pyopencv_mean, METH_VARARGS | METH_KEYWORDS, "mean(src[, mask]) -> retval"},
    {"meanShift", (PyCFunction)pyopencv_meanShift, METH_VARARGS | METH_KEYWORDS, "meanShift(probImage, window, criteria) -> retval, window"},
    {"meanStdDev", (PyCFunction)pyopencv_meanStdDev, METH_VARARGS | METH_KEYWORDS, "meanStdDev(src[, mean[, stddev[, mask]]]) -> mean, stddev"},
    {"medianBlur", (PyCFunction)pyopencv_medianBlur, METH_VARARGS | METH_KEYWORDS, "medianBlur(src, ksize[, dst]) -> dst"},
    {"merge", (PyCFunction)pyopencv_merge, METH_VARARGS | METH_KEYWORDS, "merge(mv[, dst]) -> dst"},
    {"min", (PyCFunction)pyopencv_min, METH_VARARGS | METH_KEYWORDS, "min(src1, src2[, dst]) -> dst"},
    {"minAreaRect", (PyCFunction)pyopencv_minAreaRect, METH_VARARGS | METH_KEYWORDS, "minAreaRect(points) -> retval"},
    {"minEnclosingCircle", (PyCFunction)pyopencv_minEnclosingCircle, METH_VARARGS | METH_KEYWORDS, "minEnclosingCircle(points) -> center, radius"},
    {"minEnclosingTriangle", (PyCFunction)pyopencv_minEnclosingTriangle, METH_VARARGS | METH_KEYWORDS, "minEnclosingTriangle(points[, triangle]) -> retval, triangle"},
    {"minMaxLoc", (PyCFunction)pyopencv_minMaxLoc, METH_VARARGS | METH_KEYWORDS, "minMaxLoc(src[, mask]) -> minVal, maxVal, minLoc, maxLoc"},
    {"mixChannels", (PyCFunction)pyopencv_mixChannels, METH_VARARGS | METH_KEYWORDS, "mixChannels(src, dst, fromTo) -> dst"},
    {"moments", (PyCFunction)pyopencv_moments, METH_VARARGS | METH_KEYWORDS, "moments(array[, binaryImage]) -> retval"},
    {"morphologyEx", (PyCFunction)pyopencv_morphologyEx, METH_VARARGS | METH_KEYWORDS, "morphologyEx(src, op, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]]) -> dst"},
    {"moveWindow", (PyCFunction)pyopencv_moveWindow, METH_VARARGS | METH_KEYWORDS, "moveWindow(winname, x, y) -> None"},
    {"mulSpectrums", (PyCFunction)pyopencv_mulSpectrums, METH_VARARGS | METH_KEYWORDS, "mulSpectrums(a, b, flags[, c[, conjB]]) -> c"},
    {"mulTransposed", (PyCFunction)pyopencv_mulTransposed, METH_VARARGS | METH_KEYWORDS, "mulTransposed(src, aTa[, dst[, delta[, scale[, dtype]]]]) -> dst"},
    {"multiply", (PyCFunction)pyopencv_multiply, METH_VARARGS | METH_KEYWORDS, "multiply(src1, src2[, dst[, scale[, dtype]]]) -> dst"},
    {"namedWindow", (PyCFunction)pyopencv_namedWindow, METH_VARARGS | METH_KEYWORDS, "namedWindow(winname[, flags]) -> None"},
    {"norm", (PyCFunction)pyopencv_norm, METH_VARARGS | METH_KEYWORDS, "norm(src1[, normType[, mask]]) -> retval  or  norm(src1, src2[, normType[, mask]]) -> retval"},
    {"normalize", (PyCFunction)pyopencv_normalize, METH_VARARGS | METH_KEYWORDS, "normalize(src[, dst[, alpha[, beta[, norm_type[, dtype[, mask]]]]]]) -> dst"},
    {"patchNaNs", (PyCFunction)pyopencv_patchNaNs, METH_VARARGS | METH_KEYWORDS, "patchNaNs(a[, val]) -> a"},
    {"pencilSketch", (PyCFunction)pyopencv_pencilSketch, METH_VARARGS | METH_KEYWORDS, "pencilSketch(src[, dst1[, dst2[, sigma_s[, sigma_r[, shade_factor]]]]]) -> dst1, dst2"},
    {"perspectiveTransform", (PyCFunction)pyopencv_perspectiveTransform, METH_VARARGS | METH_KEYWORDS, "perspectiveTransform(src, m[, dst]) -> dst"},
    {"phase", (PyCFunction)pyopencv_phase, METH_VARARGS | METH_KEYWORDS, "phase(x, y[, angle[, angleInDegrees]]) -> angle"},
    {"phaseCorrelate", (PyCFunction)pyopencv_phaseCorrelate, METH_VARARGS | METH_KEYWORDS, "phaseCorrelate(src1, src2[, window]) -> retval, response"},
    {"pointPolygonTest", (PyCFunction)pyopencv_pointPolygonTest, METH_VARARGS | METH_KEYWORDS, "pointPolygonTest(contour, pt, measureDist) -> retval"},
    {"polarToCart", (PyCFunction)pyopencv_polarToCart, METH_VARARGS | METH_KEYWORDS, "polarToCart(magnitude, angle[, x[, y[, angleInDegrees]]]) -> x, y"},
    {"polylines", (PyCFunction)pyopencv_polylines, METH_VARARGS | METH_KEYWORDS, "polylines(img, pts, isClosed, color[, thickness[, lineType[, shift]]]) -> img"},
    {"pow", (PyCFunction)pyopencv_pow, METH_VARARGS | METH_KEYWORDS, "pow(src, power[, dst]) -> dst"},
    {"preCornerDetect", (PyCFunction)pyopencv_preCornerDetect, METH_VARARGS | METH_KEYWORDS, "preCornerDetect(src, ksize[, dst[, borderType]]) -> dst"},
    {"projectPoints", (PyCFunction)pyopencv_projectPoints, METH_VARARGS | METH_KEYWORDS, "projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs[, imagePoints[, jacobian[, aspectRatio]]]) -> imagePoints, jacobian"},
    {"putText", (PyCFunction)pyopencv_putText, METH_VARARGS | METH_KEYWORDS, "putText(img, text, org, fontFace, fontScale, color[, thickness[, lineType[, bottomLeftOrigin]]]) -> img"},
    {"pyrDown", (PyCFunction)pyopencv_pyrDown, METH_VARARGS | METH_KEYWORDS, "pyrDown(src[, dst[, dstsize[, borderType]]]) -> dst"},
    {"pyrMeanShiftFiltering", (PyCFunction)pyopencv_pyrMeanShiftFiltering, METH_VARARGS | METH_KEYWORDS, "pyrMeanShiftFiltering(src, sp, sr[, dst[, maxLevel[, termcrit]]]) -> dst"},
    {"pyrUp", (PyCFunction)pyopencv_pyrUp, METH_VARARGS | METH_KEYWORDS, "pyrUp(src[, dst[, dstsize[, borderType]]]) -> dst"},
    {"randShuffle", (PyCFunction)pyopencv_randShuffle, METH_VARARGS | METH_KEYWORDS, "randShuffle(dst[, iterFactor]) -> dst"},
    {"randn", (PyCFunction)pyopencv_randn, METH_VARARGS | METH_KEYWORDS, "randn(dst, mean, stddev) -> dst"},
    {"randu", (PyCFunction)pyopencv_randu, METH_VARARGS | METH_KEYWORDS, "randu(dst, low, high) -> dst"},
    {"recoverPose", (PyCFunction)pyopencv_recoverPose, METH_VARARGS | METH_KEYWORDS, "recoverPose(E, points1, points2[, R[, t[, focal[, pp[, mask]]]]]) -> retval, R, t, mask"},
    {"rectangle", (PyCFunction)pyopencv_rectangle, METH_VARARGS | METH_KEYWORDS, "rectangle(img, pt1, pt2, color[, thickness[, lineType[, shift]]]) -> img"},
    {"rectify3Collinear", (PyCFunction)pyopencv_rectify3Collinear, METH_VARARGS | METH_KEYWORDS, "rectify3Collinear(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, cameraMatrix3, distCoeffs3, imgpt1, imgpt3, imageSize, R12, T12, R13, T13, alpha, newImgSize, flags[, R1[, R2[, R3[, P1[, P2[, P3[, Q]]]]]]]) -> retval, R1, R2, R3, P1, P2, P3, Q, roi1, roi2"},
    {"reduce", (PyCFunction)pyopencv_reduce, METH_VARARGS | METH_KEYWORDS, "reduce(src, dim, rtype[, dst[, dtype]]) -> dst"},
    {"remap", (PyCFunction)pyopencv_remap, METH_VARARGS | METH_KEYWORDS, "remap(src, map1, map2, interpolation[, dst[, borderMode[, borderValue]]]) -> dst"},
    {"repeat", (PyCFunction)pyopencv_repeat, METH_VARARGS | METH_KEYWORDS, "repeat(src, ny, nx[, dst]) -> dst"},
    {"reprojectImageTo3D", (PyCFunction)pyopencv_reprojectImageTo3D, METH_VARARGS | METH_KEYWORDS, "reprojectImageTo3D(disparity, Q[, _3dImage[, handleMissingValues[, ddepth]]]) -> _3dImage"},
    {"resize", (PyCFunction)pyopencv_resize, METH_VARARGS | METH_KEYWORDS, "resize(src, dsize[, dst[, fx[, fy[, interpolation]]]]) -> dst"},
    {"resizeWindow", (PyCFunction)pyopencv_resizeWindow, METH_VARARGS | METH_KEYWORDS, "resizeWindow(winname, width, height) -> None"},
    {"rotatedRectangleIntersection", (PyCFunction)pyopencv_rotatedRectangleIntersection, METH_VARARGS | METH_KEYWORDS, "rotatedRectangleIntersection(rect1, rect2[, intersectingRegion]) -> retval, intersectingRegion"},
    {"scaleAdd", (PyCFunction)pyopencv_scaleAdd, METH_VARARGS | METH_KEYWORDS, "scaleAdd(src1, alpha, src2[, dst]) -> dst"},
    {"seamlessClone", (PyCFunction)pyopencv_seamlessClone, METH_VARARGS | METH_KEYWORDS, "seamlessClone(src, dst, mask, p, flags[, blend]) -> blend"},
    {"segmentMotion", (PyCFunction)pyopencv_segmentMotion, METH_VARARGS | METH_KEYWORDS, "segmentMotion(mhi, timestamp, segThresh[, segmask]) -> segmask, boundingRects"},
    {"sepFilter2D", (PyCFunction)pyopencv_sepFilter2D, METH_VARARGS | METH_KEYWORDS, "sepFilter2D(src, ddepth, kernelX, kernelY[, dst[, anchor[, delta[, borderType]]]]) -> dst"},
    {"setIdentity", (PyCFunction)pyopencv_setIdentity, METH_VARARGS | METH_KEYWORDS, "setIdentity(mtx[, s]) -> mtx"},
    {"setTrackbarPos", (PyCFunction)pyopencv_setTrackbarPos, METH_VARARGS | METH_KEYWORDS, "setTrackbarPos(trackbarname, winname, pos) -> None"},
    {"setUseOptimized", (PyCFunction)pyopencv_setUseOptimized, METH_VARARGS | METH_KEYWORDS, "setUseOptimized(onoff) -> None"},
    {"setWindowProperty", (PyCFunction)pyopencv_setWindowProperty, METH_VARARGS | METH_KEYWORDS, "setWindowProperty(winname, prop_id, prop_value) -> None"},
    {"softcascade_ChannelFeatureBuilder_create", (PyCFunction)pyopencv_softcascade_ChannelFeatureBuilder_create, METH_VARARGS | METH_KEYWORDS, "softcascade_ChannelFeatureBuilder_create(featureType) -> retval"},
    {"solve", (PyCFunction)pyopencv_solve, METH_VARARGS | METH_KEYWORDS, "solve(src1, src2[, dst[, flags]]) -> retval, dst"},
    {"solveCubic", (PyCFunction)pyopencv_solveCubic, METH_VARARGS | METH_KEYWORDS, "solveCubic(coeffs[, roots]) -> retval, roots"},
    {"solvePnP", (PyCFunction)pyopencv_solvePnP, METH_VARARGS | METH_KEYWORDS, "solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs[, rvec[, tvec[, useExtrinsicGuess[, flags]]]]) -> retval, rvec, tvec"},
    {"solvePnPRansac", (PyCFunction)pyopencv_solvePnPRansac, METH_VARARGS | METH_KEYWORDS, "solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs[, rvec[, tvec[, useExtrinsicGuess[, iterationsCount[, reprojectionError[, minInliersCount[, inliers[, flags]]]]]]]]) -> rvec, tvec, inliers"},
    {"solvePoly", (PyCFunction)pyopencv_solvePoly, METH_VARARGS | METH_KEYWORDS, "solvePoly(coeffs[, roots[, maxIters]]) -> retval, roots"},
    {"sort", (PyCFunction)pyopencv_sort, METH_VARARGS | METH_KEYWORDS, "sort(src, flags[, dst]) -> dst"},
    {"sortIdx", (PyCFunction)pyopencv_sortIdx, METH_VARARGS | METH_KEYWORDS, "sortIdx(src, flags[, dst]) -> dst"},
    {"split", (PyCFunction)pyopencv_split, METH_VARARGS | METH_KEYWORDS, "split(m[, mv]) -> mv"},
    {"sqrBoxFilter", (PyCFunction)pyopencv_sqrBoxFilter, METH_VARARGS | METH_KEYWORDS, "sqrBoxFilter(_src, ddepth, ksize[, _dst[, anchor[, normalize[, borderType]]]]) -> _dst"},
    {"sqrt", (PyCFunction)pyopencv_sqrt, METH_VARARGS | METH_KEYWORDS, "sqrt(src[, dst]) -> dst"},
    {"startWindowThread", (PyCFunction)pyopencv_startWindowThread, METH_VARARGS | METH_KEYWORDS, "startWindowThread() -> retval"},
    {"stereoCalibrate", (PyCFunction)pyopencv_stereoCalibrate, METH_VARARGS | METH_KEYWORDS, "stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize[, R[, T[, E[, F[, flags[, criteria]]]]]]) -> retval, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, R, T, E, F"},
    {"stereoRectify", (PyCFunction)pyopencv_stereoRectify, METH_VARARGS | METH_KEYWORDS, "stereoRectify(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T[, R1[, R2[, P1[, P2[, Q[, flags[, alpha[, newImageSize]]]]]]]]) -> R1, R2, P1, P2, Q, validPixROI1, validPixROI2"},
    {"stereoRectifyUncalibrated", (PyCFunction)pyopencv_stereoRectifyUncalibrated, METH_VARARGS | METH_KEYWORDS, "stereoRectifyUncalibrated(points1, points2, F, imgSize[, H1[, H2[, threshold]]]) -> retval, H1, H2"},
    {"stylization", (PyCFunction)pyopencv_stylization, METH_VARARGS | METH_KEYWORDS, "stylization(src[, dst[, sigma_s[, sigma_r]]]) -> dst"},
    {"subtract", (PyCFunction)pyopencv_subtract, METH_VARARGS | METH_KEYWORDS, "subtract(src1, src2[, dst[, mask[, dtype]]]) -> dst"},
    {"sumElems", (PyCFunction)pyopencv_sumElems, METH_VARARGS | METH_KEYWORDS, "sumElems(src) -> retval"},
    {"textureFlattening", (PyCFunction)pyopencv_textureFlattening, METH_VARARGS | METH_KEYWORDS, "textureFlattening(src, mask[, dst[, low_threshold[, high_threshold[, kernel_size]]]]) -> dst"},
    {"threshold", (PyCFunction)pyopencv_threshold, METH_VARARGS | METH_KEYWORDS, "threshold(src, thresh, maxval, type[, dst]) -> retval, dst"},
    {"trace", (PyCFunction)pyopencv_trace, METH_VARARGS | METH_KEYWORDS, "trace(mtx) -> retval"},
    {"transform", (PyCFunction)pyopencv_transform, METH_VARARGS | METH_KEYWORDS, "transform(src, m[, dst]) -> dst"},
    {"transpose", (PyCFunction)pyopencv_transpose, METH_VARARGS | METH_KEYWORDS, "transpose(src[, dst]) -> dst"},
    {"triangulatePoints", (PyCFunction)pyopencv_triangulatePoints, METH_VARARGS | METH_KEYWORDS, "triangulatePoints(projMatr1, projMatr2, projPoints1, projPoints2[, points4D]) -> points4D"},
    {"undistort", (PyCFunction)pyopencv_undistort, METH_VARARGS | METH_KEYWORDS, "undistort(src, cameraMatrix, distCoeffs[, dst[, newCameraMatrix]]) -> dst"},
    {"undistortPoints", (PyCFunction)pyopencv_undistortPoints, METH_VARARGS | METH_KEYWORDS, "undistortPoints(src, cameraMatrix, distCoeffs[, dst[, R[, P]]]) -> dst"},
    {"updateMotionHistory", (PyCFunction)pyopencv_updateMotionHistory, METH_VARARGS | METH_KEYWORDS, "updateMotionHistory(silhouette, mhi, timestamp, duration) -> mhi"},
    {"useOptimized", (PyCFunction)pyopencv_useOptimized, METH_VARARGS | METH_KEYWORDS, "useOptimized() -> retval"},
    {"validateDisparity", (PyCFunction)pyopencv_validateDisparity, METH_VARARGS | METH_KEYWORDS, "validateDisparity(disparity, cost, minDisparity, numberOfDisparities[, disp12MaxDisp]) -> disparity"},
    {"vconcat", (PyCFunction)pyopencv_vconcat, METH_VARARGS | METH_KEYWORDS, "vconcat(src[, dst]) -> dst"},
    {"waitKey", (PyCFunction)pyopencv_waitKey, METH_VARARGS | METH_KEYWORDS, "waitKey([, delay]) -> retval"},
    {"warpAffine", (PyCFunction)pyopencv_warpAffine, METH_VARARGS | METH_KEYWORDS, "warpAffine(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) -> dst"},
    {"warpPerspective", (PyCFunction)pyopencv_warpPerspective, METH_VARARGS | METH_KEYWORDS, "warpPerspective(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) -> dst"},
    {"watershed", (PyCFunction)pyopencv_watershed, METH_VARARGS | METH_KEYWORDS, "watershed(image, markers) -> markers"},
