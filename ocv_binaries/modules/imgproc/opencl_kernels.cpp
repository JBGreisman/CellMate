// This file is auto-generated. Do not edit!

#include "precomp.hpp"
#include "opencl_kernels.hpp"

namespace cv
{
namespace ocl
{
namespace imgproc
{

const struct ProgramEntry accumulate={"accumulate",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void accumulate(__global const uchar * srcptr, int src_step, int src_offset,\n"
"#ifdef ACCUMULATE_PRODUCT\n"
"__global const uchar * src2ptr, int src2_step, int src2_offset,\n"
"#endif\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols\n"
"#ifdef ACCUMULATE_WEIGHTED\n"
", dstT alpha\n"
"#endif\n"
"#ifdef HAVE_MASK\n"
", __global const uchar * mask, int mask_step, int mask_offset\n"
"#endif\n"
")\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int src_index = mad24(y, src_step, src_offset + x * cn * (int)sizeof(srcT));\n"
"#ifdef HAVE_MASK\n"
"int mask_index = mad24(y, mask_step, mask_offset + x);\n"
"mask += mask_index;\n"
"#endif\n"
"int dst_index = mad24(y, dst_step, dst_offset + x * cn * (int)sizeof(dstT));\n"
"__global const srcT * src = (__global const srcT *)(srcptr + src_index);\n"
"#ifdef ACCUMULATE_PRODUCT\n"
"int src2_index = mad24(y, src2_step, src2_offset + x * cn * (int)sizeof(srcT));\n"
"__global const srcT * src2 = (__global const srcT *)(src2ptr + src2_index);\n"
"#endif\n"
"__global dstT * dst = (__global dstT *)(dstptr + dst_index);\n"
"#pragma unroll\n"
"for (int c = 0; c < cn; ++c)\n"
"#ifdef HAVE_MASK\n"
"if (mask[0])\n"
"#endif\n"
"#ifdef ACCUMULATE\n"
"dst[c] += src[c];\n"
"#elif defined ACCUMULATE_SQUARE\n"
"dst[c] += src[c] * src[c];\n"
"#elif defined ACCUMULATE_PRODUCT\n"
"dst[c] += src[c] * src2[c];\n"
"#elif defined ACCUMULATE_WEIGHTED\n"
"dst[c] = (1 - alpha) * dst[c] + src[c] * alpha;\n"
"#else\n"
"#error \"Unknown accumulation type\"\n"
"#endif\n"
"}\n"
"}\n"
, "eec8133ba9e4804357b3fb8de107ad29"};
ProgramSource accumulate_oclsrc(accumulate.programStr);
const struct ProgramEntry bilateral={"bilateral",
"#if cn != 3\n"
"#define loadpix(addr) *(__global const uchar_t *)(addr)\n"
"#define storepix(val, addr)  *(__global uchar_t *)(addr) = val\n"
"#define TSIZE cn\n"
"#else\n"
"#define loadpix(addr) vload3(0, (__global const uchar *)(addr))\n"
"#define storepix(val, addr) vstore3(val, 0, (__global uchar *)(addr))\n"
"#define TSIZE 3\n"
"#endif\n"
"#if cn == 1\n"
"#define SUM(a) a\n"
"#elif cn == 2\n"
"#define SUM(a) a.x + a.y\n"
"#elif cn == 3\n"
"#define SUM(a) a.x + a.y + a.z\n"
"#elif cn == 4\n"
"#define SUM(a) a.x + a.y + a.z + a.w\n"
"#else\n"
"#error \"cn should be <= 4\"\n"
"#endif\n"
"__kernel void bilateral(__global const uchar * src, int src_step, int src_offset,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__constant float * space_weight, __constant int * space_ofs)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < dst_rows && x < dst_cols)\n"
"{\n"
"int src_index = mad24(y + radius, src_step, mad24(x + radius, TSIZE, src_offset));\n"
"int dst_index = mad24(y, dst_step, mad24(x, TSIZE, dst_offset));\n"
"float_t sum = (float_t)(0.0f);\n"
"float wsum = 0.0f;\n"
"#ifdef INTEL_DEVICE\n"
"float_t val0 = convert_float_t(loadpix(src + src_index));\n"
"#else\n"
"int_t val0 = convert_int_t(loadpix(src + src_index));\n"
"#endif\n"
"#pragma unroll\n"
"for (int k = 0; k < maxk; k++ )\n"
"{\n"
"#ifdef INTEL_DEVICE\n"
"float_t val = convert_float_t(loadpix(src + src_index + space_ofs[k]));\n"
"float diff = SUM(fabs(val - val0));\n"
"#else\n"
"int_t val = convert_int_t(loadpix(src + src_index + space_ofs[k]));\n"
"int diff = SUM(abs(val - val0));\n"
"#endif\n"
"float w = space_weight[k] * native_exp((float)(diff * diff * gauss_color_coeff));\n"
"sum += convert_float_t(val) * (float_t)(w);\n"
"wsum += w;\n"
"}\n"
"storepix(convert_uchar_t(sum / (float_t)(wsum)), dst + dst_index);\n"
"}\n"
"}\n"
"#ifdef INTEL_DEVICE\n"
"#if cn == 1\n"
"__kernel void bilateral_float4(__global const uchar * src, int src_step, int src_offset,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__constant float * space_weight, __constant int * space_ofs)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < dst_rows && x < dst_cols / 4 )\n"
"{\n"
"int src_index = ((y + radius) * src_step) + x * 4  + (radius + src_offset);\n"
"int dst_index = (y  * dst_step) +  x * 4 + dst_offset ;\n"
"float4 sum = 0.f, wsum = 0.f;\n"
"float4 val0 = convert_float4(vload4(0, src + src_index));\n"
"#pragma unroll\n"
"for (int k = 0; k < maxk; k++ )\n"
"{\n"
"float4 val = convert_float4(vload4(0, src + src_index + space_ofs[k]));\n"
"float4 w = space_weight[k] * native_exp((val - val0) * (val - val0) * gauss_color_coeff);\n"
"sum += val * w;\n"
"wsum += w;\n"
"}\n"
"sum = sum / wsum + .5f;\n"
"vstore4(convert_uchar4_rtz(sum), 0, dst + dst_index);\n"
"}\n"
"}\n"
"#endif\n"
"#endif\n"
, "1cc12569fdb93cbfa05bb215d3d42e64"};
ProgramSource bilateral_oclsrc(bilateral.programStr);
const struct ProgramEntry blend_linear={"blend_linear",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#define noconvert\n"
"__kernel void blendLinear(__global const uchar * src1ptr, int src1_step, int src1_offset,\n"
"__global const uchar * src2ptr, int src2_step, int src2_offset,\n"
"__global const uchar * weight1, int weight1_step, int weight1_offset,\n"
"__global const uchar * weight2, int weight2_step, int weight2_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, src1_offset + x * cn * (int)sizeof(T));\n"
"int src2_index = mad24(y, src2_step, src2_offset + x * cn * (int)sizeof(T));\n"
"int weight1_index = mad24(y, weight1_step, weight1_offset + x * (int)sizeof(float));\n"
"int weight2_index = mad24(y, weight2_step, weight2_offset + x * (int)sizeof(float));\n"
"int dst_index = mad24(y, dst_step, dst_offset + x * cn * (int)sizeof(T));\n"
"float w1 = *(__global const float *)(weight1 + weight1_index),\n"
"w2 = *(__global const float *)(weight2 + weight2_index);\n"
"float den = w1 + w2 + 1e-5f;\n"
"__global const T * src1 = (__global const T *)(src1ptr + src1_index);\n"
"__global const T * src2 = (__global const T *)(src2ptr + src2_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"#pragma unroll\n"
"for (int i = 0; i < cn; ++i)\n"
"{\n"
"float num = w1 * convert_float(src1[i]) + w2 * convert_float(src2[i]);\n"
"dst[i] = convertToT(num / den);\n"
"}\n"
"}\n"
"}\n"
, "76072b51c3ede4951ee0200aa33297dc"};
ProgramSource blend_linear_oclsrc(blend_linear.programStr);
const struct ProgramEntry boxFilter={"boxFilter",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#if cn != 3\n"
"#define loadpix(addr) *(__global const ST *)(addr)\n"
"#define storepix(val, addr)  *(__global DT *)(addr) = val\n"
"#define SRCSIZE (int)sizeof(ST)\n"
"#define DSTSIZE (int)sizeof(DT)\n"
"#else\n"
"#define loadpix(addr) vload3(0, (__global const ST1 *)(addr))\n"
"#define storepix(val, addr) vstore3(val, 0, (__global DT1 *)(addr))\n"
"#define SRCSIZE (int)sizeof(ST1)*cn\n"
"#define DSTSIZE (int)sizeof(DT1)*cn\n"
"#endif\n"
"#ifdef BORDER_CONSTANT\n"
"#elif defined BORDER_REPLICATE\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n"
"{ \\\n"
"x = max(min(x, maxX - 1), minX); \\\n"
"y = max(min(y, maxY - 1), minY); \\\n"
"}\n"
"#elif defined BORDER_WRAP\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n"
"{ \\\n"
"if (x < minX) \\\n"
"x -= ((x - maxX + 1) / maxX) * maxX; \\\n"
"if (x >= maxX) \\\n"
"x %= maxX; \\\n"
"if (y < minY) \\\n"
"y -= ((y - maxY + 1) / maxY) * maxY; \\\n"
"if (y >= maxY) \\\n"
"y %= maxY; \\\n"
"}\n"
"#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT_101)\n"
"#define EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, delta) \\\n"
"{ \\\n"
"if (maxX - minX == 1) \\\n"
"x = minX; \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if (x < minX) \\\n"
"x = minX - (x - minX) - 1 + delta; \\\n"
"else \\\n"
"x = maxX - 1 - (x - maxX) - delta; \\\n"
"} \\\n"
"while (x >= maxX || x < minX); \\\n"
"\\\n"
"if (maxY - minY == 1) \\\n"
"y = minY; \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if (y < minY) \\\n"
"y = minY - (y - minY) - 1 + delta; \\\n"
"else \\\n"
"y = maxY - 1 - (y - maxY) - delta; \\\n"
"} \\\n"
"while (y >= maxY || y < minY); \\\n"
"}\n"
"#ifdef BORDER_REFLECT\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, 0)\n"
"#elif defined(BORDER_REFLECT_101)\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, 1)\n"
"#endif\n"
"#else\n"
"#error No extrapolation method\n"
"#endif\n"
"#define noconvert\n"
"#ifdef SQR\n"
"#define PROCESS_ELEM(value) (value * value)\n"
"#else\n"
"#define PROCESS_ELEM(value) value\n"
"#endif\n"
"struct RectCoords\n"
"{\n"
"int x1, y1, x2, y2;\n"
"};\n"
"inline WT readSrcPixel(int2 pos, __global const uchar * srcptr, int src_step, const struct RectCoords srcCoords)\n"
"{\n"
"#ifdef BORDER_ISOLATED\n"
"if (pos.x >= srcCoords.x1 && pos.y >= srcCoords.y1 && pos.x < srcCoords.x2 && pos.y < srcCoords.y2)\n"
"#else\n"
"if (pos.x >= 0 && pos.y >= 0 && pos.x < srcCoords.x2 && pos.y < srcCoords.y2)\n"
"#endif\n"
"{\n"
"int src_index = mad24(pos.y, src_step, pos.x * SRCSIZE);\n"
"WT value = convertToWT(loadpix(srcptr + src_index));\n"
"return PROCESS_ELEM(value);\n"
"}\n"
"else\n"
"{\n"
"#ifdef BORDER_CONSTANT\n"
"return (WT)(0);\n"
"#else\n"
"int selected_col = pos.x, selected_row = pos.y;\n"
"EXTRAPOLATE(selected_col, selected_row,\n"
"#ifdef BORDER_ISOLATED\n"
"srcCoords.x1, srcCoords.y1,\n"
"#else\n"
"0, 0,\n"
"#endif\n"
"srcCoords.x2, srcCoords.y2);\n"
"int src_index = mad24(selected_row, src_step, selected_col * SRCSIZE);\n"
"WT value = convertToWT(loadpix(srcptr + src_index));\n"
"return PROCESS_ELEM(value);\n"
"#endif\n"
"}\n"
"}\n"
"__kernel void boxFilter(__global const uchar * srcptr, int src_step, int srcOffsetX, int srcOffsetY, int srcEndX, int srcEndY,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int rows, int cols\n"
"#ifdef NORMALIZE\n"
", float alpha\n"
"#endif\n"
")\n"
"{\n"
"const struct RectCoords srcCoords = { srcOffsetX, srcOffsetY, srcEndX, srcEndY };\n"
"int x = get_local_id(0) + (LOCAL_SIZE_X - (KERNEL_SIZE_X - 1)) * get_group_id(0) - ANCHOR_X;\n"
"int y = get_global_id(1) * BLOCK_SIZE_Y;\n"
"int local_id = get_local_id(0);\n"
"WT data[KERNEL_SIZE_Y];\n"
"__local WT sumOfCols[LOCAL_SIZE_X];\n"
"int2 srcPos = (int2)(srcCoords.x1 + x, srcCoords.y1 + y - ANCHOR_Y);\n"
"#pragma unroll\n"
"for (int sy = 0; sy < KERNEL_SIZE_Y; sy++, srcPos.y++)\n"
"data[sy] = readSrcPixel(srcPos, srcptr, src_step, srcCoords);\n"
"WT tmp_sum = (WT)(0);\n"
"#pragma unroll\n"
"for (int sy = 0; sy < KERNEL_SIZE_Y; sy++)\n"
"tmp_sum += data[sy];\n"
"sumOfCols[local_id] = tmp_sum;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int dst_index = mad24(y, dst_step, mad24(x, DSTSIZE, dst_offset));\n"
"__global DT * dst = (__global DT *)(dstptr + dst_index);\n"
"int sy_index = 0;\n"
"for (int i = 0, stepY = min(rows - y, BLOCK_SIZE_Y); i < stepY; ++i)\n"
"{\n"
"if (local_id >= ANCHOR_X && local_id < LOCAL_SIZE_X - (KERNEL_SIZE_X - 1 - ANCHOR_X) &&\n"
"x >= 0 && x < cols)\n"
"{\n"
"WT total_sum = (WT)(0);\n"
"#pragma unroll\n"
"for (int sx = 0; sx < KERNEL_SIZE_X; sx++)\n"
"total_sum += sumOfCols[local_id + sx - ANCHOR_X];\n"
"#ifdef NORMALIZE\n"
"DT dstval = convertToDT((WT)(alpha) * total_sum);\n"
"#else\n"
"DT dstval = convertToDT(total_sum);\n"
"#endif\n"
"storepix(dstval, dst);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"tmp_sum = sumOfCols[local_id];\n"
"tmp_sum -= data[sy_index];\n"
"data[sy_index] = readSrcPixel(srcPos, srcptr, src_step, srcCoords);\n"
"srcPos.y++;\n"
"tmp_sum += data[sy_index];\n"
"sumOfCols[local_id] = tmp_sum;\n"
"sy_index = sy_index + 1 < KERNEL_SIZE_Y ? sy_index + 1 : 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"dst = (__global DT *)((__global uchar *)dst + dst_step);\n"
"}\n"
"}\n"
, "d3e542270fa2ea1fc3744043dad50cb4"};
ProgramSource boxFilter_oclsrc(boxFilter.programStr);
const struct ProgramEntry calc_back_project={"calc_back_project",
"#define OUT_OF_RANGE -1\n"
"#if histdims == 1\n"
"__kernel void calcLUT(__global const uchar * histptr, int hist_step, int hist_offset, int hist_bins,\n"
"__global int * lut, float scale, __constant float * ranges)\n"
"{\n"
"int x = get_global_id(0);\n"
"float value = convert_float(x);\n"
"if (value > ranges[1] || value < ranges[0])\n"
"lut[x] = OUT_OF_RANGE;\n"
"else\n"
"{\n"
"float lb = ranges[0], ub = ranges[1], gap = (ub - lb) / hist_bins;\n"
"value -= lb;\n"
"int bin = convert_int_sat_rtn(value / gap);\n"
"if (bin >= hist_bins)\n"
"lut[x] = OUT_OF_RANGE;\n"
"else\n"
"{\n"
"int hist_index = mad24(hist_step, bin, hist_offset);\n"
"__global const float * hist = (__global const float *)(histptr + hist_index);\n"
"lut[x] = (int)convert_uchar_sat_rte(hist[0] * scale);\n"
"}\n"
"}\n"
"}\n"
"__kernel void LUT(__global const uchar * src, int src_step, int src_offset,\n"
"__constant int * lut,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int src_index = mad24(y, src_step, src_offset + x * scn);\n"
"int dst_index = mad24(y, dst_step, dst_offset + x);\n"
"int value = lut[src[src_index]];\n"
"dst[dst_index] = value == OUT_OF_RANGE ? 0 : convert_uchar(value);\n"
"}\n"
"}\n"
"#elif histdims == 2\n"
"__kernel void calcLUT(int hist_bins, __global int * lut, int lut_offset,\n"
"__constant float * ranges, int roffset)\n"
"{\n"
"int x = get_global_id(0);\n"
"float value = convert_float(x);\n"
"ranges += roffset;\n"
"lut += lut_offset;\n"
"if (value > ranges[1] || value < ranges[0])\n"
"lut[x] = OUT_OF_RANGE;\n"
"else\n"
"{\n"
"float lb = ranges[0], ub = ranges[1], gap = (ub - lb) / hist_bins;\n"
"value -= lb;\n"
"int bin = convert_int_sat_rtn(value / gap);\n"
"lut[x] = bin >= hist_bins ? OUT_OF_RANGE : bin;\n"
"}\n"
"}\n"
"__kernel void LUT(__global const uchar * src1, int src1_step, int src1_offset,\n"
"__global const uchar * src2, int src2_step, int src2_offset,\n"
"__global const uchar * histptr, int hist_step, int hist_offset,\n"
"__constant int * lut, float scale,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int src1_index = mad24(y, src1_step, src1_offset + x * scn1);\n"
"int src2_index = mad24(y, src2_step, src2_offset + x * scn2);\n"
"int dst_index = mad24(y, dst_step, dst_offset + x);\n"
"int bin1 = lut[src1[src1_index]];\n"
"int bin2 = lut[src2[src2_index] + 256];\n"
"dst[dst_index] = bin1 == OUT_OF_RANGE || bin2 == OUT_OF_RANGE ? 0 :\n"
"convert_uchar_sat_rte(*(__global const float *)(histptr +\n"
"mad24(hist_step, bin1, hist_offset + bin2 * (int)sizeof(float))) * scale);\n"
"}\n"
"}\n"
"#else\n"
"#error \"(nimages <= 2) should be true\"\n"
"#endif\n"
, "a69c4bdfeda12ce56ca8de84e890b3d3"};
ProgramSource calc_back_project_oclsrc(calc_back_project.programStr);
const struct ProgramEntry canny={"canny",
"#ifdef OP_SOBEL\n"
"#if cn != 3\n"
"#define loadpix(addr) convertToIntT(*(__global const ucharT *)(addr))\n"
"#define storepix(val, addr) *(__global shortT *)(addr) = convertToShortT(val)\n"
"#define shortSize (int)sizeof(shortT)\n"
"#else\n"
"#define loadpix(addr) convertToIntT(vload3(0, (__global const uchar *)(addr)))\n"
"#define storepix(val, addr) vstore3(convertToShortT(val), 0, (__global short *)(addr))\n"
"#define shortSize (int)sizeof(short) * cn\n"
"#endif\n"
"__kernel void calcSobelRowPass(__global const uchar * src, int src_step, int src_offset, int rows, int cols,\n"
"__global uchar * dx_buf, int dx_buf_step, int dx_buf_offset,\n"
"__global uchar * dy_buf, int dy_buf_step, int dy_buf_offset)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int lidx = get_local_id(0);\n"
"int lidy = get_local_id(1);\n"
"__local intT smem[16][18];\n"
"smem[lidy][lidx + 1] = loadpix(src + mad24(src_step, min(gidy, rows - 1), mad24(gidx, cn, src_offset)));\n"
"if (lidx == 0)\n"
"{\n"
"smem[lidy][0]  = loadpix(src + mad24(src_step, min(gidy, rows - 1), mad24(max(gidx - 1,  0), cn, src_offset)));\n"
"smem[lidy][17] = loadpix(src + mad24(src_step, min(gidy, rows - 1), mad24(min(gidx + 16, cols - 1), cn, src_offset)));\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (gidy < rows && gidx < cols)\n"
"{\n"
"storepix(smem[lidy][lidx + 2] - smem[lidy][lidx],\n"
"dx_buf + mad24(gidy, dx_buf_step, mad24(gidx, shortSize, dx_buf_offset)));\n"
"storepix(mad24(2, smem[lidy][lidx + 1], smem[lidy][lidx] + smem[lidy][lidx + 2]),\n"
"dy_buf + mad24(gidy, dy_buf_step, mad24(gidx, shortSize, dy_buf_offset)));\n"
"}\n"
"}\n"
"#elif defined OP_MAG_BUF || defined OP_MAG\n"
"inline intT calc(shortT x, shortT y)\n"
"{\n"
"#ifdef L2GRAD\n"
"intT intx = convertToIntT(x), inty = convertToIntT(y);\n"
"return intx * intx + inty * inty;\n"
"#else\n"
"return convertToIntT( (x >= (shortT)(0) ? x : -x) + (y >= (shortT)(0) ? y : -y) );\n"
"#endif\n"
"}\n"
"#ifdef OP_MAG\n"
"__kernel void calcMagnitude(__global const uchar * dxptr, int dx_step, int dx_offset,\n"
"__global const uchar * dyptr, int dy_step, int dy_offset,\n"
"__global uchar * magptr, int mag_step, int mag_offset, int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int dx_index = mad24(dx_step, y, mad24(x, (int)sizeof(short) * cn, dx_offset));\n"
"int dy_index = mad24(dy_step, y, mad24(x, (int)sizeof(short) * cn, dy_offset));\n"
"int mag_index = mad24(mag_step, y + 1, mad24(x + 1, (int)sizeof(int), mag_offset));\n"
"__global short * dx = (__global short *)(dxptr + dx_index);\n"
"__global short * dy = (__global short *)(dyptr + dy_index);\n"
"__global int * mag = (__global int *)(magptr + mag_index);\n"
"int cmag = calc(dx[0], dy[0]);\n"
"#if cn > 1\n"
"short cx = dx[0], cy = dy[0];\n"
"int pmag;\n"
"#pragma unroll\n"
"for (int i = 1; i < cn; ++i)\n"
"{\n"
"pmag = calc(dx[i], dy[i]);\n"
"if (pmag > cmag)\n"
"cmag = pmag, cx = dx[i], cy = dy[i];\n"
"}\n"
"dx[0] = cx, dy[0] = cy;\n"
"#endif\n"
"mag[0] = cmag;\n"
"}\n"
"}\n"
"#elif defined OP_MAG_BUF\n"
"#if cn != 3\n"
"#define loadpix(addr) *(__global const shortT *)(addr)\n"
"#define shortSize (int)sizeof(shortT)\n"
"#else\n"
"#define loadpix(addr) vload3(0, (__global const short *)(addr))\n"
"#define shortSize (int)sizeof(short)*cn\n"
"#endif\n"
"__kernel void calcMagnitude_buf(__global const uchar * dx_buf, int dx_buf_step, int dx_buf_offset,\n"
"__global const uchar * dy_buf, int dy_buf_step, int dy_buf_offset,\n"
"__global uchar * dx, int dx_step, int dx_offset,\n"
"__global uchar * dy, int dy_step, int dy_offset,\n"
"__global uchar * mag, int mag_step, int mag_offset, int rows, int cols)\n"
"{\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int lidx = get_local_id(0);\n"
"int lidy = get_local_id(1);\n"
"__local shortT sdx[18][16];\n"
"__local shortT sdy[18][16];\n"
"sdx[lidy + 1][lidx] = loadpix(dx_buf + mad24(min(gidy, rows - 1), dx_buf_step, mad24(gidx, shortSize, dx_buf_offset)));\n"
"sdy[lidy + 1][lidx] = loadpix(dy_buf + mad24(min(gidy, rows - 1), dy_buf_step, mad24(gidx, shortSize, dy_buf_offset)));\n"
"if (lidy == 0)\n"
"{\n"
"sdx[0][lidx]  = loadpix(dx_buf + mad24(clamp(gidy - 1, 0, rows - 1), dx_buf_step, mad24(gidx, shortSize, dx_buf_offset)));\n"
"sdx[17][lidx] = loadpix(dx_buf + mad24(min(gidy + 16, rows - 1), dx_buf_step, mad24(gidx, shortSize, dx_buf_offset)));\n"
"sdy[0][lidx]  = loadpix(dy_buf + mad24(clamp(gidy - 1, 0, rows - 1), dy_buf_step, mad24(gidx, shortSize, dy_buf_offset)));\n"
"sdy[17][lidx] = loadpix(dy_buf + mad24(min(gidy + 16, rows - 1), dy_buf_step, mad24(gidx, shortSize, dy_buf_offset)));\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (gidx < cols && gidy < rows)\n"
"{\n"
"shortT x = sdx[lidy + 1][lidx] * (shortT)(2) + sdx[lidy][lidx] + sdx[lidy + 2][lidx];\n"
"shortT y = -sdy[lidy][lidx] + sdy[lidy + 2][lidx];\n"
"#if cn == 1\n"
"*(__global short *)(dx + mad24(gidy, dx_step, mad24(gidx, shortSize, dx_offset))) = x;\n"
"*(__global short *)(dy + mad24(gidy, dy_step, mad24(gidx, shortSize, dy_offset))) = y;\n"
"*(__global int *)(mag + mad24(gidy + 1, mag_step, mad24(gidx + 1, (int)sizeof(int), mag_offset))) = calc(x, y);\n"
"#elif cn == 3\n"
"intT magv = calc(x, y);\n"
"short cx = x.x, cy = y.x;\n"
"int cmag = magv.x;\n"
"if (cmag < magv.y)\n"
"cx = x.y, cy = y.y, cmag = magv.y;\n"
"if (cmag < magv.z)\n"
"cx = x.z, cy = y.z, cmag = magv.z;\n"
"*(__global short *)(dx + mad24(gidy, dx_step, mad24(gidx, shortSize, dx_offset))) = cx;\n"
"*(__global short *)(dy + mad24(gidy, dy_step, mad24(gidx, shortSize, dy_offset))) = cy;\n"
"*(__global int *)(mag + mad24(gidy + 1, mag_step, mad24(gidx + 1, (int)sizeof(int), mag_offset))) = cmag;\n"
"#endif\n"
"}\n"
"}\n"
"#endif\n"
"#elif defined OP_MAP\n"
"#define CANNY_SHIFT 15\n"
"#define TG22        (int)(0.4142135623730950488016887242097f*(1<<CANNY_SHIFT) + 0.5f)\n"
"__kernel void calcMap(__global const uchar * dx, int dx_step, int dx_offset,\n"
"__global const uchar * dy, int dy_step, int dy_offset,\n"
"__global const uchar * mag, int mag_step, int mag_offset,\n"
"__global uchar * map, int map_step, int map_offset,\n"
"int rows, int cols, int low_thresh, int high_thresh)\n"
"{\n"
"__local int smem[18][18];\n"
"int gidx = get_global_id(0);\n"
"int gidy = get_global_id(1);\n"
"int lidx = get_local_id(0);\n"
"int lidy = get_local_id(1);\n"
"int grp_idx = get_global_id(0) & 0xFFFFF0;\n"
"int grp_idy = get_global_id(1) & 0xFFFFF0;\n"
"int tid = mad24(lidy, 16, lidx);\n"
"int lx = tid % 18;\n"
"int ly = tid / 18;\n"
"mag += mag_offset;\n"
"if (ly < 14)\n"
"smem[ly][lx] = *(__global const int *)(mag +\n"
"mad24(mag_step, min(grp_idy + ly, rows - 1), (int)sizeof(int) * (grp_idx + lx)));\n"
"if (ly < 4 && grp_idy + ly + 14 <= rows && grp_idx + lx <= cols)\n"
"smem[ly + 14][lx] = *(__global const int *)(mag +\n"
"mad24(mag_step, min(grp_idy + ly + 14, rows - 1), (int)sizeof(int) * (grp_idx + lx)));\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (gidy < rows && gidx < cols)\n"
"{\n"
"int edge_type = 0;\n"
"int m = smem[lidy + 1][lidx + 1];\n"
"if (m > low_thresh)\n"
"{\n"
"short xs = *(__global const short *)(dx + mad24(gidy, dx_step, mad24(gidx, (int)sizeof(short) * cn, dx_offset)));\n"
"short ys = *(__global const short *)(dy + mad24(gidy, dy_step, mad24(gidx, (int)sizeof(short) * cn, dy_offset)));\n"
"int x = abs(xs), y = abs(ys);\n"
"int tg22x = x * TG22;\n"
"y <<= CANNY_SHIFT;\n"
"if (y < tg22x)\n"
"{\n"
"if (m > smem[lidy + 1][lidx] && m >= smem[lidy + 1][lidx + 2])\n"
"edge_type = 1 + (int)(m > high_thresh);\n"
"}\n"
"else\n"
"{\n"
"int tg67x = tg22x + (x << (1 + CANNY_SHIFT));\n"
"if (y > tg67x)\n"
"{\n"
"if (m > smem[lidy][lidx + 1]&& m >= smem[lidy + 2][lidx + 1])\n"
"edge_type = 1 + (int)(m > high_thresh);\n"
"}\n"
"else\n"
"{\n"
"int s = (xs ^ ys) < 0 ? -1 : 1;\n"
"if (m > smem[lidy][lidx + 1 - s]&& m > smem[lidy + 2][lidx + 1 + s])\n"
"edge_type = 1 + (int)(m > high_thresh);\n"
"}\n"
"}\n"
"}\n"
"*(__global int *)(map + mad24(map_step, gidy + 1, mad24(gidx + 1, (int)sizeof(int), + map_offset))) = edge_type;\n"
"}\n"
"}\n"
"#undef CANNY_SHIFT\n"
"#undef TG22\n"
"#elif defined OP_HYST_LOCAL\n"
"struct PtrStepSz\n"
"{\n"
"__global uchar * ptr;\n"
"int step, rows, cols;\n"
"};\n"
"inline int get(struct PtrStepSz data, int y, int x)\n"
"{\n"
"return *(__global int *)(data.ptr + mad24(data.step, y + 1, (int)sizeof(int) * (x + 1)));\n"
"}\n"
"inline void set(struct PtrStepSz data, int y, int x, int value)\n"
"{\n"
"*(__global int *)(data.ptr + mad24(data.step, y + 1, (int)sizeof(int) * (x + 1))) = value;\n"
"}\n"
"__kernel void edgesHysteresisLocal(__global uchar * map_ptr, int map_step, int map_offset,\n"
"__global ushort2 * st, __global unsigned int * counter,\n"
"int rows, int cols)\n"
"{\n"
"struct PtrStepSz map = { map_ptr + map_offset, map_step, rows + 1, cols + 1 };\n"
"__local int smem[18][18];\n"
"int2 blockIdx = (int2)(get_group_id(0), get_group_id(1));\n"
"int2 blockDim = (int2)(get_local_size(0), get_local_size(1));\n"
"int2 threadIdx = (int2)(get_local_id(0), get_local_id(1));\n"
"const int x = blockIdx.x * blockDim.x + threadIdx.x;\n"
"const int y = blockIdx.y * blockDim.y + threadIdx.y;\n"
"smem[threadIdx.y + 1][threadIdx.x + 1] = x < map.cols && y < map.rows ? get(map, y, x) : 0;\n"
"if (threadIdx.y == 0)\n"
"smem[0][threadIdx.x + 1] = x < map.cols ? get(map, y - 1, x) : 0;\n"
"if (threadIdx.y == blockDim.y - 1)\n"
"smem[blockDim.y + 1][threadIdx.x + 1] = y + 1 < map.rows ? get(map, y + 1, x) : 0;\n"
"if (threadIdx.x == 0)\n"
"smem[threadIdx.y + 1][0] = y < map.rows ? get(map, y, x - 1) : 0;\n"
"if (threadIdx.x == blockDim.x - 1)\n"
"smem[threadIdx.y + 1][blockDim.x + 1] = x + 1 < map.cols && y < map.rows ? get(map, y, x + 1) : 0;\n"
"if (threadIdx.x == 0 && threadIdx.y == 0)\n"
"smem[0][0] = y > 0 && x > 0 ? get(map, y - 1, x - 1) : 0;\n"
"if (threadIdx.x == blockDim.x - 1 && threadIdx.y == 0)\n"
"smem[0][blockDim.x + 1] = y > 0 && x + 1 < map.cols ? get(map, y - 1, x + 1) : 0;\n"
"if (threadIdx.x == 0 && threadIdx.y == blockDim.y - 1)\n"
"smem[blockDim.y + 1][0] = y + 1 < map.rows && x > 0 ? get(map, y + 1, x - 1) : 0;\n"
"if (threadIdx.x == blockDim.x - 1 && threadIdx.y == blockDim.y - 1)\n"
"smem[blockDim.y + 1][blockDim.x + 1] = y + 1 < map.rows && x + 1 < map.cols ? get(map, y + 1, x + 1) : 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (x >= cols || y >= rows)\n"
"return;\n"
"int n;\n"
"#pragma unroll\n"
"for (int k = 0; k < 16; ++k)\n"
"{\n"
"n = 0;\n"
"if (smem[threadIdx.y + 1][threadIdx.x + 1] == 1)\n"
"{\n"
"n += smem[threadIdx.y    ][threadIdx.x    ] == 2;\n"
"n += smem[threadIdx.y    ][threadIdx.x + 1] == 2;\n"
"n += smem[threadIdx.y    ][threadIdx.x + 2] == 2;\n"
"n += smem[threadIdx.y + 1][threadIdx.x    ] == 2;\n"
"n += smem[threadIdx.y + 1][threadIdx.x + 2] == 2;\n"
"n += smem[threadIdx.y + 2][threadIdx.x    ] == 2;\n"
"n += smem[threadIdx.y + 2][threadIdx.x + 1] == 2;\n"
"n += smem[threadIdx.y + 2][threadIdx.x + 2] == 2;\n"
"}\n"
"if (n > 0)\n"
"smem[threadIdx.y + 1][threadIdx.x + 1] = 2;\n"
"}\n"
"const int e = smem[threadIdx.y + 1][threadIdx.x + 1];\n"
"set(map, y, x, e);\n"
"n = 0;\n"
"if (e == 2)\n"
"{\n"
"n += smem[threadIdx.y    ][threadIdx.x    ] == 1;\n"
"n += smem[threadIdx.y    ][threadIdx.x + 1] == 1;\n"
"n += smem[threadIdx.y    ][threadIdx.x + 2] == 1;\n"
"n += smem[threadIdx.y + 1][threadIdx.x    ] == 1;\n"
"n += smem[threadIdx.y + 1][threadIdx.x + 2] == 1;\n"
"n += smem[threadIdx.y + 2][threadIdx.x    ] == 1;\n"
"n += smem[threadIdx.y + 2][threadIdx.x + 1] == 1;\n"
"n += smem[threadIdx.y + 2][threadIdx.x + 2] == 1;\n"
"}\n"
"if (n > 0)\n"
"{\n"
"const int ind = atomic_inc(counter);\n"
"st[ind] = (ushort2)(x + 1, y + 1);\n"
"}\n"
"}\n"
"#elif defined OP_HYST_GLOBAL\n"
"__constant int c_dx[8] = {-1,  0,  1, -1, 1, -1, 0, 1};\n"
"__constant int c_dy[8] = {-1, -1, -1,  0, 0,  1, 1, 1};\n"
"#define stack_size 512\n"
"#define map_index mad24(map_step, pos.y, pos.x * (int)sizeof(int))\n"
"__kernel void edgesHysteresisGlobal(__global uchar * map, int map_step, int map_offset,\n"
"__global ushort2 * st1, __global ushort2 * st2, __global int * counter,\n"
"int rows, int cols, int count)\n"
"{\n"
"map += map_offset;\n"
"int lidx = get_local_id(0);\n"
"int grp_idx = get_group_id(0);\n"
"int grp_idy = get_group_id(1);\n"
"__local unsigned int s_counter, s_ind;\n"
"__local ushort2 s_st[stack_size];\n"
"if (lidx == 0)\n"
"s_counter = 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ind = mad24(grp_idy, (int)get_local_size(0), grp_idx);\n"
"if (ind < count)\n"
"{\n"
"ushort2 pos = st1[ind];\n"
"if (lidx < 8)\n"
"{\n"
"pos.x += c_dx[lidx];\n"
"pos.y += c_dy[lidx];\n"
"if (pos.x > 0 && pos.x <= cols && pos.y > 0 && pos.y <= rows && *(__global int *)(map + map_index) == 1)\n"
"{\n"
"*(__global int *)(map + map_index) = 2;\n"
"ind = atomic_inc(&s_counter);\n"
"s_st[ind] = pos;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"while (s_counter > 0 && s_counter <= stack_size - get_local_size(0))\n"
"{\n"
"const int subTaskIdx = lidx >> 3;\n"
"const int portion = min(s_counter, (uint)(get_local_size(0)>> 3));\n"
"if (subTaskIdx < portion)\n"
"pos = s_st[s_counter - 1 - subTaskIdx];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (lidx == 0)\n"
"s_counter -= portion;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (subTaskIdx < portion)\n"
"{\n"
"pos.x += c_dx[lidx & 7];\n"
"pos.y += c_dy[lidx & 7];\n"
"if (pos.x > 0 && pos.x <= cols && pos.y > 0 && pos.y <= rows && *(__global int *)(map + map_index) == 1)\n"
"{\n"
"*(__global int *)(map + map_index) = 2;\n"
"ind = atomic_inc(&s_counter);\n"
"s_st[ind] = pos;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if (s_counter > 0)\n"
"{\n"
"if (lidx == 0)\n"
"{\n"
"ind = atomic_add(counter, s_counter);\n"
"s_ind = ind - s_counter;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"ind = s_ind;\n"
"for (int i = lidx; i < (int)s_counter; i += get_local_size(0))\n"
"st2[ind + i] = s_st[i];\n"
"}\n"
"}\n"
"}\n"
"#undef map_index\n"
"#undef stack_size\n"
"#elif defined OP_EDGES\n"
"__kernel void getEdges(__global const uchar * mapptr, int map_step, int map_offset,\n"
"__global uchar * dst, int dst_step, int dst_offset, int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols)\n"
"{\n"
"int map_index = mad24(map_step, y + 1, mad24(x + 1, (int)sizeof(int), map_offset));\n"
"int dst_index = mad24(dst_step, y, x + dst_offset);\n"
"__global const int * map = (__global const int *)(mapptr + map_index);\n"
"dst[dst_index] = (uchar)(-(map[0] >> 1));\n"
"}\n"
"}\n"
"#endif\n"
, "5f5f125d7845d2828063b0e538de9be3"};
ProgramSource canny_oclsrc(canny.programStr);
const struct ProgramEntry clahe={"clahe",
"#ifndef WAVE_SIZE\n"
"#define WAVE_SIZE 1\n"
"#endif\n"
"inline int calc_lut(__local int* smem, int val, int tid)\n"
"{\n"
"smem[tid] = val;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid == 0)\n"
"for (int i = 1; i < 256; ++i)\n"
"smem[i] += smem[i - 1];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"return smem[tid];\n"
"}\n"
"#ifdef CPU\n"
"inline void reduce(volatile __local int* smem, int val, int tid)\n"
"{\n"
"smem[tid] = val;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 128)\n"
"smem[tid] = val += smem[tid + 128];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 64)\n"
"smem[tid] = val += smem[tid + 64];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 32)\n"
"smem[tid] += smem[tid + 32];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 16)\n"
"smem[tid] += smem[tid + 16];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 8)\n"
"smem[tid] += smem[tid + 8];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 4)\n"
"smem[tid] += smem[tid + 4];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 2)\n"
"smem[tid] += smem[tid + 2];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 1)\n"
"smem[256] = smem[tid] + smem[tid + 1];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"#else\n"
"inline void reduce(__local volatile int* smem, int val, int tid)\n"
"{\n"
"smem[tid] = val;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 128)\n"
"smem[tid] = val += smem[tid + 128];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 64)\n"
"smem[tid] = val += smem[tid + 64];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 32)\n"
"{\n"
"smem[tid] += smem[tid + 32];\n"
"#if WAVE_SIZE < 32\n"
"} barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 16)\n"
"{\n"
"#endif\n"
"smem[tid] += smem[tid + 16];\n"
"#if WAVE_SIZE < 16\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (tid < 8)\n"
"{\n"
"#endif\n"
"smem[tid] += smem[tid + 8];\n"
"smem[tid] += smem[tid + 4];\n"
"smem[tid] += smem[tid + 2];\n"
"smem[tid] += smem[tid + 1];\n"
"}\n"
"}\n"
"#endif\n"
"__kernel void calcLut(__global __const uchar * src, const int srcStep,\n"
"const int src_offset, __global uchar * lut,\n"
"const int dstStep, const int dst_offset,\n"
"const int2 tileSize, const int tilesX,\n"
"const int clipLimit, const float lutScale)\n"
"{\n"
"__local int smem[512];\n"
"int tx = get_group_id(0);\n"
"int ty = get_group_id(1);\n"
"int tid = get_local_id(1) * get_local_size(0)\n"
"+ get_local_id(0);\n"
"smem[tid] = 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for (int i = get_local_id(1); i < tileSize.y; i += get_local_size(1))\n"
"{\n"
"__global const uchar* srcPtr = src + mad24(ty * tileSize.y + i, srcStep, tx * tileSize.x + src_offset);\n"
"for (int j = get_local_id(0); j < tileSize.x; j += get_local_size(0))\n"
"{\n"
"const int data = srcPtr[j];\n"
"atomic_inc(&smem[data]);\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int tHistVal = smem[tid];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (clipLimit > 0)\n"
"{\n"
"int clipped = 0;\n"
"if (tHistVal > clipLimit)\n"
"{\n"
"clipped = tHistVal - clipLimit;\n"
"tHistVal = clipLimit;\n"
"}\n"
"reduce(smem, clipped, tid);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#ifdef CPU\n"
"clipped = smem[256];\n"
"#else\n"
"clipped = smem[0];\n"
"#endif\n"
"__local int totalClipped;\n"
"if (tid == 0)\n"
"totalClipped = clipped;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int redistBatch = totalClipped / 256;\n"
"tHistVal += redistBatch;\n"
"int residual = totalClipped - redistBatch * 256;\n"
"if (tid < residual)\n"
"++tHistVal;\n"
"}\n"
"const int lutVal = calc_lut(smem, tHistVal, tid);\n"
"uint ires = (uint)convert_int_rte(lutScale * lutVal);\n"
"lut[(ty * tilesX + tx) * dstStep + tid + dst_offset] =\n"
"convert_uchar(clamp(ires, (uint)0, (uint)255));\n"
"}\n"
"__kernel void transform(__global __const uchar * src, const int srcStep, const int src_offset,\n"
"__global uchar * dst, const int dstStep, const int dst_offset,\n"
"__global uchar * lut, const int lutStep, int lut_offset,\n"
"const int cols, const int rows,\n"
"const int2 tileSize,\n"
"const int tilesX, const int tilesY)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"if (x >= cols || y >= rows)\n"
"return;\n"
"const float tyf = (convert_float(y) / tileSize.y) - 0.5f;\n"
"int ty1 = convert_int_rtn(tyf);\n"
"int ty2 = ty1 + 1;\n"
"const float ya = tyf - ty1;\n"
"ty1 = max(ty1, 0);\n"
"ty2 = min(ty2, tilesY - 1);\n"
"const float txf = (convert_float(x) / tileSize.x) - 0.5f;\n"
"int tx1 = convert_int_rtn(txf);\n"
"int tx2 = tx1 + 1;\n"
"const float xa = txf - tx1;\n"
"tx1 = max(tx1, 0);\n"
"tx2 = min(tx2, tilesX - 1);\n"
"const int srcVal = src[mad24(y, srcStep, x + src_offset)];\n"
"float res = 0;\n"
"res += lut[mad24(ty1 * tilesX + tx1, lutStep, srcVal + lut_offset)] * ((1.0f - xa) * (1.0f - ya));\n"
"res += lut[mad24(ty1 * tilesX + tx2, lutStep, srcVal + lut_offset)] * ((xa) * (1.0f - ya));\n"
"res += lut[mad24(ty2 * tilesX + tx1, lutStep, srcVal + lut_offset)] * ((1.0f - xa) * (ya));\n"
"res += lut[mad24(ty2 * tilesX + tx2, lutStep, srcVal + lut_offset)] * ((xa) * (ya));\n"
"uint ires = (uint)convert_int_rte(res);\n"
"dst[mad24(y, dstStep, x + dst_offset)] = convert_uchar(clamp(ires, (uint)0, (uint)255));\n"
"}\n"
, "1240500336efb8988a25b1da384c217d"};
ProgramSource clahe_oclsrc(clahe.programStr);
const struct ProgramEntry corner={"corner",
"#ifdef BORDER_CONSTANT\n"
"#elif defined BORDER_REPLICATE\n"
"#define EXTRAPOLATE(x, maxV) \\\n"
"{ \\\n"
"x = max(min(x, maxV - 1), 0); \\\n"
"}\n"
"#elif defined BORDER_WRAP\n"
"#define EXTRAPOLATE(x, maxV) \\\n"
"{ \\\n"
"if (x < 0) \\\n"
"x -= ((x - maxV + 1) / maxV) * maxV; \\\n"
"if (x >= maxV) \\\n"
"x %= maxV; \\\n"
"}\n"
"#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT101)\n"
"#define EXTRAPOLATE_(x, maxV, delta) \\\n"
"{ \\\n"
"if (maxV == 1) \\\n"
"x = 0; \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if ( x < 0 ) \\\n"
"x = -x - 1 + delta; \\\n"
"else \\\n"
"x = maxV - 1 - (x - maxV) - delta; \\\n"
"} \\\n"
"while (x >= maxV || x < 0); \\\n"
"}\n"
"#ifdef BORDER_REFLECT\n"
"#define EXTRAPOLATE(x, maxV) EXTRAPOLATE_(x, maxV, 0)\n"
"#else\n"
"#define EXTRAPOLATE(x, maxV) EXTRAPOLATE_(x, maxV, 1)\n"
"#endif\n"
"#else\n"
"#error No extrapolation method\n"
"#endif\n"
"#define THREADS 256\n"
"__kernel void corner(__global const float * Dx, int dx_step, int dx_offset, int dx_whole_rows, int dx_whole_cols,\n"
"__global const float * Dy, int dy_step, int dy_offset, int dy_whole_rows, int dy_whole_cols,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols, float k)\n"
"{\n"
"int col = get_local_id(0);\n"
"int gX = get_group_id(0);\n"
"int gY = get_group_id(1);\n"
"int gly = get_global_id(1);\n"
"int dx_x_off = (dx_offset % dx_step) >> 2;\n"
"int dx_y_off = dx_offset / dx_step;\n"
"int dy_x_off = (dy_offset % dy_step) >> 2;\n"
"int dy_y_off = dy_offset / dy_step;\n"
"int dst_x_off = (dst_offset % dst_step) >> 2;\n"
"int dst_y_off = dst_offset / dst_step;\n"
"int dx_startX = gX * (THREADS-ksX+1) - anX + dx_x_off;\n"
"int dx_startY = (gY << 1) - anY + dx_y_off;\n"
"int dy_startX = gX * (THREADS-ksX+1) - anX + dy_x_off;\n"
"int dy_startY = (gY << 1) - anY + dy_y_off;\n"
"int dst_startX = gX * (THREADS-ksX+1) + dst_x_off;\n"
"int dst_startY = (gY << 1) + dst_y_off;\n"
"float dx_data[ksY+1],dy_data[ksY+1], data[3][ksY+1];\n"
"__local float temp[6][THREADS];\n"
"#ifdef BORDER_CONSTANT\n"
"for (int i=0; i < ksY+1; i++)\n"
"{\n"
"bool dx_con = dx_startX+col >= 0 && dx_startX+col < dx_whole_cols && dx_startY+i >= 0 && dx_startY+i < dx_whole_rows;\n"
"int indexDx = (dx_startY+i)*(dx_step>>2)+(dx_startX+col);\n"
"float dx_s = dx_con ? Dx[indexDx] : 0.0f;\n"
"dx_data[i] = dx_s;\n"
"bool dy_con = dy_startX+col >= 0 && dy_startX+col < dy_whole_cols && dy_startY+i >= 0 && dy_startY+i < dy_whole_rows;\n"
"int indexDy = (dy_startY+i)*(dy_step>>2)+(dy_startX+col);\n"
"float dy_s = dy_con ? Dy[indexDy] : 0.0f;\n"
"dy_data[i] = dy_s;\n"
"data[0][i] = dx_data[i] * dx_data[i];\n"
"data[1][i] = dx_data[i] * dy_data[i];\n"
"data[2][i] = dy_data[i] * dy_data[i];\n"
"}\n"
"#else\n"
"int clamped_col = min(2*dst_cols, col);\n"
"for (int i=0; i < ksY+1; i++)\n"
"{\n"
"int dx_selected_row = dx_startY+i, dx_selected_col = dx_startX+clamped_col;\n"
"EXTRAPOLATE(dx_selected_row, dx_whole_rows)\n"
"EXTRAPOLATE(dx_selected_col, dx_whole_cols)\n"
"dx_data[i] = Dx[dx_selected_row * (dx_step>>2) + dx_selected_col];\n"
"int dy_selected_row = dy_startY+i, dy_selected_col = dy_startX+clamped_col;\n"
"EXTRAPOLATE(dy_selected_row, dy_whole_rows)\n"
"EXTRAPOLATE(dy_selected_col, dy_whole_cols)\n"
"dy_data[i] = Dy[dy_selected_row * (dy_step>>2) + dy_selected_col];\n"
"data[0][i] = dx_data[i] * dx_data[i];\n"
"data[1][i] = dx_data[i] * dy_data[i];\n"
"data[2][i] = dy_data[i] * dy_data[i];\n"
"}\n"
"#endif\n"
"float sum0 = 0.0f, sum1 = 0.0f, sum2 = 0.0f;\n"
"for (int i=1; i < ksY; i++)\n"
"{\n"
"sum0 += data[0][i];\n"
"sum1 += data[1][i];\n"
"sum2 += data[2][i];\n"
"}\n"
"float sum01 = sum0 + data[0][0];\n"
"float sum02 = sum0 + data[0][ksY];\n"
"temp[0][col] = sum01;\n"
"temp[1][col] = sum02;\n"
"float sum11 = sum1 + data[1][0];\n"
"float sum12 = sum1 + data[1][ksY];\n"
"temp[2][col] = sum11;\n"
"temp[3][col] = sum12;\n"
"float sum21 = sum2 + data[2][0];\n"
"float sum22 = sum2 + data[2][ksY];\n"
"temp[4][col] = sum21;\n"
"temp[5][col] = sum22;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (col < (THREADS - (ksX - 1)))\n"
"{\n"
"col += anX;\n"
"int posX = dst_startX - dst_x_off + col - anX;\n"
"int posY = (gly << 1);\n"
"int till = (ksX + 1)%2;\n"
"float tmp_sum[6] = { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f };\n"
"for (int k=0; k<6; k++)\n"
"{\n"
"float temp_sum = 0;\n"
"for (int i=-anX; i<=anX - till; i++)\n"
"temp_sum += temp[k][col+i];\n"
"tmp_sum[k] = temp_sum;\n"
"}\n"
"#ifdef CORNER_HARRIS\n"
"if (posX < dst_cols && (posY) < dst_rows)\n"
"{\n"
"int dst_index = mad24(dst_step, dst_startY, (int)sizeof(float) * (dst_startX + col - anX));\n"
"*(__global float *)(dst + dst_index) =\n"
"tmp_sum[0] * tmp_sum[4] - tmp_sum[2] * tmp_sum[2] - k * (tmp_sum[0] + tmp_sum[4]) * (tmp_sum[0] + tmp_sum[4]);\n"
"}\n"
"if (posX < dst_cols && (posY + 1) < dst_rows)\n"
"{\n"
"int dst_index = mad24(dst_step, dst_startY + 1, (int)sizeof(float) * (dst_startX + col - anX));\n"
"*(__global float *)(dst + dst_index) =\n"
"tmp_sum[1] * tmp_sum[5] - tmp_sum[3] * tmp_sum[3] - k * (tmp_sum[1] + tmp_sum[5]) * (tmp_sum[1] + tmp_sum[5]);\n"
"}\n"
"#elif defined CORNER_MINEIGENVAL\n"
"if (posX < dst_cols && (posY) < dst_rows)\n"
"{\n"
"int dst_index = mad24(dst_step, dst_startY, (int)sizeof(float) * (dst_startX + col - anX));\n"
"float a = tmp_sum[0] * 0.5f;\n"
"float b = tmp_sum[2];\n"
"float c = tmp_sum[4] * 0.5f;\n"
"*(__global float *)(dst + dst_index) = (float)((a+c) - sqrt((a-c)*(a-c) + b*b));\n"
"}\n"
"if (posX < dst_cols && (posY + 1) < dst_rows)\n"
"{\n"
"int dst_index = mad24(dst_step, dst_startY + 1, (int)sizeof(float) * (dst_startX + col - anX));\n"
"float a = tmp_sum[1] * 0.5f;\n"
"float b = tmp_sum[3];\n"
"float c = tmp_sum[5] * 0.5f;\n"
"*(__global float *)(dst + dst_index) = (float)((a+c) - sqrt((a-c)*(a-c) + b*b));\n"
"}\n"
"#else\n"
"#error \"No such corners type\"\n"
"#endif\n"
"}\n"
"}\n"
, "cd6c97339f3c3fd6ed35f0e0f0b4ed1a"};
ProgramSource corner_oclsrc(corner.programStr);
const struct ProgramEntry covardata={"covardata",
"#ifdef BORDER_CONSTANT\n"
"#define EXTRAPOLATE(x, maxV)\n"
"#elif defined BORDER_REPLICATE\n"
"#define EXTRAPOLATE(x, maxV) \\\n"
"{ \\\n"
"(x) = max(min((x), (maxV) - 1), 0); \\\n"
"}\n"
"#elif defined BORDER_WRAP\n"
"#define EXTRAPOLATE(x, maxV) \\\n"
"{ \\\n"
"(x) = ( (x) + (maxV) ) % (maxV); \\\n"
"}\n"
"#elif defined BORDER_REFLECT\n"
"#define EXTRAPOLATE(x, maxV) \\\n"
"{ \\\n"
"(x) = min( mad24((maxV)-1,2,-(x))+1 , max((x),-(x)-1) ); \\\n"
"}\n"
"#elif defined BORDER_REFLECT_101 || defined BORDER_REFLECT101\n"
"#define EXTRAPOLATE(x, maxV) \\\n"
"{ \\\n"
"(x) = min( mad24((maxV)-1,2,-(x)), max((x),-(x)) ); \\\n"
"}\n"
"#else\n"
"#error No extrapolation method\n"
"#endif\n"
"#define SRC(_x,_y) convert_float(((global SRCTYPE*)(Src+(_y)*src_step))[_x])\n"
"#ifdef BORDER_CONSTANT\n"
"#define ELEM(_x,_y,r_edge,t_edge,const_v) (_x)<0 | (_x) >= (r_edge) | (_y)<0 | (_y) >= (t_edge) ? (const_v) : SRC((_x),(_y))\n"
"#else\n"
"#define ELEM(_x,_y,r_edge,t_edge,const_v) SRC((_x),(_y))\n"
"#endif\n"
"#define DSTX(_x,_y) (((global float*)(DstX+DstXOffset+(_y)*DstXPitch))[_x])\n"
"#define DSTY(_x,_y) (((global float*)(DstY+DstYOffset+(_y)*DstYPitch))[_x])\n"
"#define INIT_AND_READ_LOCAL_SOURCE(width, height, fill_const, kernel_border) \\\n"
"int srcX = x + srcOffsetX - (kernel_border); \\\n"
"int srcY = y + srcOffsetY - (kernel_border); \\\n"
"int xb = srcX; \\\n"
"int yb = srcY; \\\n"
"\\\n"
"EXTRAPOLATE(xb, (width)); \\\n"
"EXTRAPOLATE(yb, (height)); \\\n"
"lsmem[liy][lix] = ELEM(xb, yb, (width), (height), (fill_const) ); \\\n"
"\\\n"
"if(lix < ((kernel_border)*2)) \\\n"
"{ \\\n"
"int xb = srcX+BLK_X; \\\n"
"EXTRAPOLATE(xb,(width)); \\\n"
"lsmem[liy][lix+BLK_X] = ELEM(xb, yb, (width), (height), (fill_const) ); \\\n"
"} \\\n"
"if(liy< ((kernel_border)*2)) \\\n"
"{ \\\n"
"int yb = srcY+BLK_Y; \\\n"
"EXTRAPOLATE(yb, (height)); \\\n"
"lsmem[liy+BLK_Y][lix] = ELEM(xb, yb, (width), (height), (fill_const) ); \\\n"
"} \\\n"
"if(lix<((kernel_border)*2) && liy<((kernel_border)*2)) \\\n"
"{ \\\n"
"int xb = srcX+BLK_X; \\\n"
"int yb = srcY+BLK_Y; \\\n"
"EXTRAPOLATE(xb,(width)); \\\n"
"EXTRAPOLATE(yb,(height)); \\\n"
"lsmem[liy+BLK_Y][lix+BLK_X] = ELEM(xb, yb, (width), (height), (fill_const) ); \\\n"
"}\n"
"__kernel void sobel3(__global const uchar * Src, int src_step, int srcOffsetX, int srcOffsetY,\n"
"__global uchar * DstX, int DstXPitch, int DstXOffset,\n"
"__global uchar * DstY, int DstYPitch, int DstYOffset, int dstHeight, int dstWidth,\n"
"int height, int width, float scale)\n"
"{\n"
"__local float lsmem[BLK_Y+2][BLK_X+2];\n"
"int lix = get_local_id(0);\n"
"int liy = get_local_id(1);\n"
"int x = (int)get_global_id(0);\n"
"int y = (int)get_global_id(1);\n"
"INIT_AND_READ_LOCAL_SOURCE(width, height, 0, 1)\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if( x >= dstWidth || y >=dstHeight )  return;\n"
"float u1 = lsmem[liy][lix];\n"
"float u2 = lsmem[liy][lix+1];\n"
"float u3 = lsmem[liy][lix+2];\n"
"float m1 = lsmem[liy+1][lix];\n"
"float m3 = lsmem[liy+1][lix+2];\n"
"float b1 = lsmem[liy+2][lix];\n"
"float b2 = lsmem[liy+2][lix+1];\n"
"float b3 = lsmem[liy+2][lix+2];\n"
"#ifdef SCHARR\n"
"DSTX(x,y) = mad(10.0f, m3 - m1, 3.0f * (u3 - u1 + b3 - b1)) * scale;\n"
"DSTY(x,y) = mad(10.0f, b2 - u2, 3.0f * (b1 - u1 + b3 - u3)) * scale;\n"
"#else\n"
"DSTX(x,y) = mad(2.0f, m3 - m1, u3 - u1 + b3 - b1) * scale;\n"
"DSTY(x,y) = mad(2.0f, b2 - u2, b1 - u1 + b3 - u3) * scale;\n"
"#endif\n"
"}\n"
"__kernel void sobel5(__global const uchar * Src, int src_step, int srcOffsetX, int srcOffsetY,\n"
"__global uchar * DstX, int DstXPitch, int DstXOffset,\n"
"__global uchar * DstY, int DstYPitch, int DstYOffset, int dstHeight, int dstWidth,\n"
"int height, int width, float scale)\n"
"{\n"
"__local float lsmem[BLK_Y+4][BLK_X+4];\n"
"int lix = get_local_id(0);\n"
"int liy = get_local_id(1);\n"
"int x = (int)get_global_id(0);\n"
"int y = (int)get_global_id(1);\n"
"INIT_AND_READ_LOCAL_SOURCE(width, height, 0, 2)\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if( x >= dstWidth || y >=dstHeight )  return;\n"
"float t1 = lsmem[liy][lix];\n"
"float t2 = lsmem[liy][lix+1];\n"
"float t3 = lsmem[liy][lix+2];\n"
"float t4 = lsmem[liy][lix+3];\n"
"float t5 = lsmem[liy][lix+4];\n"
"float u1 = lsmem[liy+1][lix];\n"
"float u2 = lsmem[liy+1][lix+1];\n"
"float u3 = lsmem[liy+1][lix+2];\n"
"float u4 = lsmem[liy+1][lix+3];\n"
"float u5 = lsmem[liy+1][lix+4];\n"
"float m1 = lsmem[liy+2][lix];\n"
"float m2 = lsmem[liy+2][lix+1];\n"
"float m4 = lsmem[liy+2][lix+3];\n"
"float m5 = lsmem[liy+2][lix+4];\n"
"float l1 = lsmem[liy+3][lix];\n"
"float l2 = lsmem[liy+3][lix+1];\n"
"float l3 = lsmem[liy+3][lix+2];\n"
"float l4 = lsmem[liy+3][lix+3];\n"
"float l5 = lsmem[liy+3][lix+4];\n"
"float b1 = lsmem[liy+4][lix];\n"
"float b2 = lsmem[liy+4][lix+1];\n"
"float b3 = lsmem[liy+4][lix+2];\n"
"float b4 = lsmem[liy+4][lix+3];\n"
"float b5 = lsmem[liy+4][lix+4];\n"
"DSTX(x,y) = scale *\n"
"mad(12.0f, m4 - m2,\n"
"mad(6.0f, m5 - m1,\n"
"mad(8.0f, u4 - u2 + l4 - l2,\n"
"mad(4.0f, u5 - u1 + l5 - l1,\n"
"mad(2.0f, t4 - t2 + b4 - b2, t5 - t1 + b5 - b1 )\n"
")\n"
")\n"
")\n"
");\n"
"DSTY(x,y) = scale *\n"
"mad(12.0f, l3 - u3,\n"
"mad(6.0f, b3 - t3,\n"
"mad(8.0f, l2 - u2 + l4 - u4,\n"
"mad(4.0f, b2 - t2 + b4 - t4,\n"
"mad(2.0f, l1 - u1 + l5 - u5, b1 - t1 + b5 - t5 )\n"
")\n"
")\n"
")\n"
");\n"
"}\n"
"__kernel void sobel7(__global const uchar * Src, int src_step, int srcOffsetX, int srcOffsetY,\n"
"__global uchar * DstX, int DstXPitch, int DstXOffset,\n"
"__global uchar * DstY, int DstYPitch, int DstYOffset, int dstHeight, int dstWidth,\n"
"int height, int width, float scale)\n"
"{\n"
"__local float lsmem[BLK_Y+6][BLK_X+6];\n"
"int lix = get_local_id(0);\n"
"int liy = get_local_id(1);\n"
"int x = (int)get_global_id(0);\n"
"int y = (int)get_global_id(1);\n"
"INIT_AND_READ_LOCAL_SOURCE(width, height, 0, 3)\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if( x >= dstWidth || y >=dstHeight )  return;\n"
"float tt1 = lsmem[liy][lix];\n"
"float tt2 = lsmem[liy][lix+1];\n"
"float tt3 = lsmem[liy][lix+2];\n"
"float tt4 = lsmem[liy][lix+3];\n"
"float tt5 = lsmem[liy][lix+4];\n"
"float tt6 = lsmem[liy][lix+5];\n"
"float tt7 = lsmem[liy][lix+6];\n"
"float t1 = lsmem[liy+1][lix];\n"
"float t2 = lsmem[liy+1][lix+1];\n"
"float t3 = lsmem[liy+1][lix+2];\n"
"float t4 = lsmem[liy+1][lix+3];\n"
"float t5 = lsmem[liy+1][lix+4];\n"
"float t6 = lsmem[liy+1][lix+5];\n"
"float t7 = lsmem[liy+1][lix+6];\n"
"float u1 = lsmem[liy+2][lix];\n"
"float u2 = lsmem[liy+2][lix+1];\n"
"float u3 = lsmem[liy+2][lix+2];\n"
"float u4 = lsmem[liy+2][lix+3];\n"
"float u5 = lsmem[liy+2][lix+4];\n"
"float u6 = lsmem[liy+2][lix+5];\n"
"float u7 = lsmem[liy+2][lix+6];\n"
"float m1 = lsmem[liy+3][lix];\n"
"float m2 = lsmem[liy+3][lix+1];\n"
"float m3 = lsmem[liy+3][lix+2];\n"
"float m5 = lsmem[liy+3][lix+4];\n"
"float m6 = lsmem[liy+3][lix+5];\n"
"float m7 = lsmem[liy+3][lix+6];\n"
"float l1 = lsmem[liy+4][lix];\n"
"float l2 = lsmem[liy+4][lix+1];\n"
"float l3 = lsmem[liy+4][lix+2];\n"
"float l4 = lsmem[liy+4][lix+3];\n"
"float l5 = lsmem[liy+4][lix+4];\n"
"float l6 = lsmem[liy+4][lix+5];\n"
"float l7 = lsmem[liy+4][lix+6];\n"
"float b1 = lsmem[liy+5][lix];\n"
"float b2 = lsmem[liy+5][lix+1];\n"
"float b3 = lsmem[liy+5][lix+2];\n"
"float b4 = lsmem[liy+5][lix+3];\n"
"float b5 = lsmem[liy+5][lix+4];\n"
"float b6 = lsmem[liy+5][lix+5];\n"
"float b7 = lsmem[liy+5][lix+6];\n"
"float bb1 = lsmem[liy+6][lix];\n"
"float bb2 = lsmem[liy+6][lix+1];\n"
"float bb3 = lsmem[liy+6][lix+2];\n"
"float bb4 = lsmem[liy+6][lix+3];\n"
"float bb5 = lsmem[liy+6][lix+4];\n"
"float bb6 = lsmem[liy+6][lix+5];\n"
"float bb7 = lsmem[liy+6][lix+6];\n"
"DSTX(x,y) = scale *\n"
"mad(100.0f, m5 - m3,\n"
"mad(80.0f, m6 - m2,\n"
"mad(20.0f, m7 - m1,\n"
"mad(75.0f, u5 - u3 + l5 - l3,\n"
"mad(60.0f, u6 - u2 + l6 - l2,\n"
"mad(15.0f, u7 - u1 + l7 - l1,\n"
"mad(30.0f, t5 - t3 + b5 - b3,\n"
"mad(24.0f, t6 - t2 + b6 - b2,\n"
"mad(6.0f, t7 - t1 + b7 - b1,\n"
"mad(5.0f, tt5 - tt3 + bb5 - bb3,\n"
"mad(4.0f, tt6 - tt2 + bb6 - bb2, tt7 - tt1 + bb7 - bb1 )\n"
")\n"
")\n"
")\n"
")\n"
")\n"
")\n"
")\n"
")\n"
")\n"
");\n"
"DSTY(x,y) = scale *\n"
"mad(100.0f, l4 - u4,\n"
"mad(80.0f, b4 - t4,\n"
"mad(20.0f, bb4 - tt4,\n"
"mad(75.0f, l5 - u5 + l3 - u3,\n"
"mad(60.0f, b5 - t5 + b3 - t3,\n"
"mad(15.0f, bb5 - tt5 + bb3 - tt3,\n"
"mad(30.0f, l6 - u6 + l2 - u2,\n"
"mad(24.0f, b6 - t6 + b2 - t2,\n"
"mad(6.0f, bb6 - tt6 + bb2 - tt2,\n"
"mad(5.0f, l7 - u7 + l1 - u1,\n"
"mad(4.0f, b7 - t7 + b1 - t1, bb7 - tt7 + bb1 - tt1 )\n"
")\n"
")\n"
")\n"
")\n"
")\n"
")\n"
")\n"
")\n"
")\n"
");\n"
"}\n"
, "ff54fc052df3d6446809167005f4e80c"};
ProgramSource covardata_oclsrc(covardata.programStr);
const struct ProgramEntry cvtcolor={"cvtcolor",
"#if depth == 0\n"
"#define DATA_TYPE uchar\n"
"#define MAX_NUM  255\n"
"#define HALF_MAX 128\n"
"#define COEFF_TYPE int\n"
"#define SAT_CAST(num) convert_uchar_sat(num)\n"
"#define DEPTH_0\n"
"#elif depth == 2\n"
"#define DATA_TYPE ushort\n"
"#define MAX_NUM  65535\n"
"#define HALF_MAX 32768\n"
"#define COEFF_TYPE int\n"
"#define SAT_CAST(num) convert_ushort_sat(num)\n"
"#define DEPTH_2\n"
"#elif depth == 5\n"
"#define DATA_TYPE float\n"
"#define MAX_NUM  1.0f\n"
"#define HALF_MAX 0.5f\n"
"#define COEFF_TYPE float\n"
"#define SAT_CAST(num) (num)\n"
"#define DEPTH_5\n"
"#else\n"
"#error \"invalid depth: should be 0 (CV_8U), 2 (CV_16U) or 5 (CV_32F)\"\n"
"#endif\n"
"#ifndef STRIPE_SIZE\n"
"#define STRIPE_SIZE 1\n"
"#endif\n"
"#define CV_DESCALE(x,n) (((x) + (1 << ((n)-1))) >> (n))\n"
"enum\n"
"{\n"
"yuv_shift  = 14,\n"
"xyz_shift  = 12,\n"
"hsv_shift = 12,\n"
"R2Y        = 4899,\n"
"G2Y        = 9617,\n"
"B2Y        = 1868,\n"
"BLOCK_SIZE = 256\n"
"};\n"
"#define scnbytes ((int)sizeof(DATA_TYPE)*scn)\n"
"#define dcnbytes ((int)sizeof(DATA_TYPE)*dcn)\n"
"#ifndef hscale\n"
"#define hscale 0\n"
"#endif\n"
"#ifndef hrange\n"
"#define hrange 0\n"
"#endif\n"
"#if bidx == 0\n"
"#define R_COMP z\n"
"#define G_COMP y\n"
"#define B_COMP x\n"
"#elif bidx == 2\n"
"#define R_COMP x\n"
"#define G_COMP y\n"
"#define B_COMP z\n"
"#elif bidx == 3\n"
"#define R_COMP w\n"
"#define G_COMP w\n"
"#define B_COMP w\n"
"#endif\n"
"#define __CAT(x, y) x##y\n"
"#define CAT(x, y) __CAT(x, y)\n"
"#define DATA_TYPE_4 CAT(DATA_TYPE, 4)\n"
"__kernel void RGB2Gray(__global const uchar* srcptr, int srcstep, int srcoffset,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"__global const DATA_TYPE* src = (__global const DATA_TYPE*)(srcptr + mad24(y, srcstep, srcoffset + x * scnbytes));\n"
"__global DATA_TYPE* dst = (__global DATA_TYPE*)(dstptr + mad24(y, dststep, dstoffset + x * dcnbytes));\n"
"DATA_TYPE_4 src_pix = vload4(0, src);\n"
"#ifdef DEPTH_5\n"
"dst[0] = src_pix.B_COMP * 0.114f + src_pix.G_COMP * 0.587f + src_pix.R_COMP * 0.299f;\n"
"#else\n"
"dst[0] = (DATA_TYPE)CV_DESCALE((src_pix.B_COMP * B2Y + src_pix.G_COMP * G2Y + src_pix.R_COMP * R2Y), yuv_shift);\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__kernel void Gray2RGB(__global const uchar* srcptr, int srcstep, int srcoffset,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"__global const DATA_TYPE* src = (__global const DATA_TYPE*)(srcptr + mad24(y, srcstep, srcoffset + x * scnbytes));\n"
"__global DATA_TYPE* dst = (__global DATA_TYPE*)(dstptr + mad24(y, dststep, dstoffset + x * dcnbytes));\n"
"DATA_TYPE val = src[0];\n"
"dst[0] = dst[1] = dst[2] = val;\n"
"#if dcn == 4\n"
"dst[3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__constant float c_RGB2YUVCoeffs_f[5]  = { 0.114f, 0.587f, 0.299f, 0.492f, 0.877f };\n"
"__constant int   c_RGB2YUVCoeffs_i[5]  = { B2Y, G2Y, R2Y, 8061, 14369 };\n"
"__kernel void RGB2YUV(__global const uchar* srcptr, int srcstep, int srcoffset,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"__global const DATA_TYPE* src = (__global const DATA_TYPE*)(srcptr + mad24(y, srcstep, srcoffset + x * scnbytes));\n"
"__global DATA_TYPE* dst = (__global DATA_TYPE*)(dstptr + mad24(y, dststep, dstoffset + x * dcnbytes));\n"
"DATA_TYPE_4 src_pix = vload4(0, src);\n"
"DATA_TYPE b=src_pix.B_COMP, g=src_pix.G_COMP, r=src_pix.R_COMP;\n"
"#ifdef DEPTH_5\n"
"__constant float * coeffs = c_RGB2YUVCoeffs_f;\n"
"const DATA_TYPE Y  = b * coeffs[0] + g * coeffs[1] + r * coeffs[2];\n"
"const DATA_TYPE U = (b - Y) * coeffs[3] + HALF_MAX;\n"
"const DATA_TYPE V = (r - Y) * coeffs[4] + HALF_MAX;\n"
"#else\n"
"__constant int * coeffs = c_RGB2YUVCoeffs_i;\n"
"const int delta = HALF_MAX * (1 << yuv_shift);\n"
"const int Y = CV_DESCALE(b * coeffs[0] + g * coeffs[1] + r * coeffs[2], yuv_shift);\n"
"const int U = CV_DESCALE((b - Y) * coeffs[3] + delta, yuv_shift);\n"
"const int V = CV_DESCALE((r - Y) * coeffs[4] + delta, yuv_shift);\n"
"#endif\n"
"dst[0] = SAT_CAST( Y );\n"
"dst[1] = SAT_CAST( U );\n"
"dst[2] = SAT_CAST( V );\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__constant float c_YUV2RGBCoeffs_f[5] = { 2.032f, -0.395f, -0.581f, 1.140f };\n"
"__constant int   c_YUV2RGBCoeffs_i[5] = { 33292, -6472, -9519, 18678 };\n"
"__kernel void YUV2RGB(__global const uchar* srcptr, int srcstep, int srcoffset,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"__global const DATA_TYPE* src = (__global const DATA_TYPE*)(srcptr + mad24(y, srcstep, srcoffset + x * scnbytes));\n"
"__global DATA_TYPE* dst = (__global DATA_TYPE*)(dstptr + mad24(y, dststep, dstoffset + x * dcnbytes));\n"
"DATA_TYPE_4 src_pix = vload4(0, src);\n"
"DATA_TYPE Y = src_pix.x, U = src_pix.y, V = src_pix.z;\n"
"#ifdef DEPTH_5\n"
"__constant float * coeffs = c_YUV2RGBCoeffs_f;\n"
"const float r = Y + (V - HALF_MAX) * coeffs[3];\n"
"const float g = Y + (V - HALF_MAX) * coeffs[2] + (U - HALF_MAX) * coeffs[1];\n"
"const float b = Y + (U - HALF_MAX) * coeffs[0];\n"
"#else\n"
"__constant int * coeffs = c_YUV2RGBCoeffs_i;\n"
"const int r = Y + CV_DESCALE((V - HALF_MAX) * coeffs[3], yuv_shift);\n"
"const int g = Y + CV_DESCALE((V - HALF_MAX) * coeffs[2] + (U - HALF_MAX) * coeffs[1], yuv_shift);\n"
"const int b = Y + CV_DESCALE((U - HALF_MAX) * coeffs[0], yuv_shift);\n"
"#endif\n"
"dst[bidx] = SAT_CAST( b );\n"
"dst[1] = SAT_CAST( g );\n"
"dst[bidx^2] = SAT_CAST( r );\n"
"#if dcn == 4\n"
"dst[3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__constant int ITUR_BT_601_CY = 1220542;\n"
"__constant int ITUR_BT_601_CUB = 2116026;\n"
"__constant int ITUR_BT_601_CUG = 409993;\n"
"__constant int ITUR_BT_601_CVG = 852492;\n"
"__constant int ITUR_BT_601_CVR = 1673527;\n"
"__constant int ITUR_BT_601_SHIFT = 20;\n"
"__kernel void YUV2RGB_NV12(__global const uchar* srcptr, int srcstep, int srcoffset,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols / 2)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows / 2 )\n"
"{\n"
"__global const uchar* ysrc = srcptr + mad24(y << 1, srcstep, (x << 1) + srcoffset);\n"
"__global const uchar* usrc = srcptr + mad24(rows + y, srcstep, (x << 1) + srcoffset);\n"
"__global uchar*       dst1 = dstptr + mad24(y << 1, dststep, x * (dcn<<1) + dstoffset);\n"
"__global uchar*       dst2 = dstptr + mad24((y << 1) + 1, dststep, x * (dcn<<1) + dstoffset);\n"
"int Y1 = ysrc[0];\n"
"int Y2 = ysrc[1];\n"
"int Y3 = ysrc[srcstep];\n"
"int Y4 = ysrc[srcstep + 1];\n"
"int U  = usrc[0] - 128;\n"
"int V  = usrc[1] - 128;\n"
"int ruv = (1 << (ITUR_BT_601_SHIFT - 1)) + ITUR_BT_601_CVR * V;\n"
"int guv = (1 << (ITUR_BT_601_SHIFT - 1)) - ITUR_BT_601_CVG * V - ITUR_BT_601_CUG * U;\n"
"int buv = (1 << (ITUR_BT_601_SHIFT - 1)) + ITUR_BT_601_CUB * U;\n"
"Y1 = max(0, Y1 - 16) * ITUR_BT_601_CY;\n"
"dst1[2 - bidx]     = convert_uchar_sat((Y1 + ruv) >> ITUR_BT_601_SHIFT);\n"
"dst1[1]        = convert_uchar_sat((Y1 + guv) >> ITUR_BT_601_SHIFT);\n"
"dst1[bidx] = convert_uchar_sat((Y1 + buv) >> ITUR_BT_601_SHIFT);\n"
"#if dcn == 4\n"
"dst1[3]        = 255;\n"
"#endif\n"
"Y2 = max(0, Y2 - 16) * ITUR_BT_601_CY;\n"
"dst1[dcn + 2 - bidx] = convert_uchar_sat((Y2 + ruv) >> ITUR_BT_601_SHIFT);\n"
"dst1[dcn + 1]        = convert_uchar_sat((Y2 + guv) >> ITUR_BT_601_SHIFT);\n"
"dst1[dcn + bidx] = convert_uchar_sat((Y2 + buv) >> ITUR_BT_601_SHIFT);\n"
"#if dcn == 4\n"
"dst1[7]        = 255;\n"
"#endif\n"
"Y3 = max(0, Y3 - 16) * ITUR_BT_601_CY;\n"
"dst2[2 - bidx]     = convert_uchar_sat((Y3 + ruv) >> ITUR_BT_601_SHIFT);\n"
"dst2[1]        = convert_uchar_sat((Y3 + guv) >> ITUR_BT_601_SHIFT);\n"
"dst2[bidx] = convert_uchar_sat((Y3 + buv) >> ITUR_BT_601_SHIFT);\n"
"#if dcn == 4\n"
"dst2[3]        = 255;\n"
"#endif\n"
"Y4 = max(0, Y4 - 16) * ITUR_BT_601_CY;\n"
"dst2[dcn + 2 - bidx] = convert_uchar_sat((Y4 + ruv) >> ITUR_BT_601_SHIFT);\n"
"dst2[dcn + 1]        = convert_uchar_sat((Y4 + guv) >> ITUR_BT_601_SHIFT);\n"
"dst2[dcn + bidx] = convert_uchar_sat((Y4 + buv) >> ITUR_BT_601_SHIFT);\n"
"#if dcn == 4\n"
"dst2[7]        = 255;\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__constant float c_RGB2YCrCbCoeffs_f[5] = {0.299f, 0.587f, 0.114f, 0.713f, 0.564f};\n"
"__constant int   c_RGB2YCrCbCoeffs_i[5] = {R2Y, G2Y, B2Y, 11682, 9241};\n"
"__kernel void RGB2YCrCb(__global const uchar* srcptr, int srcstep, int srcoffset,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"__global const DATA_TYPE* src = (__global const DATA_TYPE*)(srcptr + mad24(y, srcstep, srcoffset + x * scnbytes));\n"
"__global DATA_TYPE* dst = (__global DATA_TYPE*)(dstptr + mad24(y, dststep, dstoffset + x * dcnbytes));\n"
"DATA_TYPE_4 src_pix = vload4(0, src);\n"
"DATA_TYPE b=src_pix.B_COMP, g=src_pix.G_COMP, r=src_pix.R_COMP;\n"
"#ifdef DEPTH_5\n"
"__constant float * coeffs = c_RGB2YCrCbCoeffs_f;\n"
"DATA_TYPE Y = b * coeffs[2] + g * coeffs[1] + r * coeffs[0];\n"
"DATA_TYPE Cr = (r - Y) * coeffs[3] + HALF_MAX;\n"
"DATA_TYPE Cb = (b - Y) * coeffs[4] + HALF_MAX;\n"
"#else\n"
"__constant int * coeffs = c_RGB2YCrCbCoeffs_i;\n"
"int delta = HALF_MAX * (1 << yuv_shift);\n"
"int Y =  CV_DESCALE(b * coeffs[2] + g * coeffs[1] + r * coeffs[0], yuv_shift);\n"
"int Cr = CV_DESCALE((r - Y) * coeffs[3] + delta, yuv_shift);\n"
"int Cb = CV_DESCALE((b - Y) * coeffs[4] + delta, yuv_shift);\n"
"#endif\n"
"dst[0] = SAT_CAST( Y );\n"
"dst[1] = SAT_CAST( Cr );\n"
"dst[2] = SAT_CAST( Cb );\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__constant float c_YCrCb2RGBCoeffs_f[4] = { 1.403f, -0.714f, -0.344f, 1.773f };\n"
"__constant int   c_YCrCb2RGBCoeffs_i[4] = { 22987, -11698, -5636, 29049 };\n"
"__kernel void YCrCb2RGB(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const DATA_TYPE * srcptr = (__global const DATA_TYPE*)(src + src_idx);\n"
"__global DATA_TYPE * dstptr = (__global DATA_TYPE*)(dst + dst_idx);\n"
"DATA_TYPE_4 src_pix = vload4(0, srcptr);\n"
"DATA_TYPE y = src_pix.x, cr = src_pix.y, cb = src_pix.z;\n"
"#ifdef DEPTH_5\n"
"__constant float * coeff = c_YCrCb2RGBCoeffs_f;\n"
"float r = y + coeff[0] * (cr - HALF_MAX);\n"
"float g = y + coeff[1] * (cr - HALF_MAX) + coeff[2] * (cb - HALF_MAX);\n"
"float b = y + coeff[3] * (cb - HALF_MAX);\n"
"#else\n"
"__constant int * coeff = c_YCrCb2RGBCoeffs_i;\n"
"int r = y + CV_DESCALE(coeff[0] * (cr - HALF_MAX), yuv_shift);\n"
"int g = y + CV_DESCALE(coeff[1] * (cr - HALF_MAX) + coeff[2] * (cb - HALF_MAX), yuv_shift);\n"
"int b = y + CV_DESCALE(coeff[3] * (cb - HALF_MAX), yuv_shift);\n"
"#endif\n"
"dstptr[(bidx^2)] = SAT_CAST(r);\n"
"dstptr[1] = SAT_CAST(g);\n"
"dstptr[bidx] = SAT_CAST(b);\n"
"#if dcn == 4\n"
"dstptr[3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__kernel void RGB2XYZ(__global const uchar * srcptr, int src_step, int src_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset,\n"
"int rows, int cols, __constant COEFF_TYPE * coeffs)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (dx < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (dy < rows)\n"
"{\n"
"int src_idx = mad24(dy, src_step, src_offset + dx * scnbytes);\n"
"int dst_idx = mad24(dy, dst_step, dst_offset + dx * dcnbytes);\n"
"__global const DATA_TYPE * src = (__global const DATA_TYPE *)(srcptr + src_idx);\n"
"__global DATA_TYPE * dst = (__global DATA_TYPE *)(dstptr + dst_idx);\n"
"DATA_TYPE_4 src_pix = vload4(0, src);\n"
"DATA_TYPE r = src_pix.x, g = src_pix.y, b = src_pix.z;\n"
"#ifdef DEPTH_5\n"
"float x = r * coeffs[0] + g * coeffs[1] + b * coeffs[2];\n"
"float y = r * coeffs[3] + g * coeffs[4] + b * coeffs[5];\n"
"float z = r * coeffs[6] + g * coeffs[7] + b * coeffs[8];\n"
"#else\n"
"int x = CV_DESCALE(r * coeffs[0] + g * coeffs[1] + b * coeffs[2], xyz_shift);\n"
"int y = CV_DESCALE(r * coeffs[3] + g * coeffs[4] + b * coeffs[5], xyz_shift);\n"
"int z = CV_DESCALE(r * coeffs[6] + g * coeffs[7] + b * coeffs[8], xyz_shift);\n"
"#endif\n"
"dst[0] = SAT_CAST(x);\n"
"dst[1] = SAT_CAST(y);\n"
"dst[2] = SAT_CAST(z);\n"
"}\n"
"++dy;\n"
"}\n"
"}\n"
"}\n"
"__kernel void XYZ2RGB(__global const uchar * srcptr, int src_step, int src_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset,\n"
"int rows, int cols, __constant COEFF_TYPE * coeffs)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (dx < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (dy < rows)\n"
"{\n"
"int src_idx = mad24(dy, src_step, src_offset + dx * scnbytes);\n"
"int dst_idx = mad24(dy, dst_step, dst_offset + dx * dcnbytes);\n"
"__global const DATA_TYPE * src = (__global const DATA_TYPE *)(srcptr + src_idx);\n"
"__global DATA_TYPE * dst = (__global DATA_TYPE *)(dstptr + dst_idx);\n"
"DATA_TYPE_4 src_pix = vload4(0, src);\n"
"DATA_TYPE x = src_pix.x, y = src_pix.y, z = src_pix.z;\n"
"#ifdef DEPTH_5\n"
"float b = x * coeffs[0] + y * coeffs[1] + z * coeffs[2];\n"
"float g = x * coeffs[3] + y * coeffs[4] + z * coeffs[5];\n"
"float r = x * coeffs[6] + y * coeffs[7] + z * coeffs[8];\n"
"#else\n"
"int b = CV_DESCALE(x * coeffs[0] + y * coeffs[1] + z * coeffs[2], xyz_shift);\n"
"int g = CV_DESCALE(x * coeffs[3] + y * coeffs[4] + z * coeffs[5], xyz_shift);\n"
"int r = CV_DESCALE(x * coeffs[6] + y * coeffs[7] + z * coeffs[8], xyz_shift);\n"
"#endif\n"
"dst[0] = SAT_CAST(b);\n"
"dst[1] = SAT_CAST(g);\n"
"dst[2] = SAT_CAST(r);\n"
"#if dcn == 4\n"
"dst[3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"++dy;\n"
"}\n"
"}\n"
"}\n"
"__kernel void RGB(__global const uchar* srcptr, int src_step, int src_offset,\n"
"__global uchar* dstptr, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const DATA_TYPE * src = (__global const DATA_TYPE *)(srcptr + src_idx);\n"
"__global DATA_TYPE * dst = (__global DATA_TYPE *)(dstptr + dst_idx);\n"
"DATA_TYPE_4 src_pix = vload4(0, src);\n"
"#ifdef REVERSE\n"
"dst[0] = src_pix.z;\n"
"dst[1] = src_pix.y;\n"
"dst[2] = src_pix.x;\n"
"#else\n"
"dst[0] = src_pix.x;\n"
"dst[1] = src_pix.y;\n"
"dst[2] = src_pix.z;\n"
"#endif\n"
"#if dcn == 4\n"
"#if scn == 3\n"
"dst[3] = MAX_NUM;\n"
"#else\n"
"dst[3] = src[3];\n"
"#endif\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__kernel void RGB5x52RGB(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"ushort t = *((__global const ushort*)(src + src_idx));\n"
"#if greenbits == 6\n"
"dst[dst_idx + bidx] = (uchar)(t << 3);\n"
"dst[dst_idx + 1] = (uchar)((t >> 3) & ~3);\n"
"dst[dst_idx + (bidx^2)] = (uchar)((t >> 8) & ~7);\n"
"#else\n"
"dst[dst_idx + bidx] = (uchar)(t << 3);\n"
"dst[dst_idx + 1] = (uchar)((t >> 2) & ~7);\n"
"dst[dst_idx + (bidx^2)] = (uchar)((t >> 7) & ~7);\n"
"#endif\n"
"#if dcn == 4\n"
"#if greenbits == 6\n"
"dst[dst_idx + 3] = 255;\n"
"#else\n"
"dst[dst_idx + 3] = t & 0x8000 ? 255 : 0;\n"
"#endif\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__kernel void RGB2RGB5x5(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"uchar4 src_pix = vload4(0, src + src_idx);\n"
"#if greenbits == 6\n"
"*((__global ushort*)(dst + dst_idx)) = (ushort)((src_pix.B_COMP >> 3)|((src_pix.G_COMP&~3) << 3)|((src_pix.R_COMP&~7) << 8));\n"
"#elif scn == 3\n"
"*((__global ushort*)(dst + dst_idx)) = (ushort)((src_pix.B_COMP >> 3)|((src_pix.G_COMP&~7) << 2)|((src_pix.R_COMP&~7) << 7));\n"
"#else\n"
"*((__global ushort*)(dst + dst_idx)) = (ushort)((src_pix.B_COMP >> 3)|((src_pix.G_COMP&~7) << 2)|\n"
"((src_pix.R_COMP&~7) << 7)|(src_pix.w ? 0x8000 : 0));\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__kernel void BGR5x52Gray(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x);\n"
"int t = *((__global const ushort*)(src + src_idx));\n"
"#if greenbits == 6\n"
"dst[dst_idx] = (uchar)CV_DESCALE(((t << 3) & 0xf8)*B2Y +\n"
"((t >> 3) & 0xfc)*G2Y +\n"
"((t >> 8) & 0xf8)*R2Y, yuv_shift);\n"
"#else\n"
"dst[dst_idx] = (uchar)CV_DESCALE(((t << 3) & 0xf8)*B2Y +\n"
"((t >> 2) & 0xf8)*G2Y +\n"
"((t >> 7) & 0xf8)*R2Y, yuv_shift);\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__kernel void Gray2BGR5x5(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"int t = src[src_idx];\n"
"#if greenbits == 6\n"
"*((__global ushort*)(dst + dst_idx)) = (ushort)((t >> 3) | ((t & ~3) << 3) | ((t & ~7) << 8));\n"
"#else\n"
"t >>= 3;\n"
"*((__global ushort*)(dst + dst_idx)) = (ushort)(t|(t << 5)|(t << 10));\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__constant int sector_data[][3] = { { 1, 3, 0 },\n"
"{ 1, 0, 2 },\n"
"{ 3, 0, 1 },\n"
"{ 0, 2, 1 },\n"
"{ 0, 1, 3 },\n"
"{ 2, 1, 0 } };\n"
"#ifdef DEPTH_0\n"
"__kernel void RGB2HSV(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols,\n"
"__constant int * sdiv_table, __constant int * hdiv_table)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"uchar4 src_pix = vload4(0, src + src_idx);\n"
"int b = src_pix.B_COMP, g = src_pix.G_COMP, r = src_pix.R_COMP;\n"
"int h, s, v = b;\n"
"int vmin = b, diff;\n"
"int vr, vg;\n"
"v = max( v, g );\n"
"v = max( v, r );\n"
"vmin = min( vmin, g );\n"
"vmin = min( vmin, r );\n"
"diff = v - vmin;\n"
"vr = v == r ? -1 : 0;\n"
"vg = v == g ? -1 : 0;\n"
"s = (diff * sdiv_table[v] + (1 << (hsv_shift-1))) >> hsv_shift;\n"
"h = (vr & (g - b)) +\n"
"(~vr & ((vg & (b - r + 2 * diff)) + ((~vg) & (r - g + 4 * diff))));\n"
"h = (h * hdiv_table[diff] + (1 << (hsv_shift-1))) >> hsv_shift;\n"
"h += h < 0 ? hrange : 0;\n"
"dst[dst_idx] = convert_uchar_sat_rte(h);\n"
"dst[dst_idx + 1] = (uchar)s;\n"
"dst[dst_idx + 2] = (uchar)v;\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__kernel void HSV2RGB(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"uchar4 src_pix = vload4(0, src + src_idx);\n"
"float h = src_pix.x, s = src_pix.y*(1/255.f), v = src_pix.z*(1/255.f);\n"
"float b, g, r;\n"
"if (s != 0)\n"
"{\n"
"float tab[4];\n"
"int sector;\n"
"h *= hscale;\n"
"if( h < 0 )\n"
"do h += 6; while( h < 0 );\n"
"else if( h >= 6 )\n"
"do h -= 6; while( h >= 6 );\n"
"sector = convert_int_sat_rtn(h);\n"
"h -= sector;\n"
"if( (unsigned)sector >= 6u )\n"
"{\n"
"sector = 0;\n"
"h = 0.f;\n"
"}\n"
"tab[0] = v;\n"
"tab[1] = v*(1.f - s);\n"
"tab[2] = v*(1.f - s*h);\n"
"tab[3] = v*(1.f - s*(1.f - h));\n"
"b = tab[sector_data[sector][0]];\n"
"g = tab[sector_data[sector][1]];\n"
"r = tab[sector_data[sector][2]];\n"
"}\n"
"else\n"
"b = g = r = v;\n"
"dst[dst_idx + bidx] = convert_uchar_sat_rte(b*255.f);\n"
"dst[dst_idx + 1] = convert_uchar_sat_rte(g*255.f);\n"
"dst[dst_idx + (bidx^2)] = convert_uchar_sat_rte(r*255.f);\n"
"#if dcn == 4\n"
"dst[dst_idx + 3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"#elif defined DEPTH_5\n"
"__kernel void RGB2HSV(__global const uchar* srcptr, int src_step, int src_offset,\n"
"__global uchar* dstptr, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const float * src = (__global const float *)(srcptr + src_idx);\n"
"__global float * dst = (__global float *)(dstptr + dst_idx);\n"
"float4 src_pix = vload4(0, src);\n"
"float b = src_pix.B_COMP, g = src_pix.G_COMP, r = src_pix.R_COMP;\n"
"float h, s, v;\n"
"float vmin, diff;\n"
"v = vmin = r;\n"
"if( v < g ) v = g;\n"
"if( v < b ) v = b;\n"
"if( vmin > g ) vmin = g;\n"
"if( vmin > b ) vmin = b;\n"
"diff = v - vmin;\n"
"s = diff/(float)(fabs(v) + FLT_EPSILON);\n"
"diff = (float)(60.f/(diff + FLT_EPSILON));\n"
"if( v == r )\n"
"h = (g - b)*diff;\n"
"else if( v == g )\n"
"h = (b - r)*diff + 120.f;\n"
"else\n"
"h = (r - g)*diff + 240.f;\n"
"if( h < 0 ) h += 360.f;\n"
"dst[0] = h*hscale;\n"
"dst[1] = s;\n"
"dst[2] = v;\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__kernel void HSV2RGB(__global const uchar* srcptr, int src_step, int src_offset,\n"
"__global uchar* dstptr, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const float * src = (__global const float *)(srcptr + src_idx);\n"
"__global float * dst = (__global float *)(dstptr + dst_idx);\n"
"float4 src_pix = vload4(0, src);\n"
"float h = src_pix.x, s = src_pix.y, v = src_pix.z;\n"
"float b, g, r;\n"
"if (s != 0)\n"
"{\n"
"float tab[4];\n"
"int sector;\n"
"h *= hscale;\n"
"if(h < 0)\n"
"do h += 6; while (h < 0);\n"
"else if (h >= 6)\n"
"do h -= 6; while (h >= 6);\n"
"sector = convert_int_sat_rtn(h);\n"
"h -= sector;\n"
"if ((unsigned)sector >= 6u)\n"
"{\n"
"sector = 0;\n"
"h = 0.f;\n"
"}\n"
"tab[0] = v;\n"
"tab[1] = v*(1.f - s);\n"
"tab[2] = v*(1.f - s*h);\n"
"tab[3] = v*(1.f - s*(1.f - h));\n"
"b = tab[sector_data[sector][0]];\n"
"g = tab[sector_data[sector][1]];\n"
"r = tab[sector_data[sector][2]];\n"
"}\n"
"else\n"
"b = g = r = v;\n"
"dst[bidx] = b;\n"
"dst[1] = g;\n"
"dst[bidx^2] = r;\n"
"#if dcn == 4\n"
"dst[3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"#endif\n"
"#ifdef DEPTH_0\n"
"__kernel void RGB2HLS(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"uchar4 src_pix = vload4(0, src + src_idx);\n"
"float b = src_pix.B_COMP*(1/255.f), g = src_pix.G_COMP*(1/255.f), r = src_pix.R_COMP*(1/255.f);\n"
"float h = 0.f, s = 0.f, l;\n"
"float vmin, vmax, diff;\n"
"vmax = vmin = r;\n"
"if (vmax < g) vmax = g;\n"
"if (vmax < b) vmax = b;\n"
"if (vmin > g) vmin = g;\n"
"if (vmin > b) vmin = b;\n"
"diff = vmax - vmin;\n"
"l = (vmax + vmin)*0.5f;\n"
"if (diff > FLT_EPSILON)\n"
"{\n"
"s = l < 0.5f ? diff/(vmax + vmin) : diff/(2 - vmax - vmin);\n"
"diff = 60.f/diff;\n"
"if( vmax == r )\n"
"h = (g - b)*diff;\n"
"else if( vmax == g )\n"
"h = (b - r)*diff + 120.f;\n"
"else\n"
"h = (r - g)*diff + 240.f;\n"
"if( h < 0.f ) h += 360.f;\n"
"}\n"
"dst[dst_idx] = convert_uchar_sat_rte(h*hscale);\n"
"dst[dst_idx + 1] = convert_uchar_sat_rte(l*255.f);\n"
"dst[dst_idx + 2] = convert_uchar_sat_rte(s*255.f);\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__kernel void HLS2RGB(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"uchar4 src_pix = vload4(0, src + src_idx);\n"
"float h = src_pix.x, l = src_pix.y*(1.f/255.f), s = src_pix.z*(1.f/255.f);\n"
"float b, g, r;\n"
"if (s != 0)\n"
"{\n"
"float tab[4];\n"
"float p2 = l <= 0.5f ? l*(1 + s) : l + s - l*s;\n"
"float p1 = 2*l - p2;\n"
"h *= hscale;\n"
"if( h < 0 )\n"
"do h += 6; while( h < 0 );\n"
"else if( h >= 6 )\n"
"do h -= 6; while( h >= 6 );\n"
"int sector = convert_int_sat_rtn(h);\n"
"h -= sector;\n"
"tab[0] = p2;\n"
"tab[1] = p1;\n"
"tab[2] = p1 + (p2 - p1)*(1-h);\n"
"tab[3] = p1 + (p2 - p1)*h;\n"
"b = tab[sector_data[sector][0]];\n"
"g = tab[sector_data[sector][1]];\n"
"r = tab[sector_data[sector][2]];\n"
"}\n"
"else\n"
"b = g = r = l;\n"
"dst[dst_idx + bidx] = convert_uchar_sat_rte(b*255.f);\n"
"dst[dst_idx + 1] = convert_uchar_sat_rte(g*255.f);\n"
"dst[dst_idx + (bidx^2)] = convert_uchar_sat_rte(r*255.f);\n"
"#if dcn == 4\n"
"dst[dst_idx + 3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"#elif defined DEPTH_5\n"
"__kernel void RGB2HLS(__global const uchar* srcptr, int src_step, int src_offset,\n"
"__global uchar* dstptr, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const float * src = (__global const float *)(srcptr + src_idx);\n"
"__global float * dst = (__global float *)(dstptr + dst_idx);\n"
"float4 src_pix = vload4(0, src);\n"
"float b = src_pix.B_COMP, g = src_pix.G_COMP, r = src_pix.R_COMP;\n"
"float h = 0.f, s = 0.f, l;\n"
"float vmin, vmax, diff;\n"
"vmax = vmin = r;\n"
"if (vmax < g) vmax = g;\n"
"if (vmax < b) vmax = b;\n"
"if (vmin > g) vmin = g;\n"
"if (vmin > b) vmin = b;\n"
"diff = vmax - vmin;\n"
"l = (vmax + vmin)*0.5f;\n"
"if (diff > FLT_EPSILON)\n"
"{\n"
"s = l < 0.5f ? diff/(vmax + vmin) : diff/(2 - vmax - vmin);\n"
"diff = 60.f/diff;\n"
"if( vmax == r )\n"
"h = (g - b)*diff;\n"
"else if( vmax == g )\n"
"h = (b - r)*diff + 120.f;\n"
"else\n"
"h = (r - g)*diff + 240.f;\n"
"if( h < 0.f ) h += 360.f;\n"
"}\n"
"dst[0] = h*hscale;\n"
"dst[1] = l;\n"
"dst[2] = s;\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__kernel void HLS2RGB(__global const uchar* srcptr, int src_step, int src_offset,\n"
"__global uchar* dstptr, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const float * src = (__global const float *)(srcptr + src_idx);\n"
"__global float * dst = (__global float *)(dstptr + dst_idx);\n"
"float4 src_pix = vload4(0, src);\n"
"float h = src_pix.x, l = src_pix.y, s = src_pix.z;\n"
"float b, g, r;\n"
"if (s != 0)\n"
"{\n"
"float tab[4];\n"
"int sector;\n"
"float p2 = l <= 0.5f ? l*(1 + s) : l + s - l*s;\n"
"float p1 = 2*l - p2;\n"
"h *= hscale;\n"
"if( h < 0 )\n"
"do h += 6; while( h < 0 );\n"
"else if( h >= 6 )\n"
"do h -= 6; while( h >= 6 );\n"
"sector = convert_int_sat_rtn(h);\n"
"h -= sector;\n"
"tab[0] = p2;\n"
"tab[1] = p1;\n"
"tab[2] = p1 + (p2 - p1)*(1-h);\n"
"tab[3] = p1 + (p2 - p1)*h;\n"
"b = tab[sector_data[sector][0]];\n"
"g = tab[sector_data[sector][1]];\n"
"r = tab[sector_data[sector][2]];\n"
"}\n"
"else\n"
"b = g = r = l;\n"
"dst[bidx] = b;\n"
"dst[1] = g;\n"
"dst[bidx^2] = r;\n"
"#if dcn == 4\n"
"dst[3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"#endif\n"
"#ifdef DEPTH_0\n"
"__kernel void RGBA2mRGBA(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + (x << 2));\n"
"int dst_idx = mad24(y, dst_step, dst_offset + (x << 2));\n"
"uchar4 src_pix = vload4(0, src + src_idx);\n"
"uchar v0 = src_pix.x, v1 = src_pix.y;\n"
"uchar v2 = src_pix.z, v3 = src_pix.w;\n"
"dst[dst_idx] = (v0 * v3 + HALF_MAX) / MAX_NUM;\n"
"dst[dst_idx + 1] = (v1 * v3 + HALF_MAX) / MAX_NUM;\n"
"dst[dst_idx + 2] = (v2 * v3 + HALF_MAX) / MAX_NUM;\n"
"dst[dst_idx + 3] = v3;\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"__kernel void mRGBA2RGBA(__global const uchar* src, int src_step, int src_offset,\n"
"__global uchar* dst, int dst_step, int dst_offset,\n"
"int rows, int cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + (x << 2));\n"
"int dst_idx = mad24(y, dst_step, dst_offset + (x << 2));\n"
"uchar4 src_pix = vload4(0, src + src_idx);\n"
"uchar v0 = src_pix.x, v1 = src_pix.y;\n"
"uchar v2 = src_pix.z, v3 = src_pix.w;\n"
"uchar v3_half = v3 / 2;\n"
"dst[dst_idx] = v3 == 0 ? 0 : (v0 * MAX_NUM + v3_half) / v3;\n"
"dst[dst_idx + 1] = v3 == 0 ? 0 : (v1 * MAX_NUM + v3_half) / v3;\n"
"dst[dst_idx + 2] = v3 == 0 ? 0 : (v2 * MAX_NUM + v3_half) / v3;\n"
"dst[dst_idx + 3] = v3;\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"#endif\n"
"#define lab_shift xyz_shift\n"
"#define gamma_shift 3\n"
"#define lab_shift2 (lab_shift + gamma_shift)\n"
"#define GAMMA_TAB_SIZE 1024\n"
"#define GammaTabScale (float)GAMMA_TAB_SIZE\n"
"inline float splineInterpolate(float x, __global const float * tab, int n)\n"
"{\n"
"int ix = clamp(convert_int_sat_rtn(x), 0, n-1);\n"
"x -= ix;\n"
"tab += ix*4;\n"
"return ((tab[3]*x + tab[2])*x + tab[1])*x + tab[0];\n"
"}\n"
"#ifdef DEPTH_0\n"
"__kernel void BGR2Lab(__global const uchar * src, int src_step, int src_offset,\n"
"__global uchar * dst, int dst_step, int dst_offset, int rows, int cols,\n"
"__global const ushort * gammaTab, __global ushort * LabCbrtTab_b,\n"
"__constant int * coeffs, int Lscale, int Lshift)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const uchar* src_ptr = src + src_idx;\n"
"__global uchar* dst_ptr = dst + dst_idx;\n"
"uchar4 src_pix = vload4(0, src_ptr);\n"
"int C0 = coeffs[0], C1 = coeffs[1], C2 = coeffs[2],\n"
"C3 = coeffs[3], C4 = coeffs[4], C5 = coeffs[5],\n"
"C6 = coeffs[6], C7 = coeffs[7], C8 = coeffs[8];\n"
"int R = gammaTab[src_pix.x], G = gammaTab[src_pix.y], B = gammaTab[src_pix.z];\n"
"int fX = LabCbrtTab_b[CV_DESCALE(R*C0 + G*C1 + B*C2, lab_shift)];\n"
"int fY = LabCbrtTab_b[CV_DESCALE(R*C3 + G*C4 + B*C5, lab_shift)];\n"
"int fZ = LabCbrtTab_b[CV_DESCALE(R*C6 + G*C7 + B*C8, lab_shift)];\n"
"int L = CV_DESCALE( Lscale*fY + Lshift, lab_shift2 );\n"
"int a = CV_DESCALE( 500*(fX - fY) + 128*(1 << lab_shift2), lab_shift2 );\n"
"int b = CV_DESCALE( 200*(fY - fZ) + 128*(1 << lab_shift2), lab_shift2 );\n"
"dst_ptr[0] = SAT_CAST(L);\n"
"dst_ptr[1] = SAT_CAST(a);\n"
"dst_ptr[2] = SAT_CAST(b);\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"#elif defined DEPTH_5\n"
"__kernel void BGR2Lab(__global const uchar * srcptr, int src_step, int src_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int rows, int cols,\n"
"#ifdef SRGB\n"
"__global const float * gammaTab,\n"
"#endif\n"
"__constant float * coeffs, float _1_3, float _a)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const float * src = (__global const float *)(srcptr + src_idx);\n"
"__global float * dst = (__global float *)(dstptr + dst_idx);\n"
"float4 src_pix = vload4(0, src);\n"
"float C0 = coeffs[0], C1 = coeffs[1], C2 = coeffs[2],\n"
"C3 = coeffs[3], C4 = coeffs[4], C5 = coeffs[5],\n"
"C6 = coeffs[6], C7 = coeffs[7], C8 = coeffs[8];\n"
"float R = clamp(src_pix.x, 0.0f, 1.0f);\n"
"float G = clamp(src_pix.y, 0.0f, 1.0f);\n"
"float B = clamp(src_pix.z, 0.0f, 1.0f);\n"
"#ifdef SRGB\n"
"R = splineInterpolate(R * GammaTabScale, gammaTab, GAMMA_TAB_SIZE);\n"
"G = splineInterpolate(G * GammaTabScale, gammaTab, GAMMA_TAB_SIZE);\n"
"B = splineInterpolate(B * GammaTabScale, gammaTab, GAMMA_TAB_SIZE);\n"
"#endif\n"
"float X = R*C0 + G*C1 + B*C2;\n"
"float Y = R*C3 + G*C4 + B*C5;\n"
"float Z = R*C6 + G*C7 + B*C8;\n"
"float FX = X > 0.008856f ? pow(X, _1_3) : (7.787f * X + _a);\n"
"float FY = Y > 0.008856f ? pow(Y, _1_3) : (7.787f * Y + _a);\n"
"float FZ = Z > 0.008856f ? pow(Z, _1_3) : (7.787f * Z + _a);\n"
"float L = Y > 0.008856f ? (116.f * FY - 16.f) : (903.3f * Y);\n"
"float a = 500.f * (FX - FY);\n"
"float b = 200.f * (FY - FZ);\n"
"dst[0] = L;\n"
"dst[1] = a;\n"
"dst[2] = b;\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"#endif\n"
"inline void Lab2BGR_f(const float * srcbuf, float * dstbuf,\n"
"#ifdef SRGB\n"
"__global const float * gammaTab,\n"
"#endif\n"
"__constant float * coeffs, float lThresh, float fThresh)\n"
"{\n"
"float li = srcbuf[0], ai = srcbuf[1], bi = srcbuf[2];\n"
"float C0 = coeffs[0], C1 = coeffs[1], C2 = coeffs[2],\n"
"C3 = coeffs[3], C4 = coeffs[4], C5 = coeffs[5],\n"
"C6 = coeffs[6], C7 = coeffs[7], C8 = coeffs[8];\n"
"float y, fy;\n"
"if (li <= lThresh)\n"
"{\n"
"y = li / 903.3f;\n"
"fy = 7.787f * y + 16.0f / 116.0f;\n"
"}\n"
"else\n"
"{\n"
"fy = (li + 16.0f) / 116.0f;\n"
"y = fy * fy * fy;\n"
"}\n"
"float fxz[] = { ai / 500.0f + fy, fy - bi / 200.0f };\n"
"for (int j = 0; j < 2; j++)\n"
"if (fxz[j] <= fThresh)\n"
"fxz[j] = (fxz[j] - 16.0f / 116.0f) / 7.787f;\n"
"else\n"
"fxz[j] = fxz[j] * fxz[j] * fxz[j];\n"
"float x = fxz[0], z = fxz[1];\n"
"float ro = clamp(C0 * x + C1 * y + C2 * z, 0.0f, 1.0f);\n"
"float go = clamp(C3 * x + C4 * y + C5 * z, 0.0f, 1.0f);\n"
"float bo = clamp(C6 * x + C7 * y + C8 * z, 0.0f, 1.0f);\n"
"#ifdef SRGB\n"
"ro = splineInterpolate(ro * GammaTabScale, gammaTab, GAMMA_TAB_SIZE);\n"
"go = splineInterpolate(go * GammaTabScale, gammaTab, GAMMA_TAB_SIZE);\n"
"bo = splineInterpolate(bo * GammaTabScale, gammaTab, GAMMA_TAB_SIZE);\n"
"#endif\n"
"dstbuf[0] = ro, dstbuf[1] = go, dstbuf[2] = bo;\n"
"}\n"
"#ifdef DEPTH_0\n"
"__kernel void Lab2BGR(__global const uchar * src, int src_step, int src_offset,\n"
"__global uchar * dst, int dst_step, int dst_offset, int rows, int cols,\n"
"#ifdef SRGB\n"
"__global const float * gammaTab,\n"
"#endif\n"
"__constant float * coeffs, float lThresh, float fThresh)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const uchar* src_ptr = src + src_idx;\n"
"__global uchar* dst_ptr = dst + dst_idx;\n"
"uchar4 src_pix = vload4(0, src_ptr);\n"
"float srcbuf[3], dstbuf[3];\n"
"srcbuf[0] = src_pix.x*(100.f/255.f);\n"
"srcbuf[1] = convert_float(src_pix.y - 128);\n"
"srcbuf[2] = convert_float(src_pix.z - 128);\n"
"Lab2BGR_f(&srcbuf[0], &dstbuf[0],\n"
"#ifdef SRGB\n"
"gammaTab,\n"
"#endif\n"
"coeffs, lThresh, fThresh);\n"
"dst_ptr[0] = SAT_CAST(dstbuf[0] * 255.0f);\n"
"dst_ptr[1] = SAT_CAST(dstbuf[1] * 255.0f);\n"
"dst_ptr[2] = SAT_CAST(dstbuf[2] * 255.0f);\n"
"#if dcn == 4\n"
"dst_ptr[3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"#elif defined DEPTH_5\n"
"__kernel void Lab2BGR(__global const uchar * srcptr, int src_step, int src_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int rows, int cols,\n"
"#ifdef SRGB\n"
"__global const float * gammaTab,\n"
"#endif\n"
"__constant float * coeffs, float lThresh, float fThresh)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1) * PIX_PER_WI_Y;\n"
"if (x < cols)\n"
"{\n"
"#pragma unroll\n"
"for (int cy = 0; cy < PIX_PER_WI_Y; ++cy)\n"
"{\n"
"if (y < rows)\n"
"{\n"
"int src_idx = mad24(y, src_step, src_offset + x * scnbytes);\n"
"int dst_idx = mad24(y, dst_step, dst_offset + x * dcnbytes);\n"
"__global const float * src = (__global const float *)(srcptr + src_idx);\n"
"__global float * dst = (__global float *)(dstptr + dst_idx);\n"
"float4 src_pix = vload4(0, src);\n"
"float srcbuf[3], dstbuf[3];\n"
"srcbuf[0] = src_pix.x, srcbuf[1] = src_pix.y, srcbuf[2] = src_pix.z;\n"
"Lab2BGR_f(&srcbuf[0], &dstbuf[0],\n"
"#ifdef SRGB\n"
"gammaTab,\n"
"#endif\n"
"coeffs, lThresh, fThresh);\n"
"dst[0] = dstbuf[0], dst[1] = dstbuf[1], dst[2] = dstbuf[2];\n"
"#if dcn == 4\n"
"dst[3] = MAX_NUM;\n"
"#endif\n"
"}\n"
"++y;\n"
"}\n"
"}\n"
"}\n"
"#endif\n"
, "4dfd874089c82df81b27e90b083c2d3f"};
ProgramSource cvtcolor_oclsrc(cvtcolor.programStr);
const struct ProgramEntry filter2D={"filter2D",
"#ifdef BORDER_REPLICATE\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (l_edge)   : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (r_edge)-1 : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (t_edge)   :(i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (b_edge)-1 :(addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)-1               : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-1+((r_edge)<<1) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)-1 : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-1+((b_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT_101\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)                 : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-2+((r_edge)<<1) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? -(i)                 : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? -(i)-2+((b_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_WRAP\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (i)+(r_edge) : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (i)-(r_edge) : (addr))\n"
"#define ADDR_H(i, t_edge, b_edge)  ((i) <  (t_edge) ? (i)+(b_edge) : (i))\n"
"#define ADDR_B(i, b_edge, addr)    ((i) >= (b_edge) ? (i)-(b_edge) : (addr))\n"
"#endif\n"
"#ifdef EXTRA_EXTRAPOLATION\n"
"#ifdef BORDER_CONSTANT\n"
"#elif defined BORDER_REPLICATE\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n"
"{ \\\n"
"x = max(min(x, maxX - 1), minX); \\\n"
"y = max(min(y, maxY - 1), minY); \\\n"
"}\n"
"#elif defined BORDER_WRAP\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n"
"{ \\\n"
"if (x < minX) \\\n"
"x -= ((x - maxX + 1) / maxX) * maxX; \\\n"
"if (x >= maxX) \\\n"
"x %= maxX; \\\n"
"if (y < minY) \\\n"
"y -= ((y - maxY + 1) / maxY) * maxY; \\\n"
"if (y >= maxY) \\\n"
"y %= maxY; \\\n"
"}\n"
"#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT_101)\n"
"#define EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, delta) \\\n"
"{ \\\n"
"if (maxX - minX == 1) \\\n"
"x = minX; \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if (x < minX) \\\n"
"x = minX - (x - minX) - 1 + delta; \\\n"
"else \\\n"
"x = maxX - 1 - (x - maxX) - delta; \\\n"
"} \\\n"
"while (x >= maxX || x < minX); \\\n"
"\\\n"
"if (maxY - minY == 1) \\\n"
"y = minY; \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if (y < minY) \\\n"
"y = minY - (y - minY) - 1 + delta; \\\n"
"else \\\n"
"y = maxY - 1 - (y - maxY) - delta; \\\n"
"} \\\n"
"while (y >= maxY || y < minY); \\\n"
"}\n"
"#ifdef BORDER_REFLECT\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, 0)\n"
"#elif defined(BORDER_REFLECT_101) || defined(BORDER_REFLECT101)\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) EXTRAPOLATE_(x, y, minX, minY, maxX, maxY, 1)\n"
"#endif\n"
"#else\n"
"#error No extrapolation method\n"
"#endif\n"
"#else\n"
"#define EXTRAPOLATE(x, y, minX, minY, maxX, maxY) \\\n"
"{ \\\n"
"int _row = y - minY, _col = x - minX; \\\n"
"_row = ADDR_H(_row, 0, maxY - minY); \\\n"
"_row = ADDR_B(_row, maxY - minY, _row); \\\n"
"y = _row + minY; \\\n"
"\\\n"
"_col = ADDR_L(_col, 0, maxX - minX); \\\n"
"_col = ADDR_R(_col, maxX - minX, _col); \\\n"
"x = _col + minX; \\\n"
"}\n"
"#endif\n"
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#if cn != 3\n"
"#define loadpix(addr) *(__global const srcT *)(addr)\n"
"#define storepix(val, addr)  *(__global dstT *)(addr) = val\n"
"#define SRCSIZE (int)sizeof(srcT)\n"
"#define DSTSIZE (int)sizeof(dstT)\n"
"#else\n"
"#define loadpix(addr) vload3(0, (__global const srcT1 *)(addr))\n"
"#define storepix(val, addr) vstore3(val, 0, (__global dstT1 *)(addr))\n"
"#define SRCSIZE (int)sizeof(srcT1) * cn\n"
"#define DSTSIZE (int)sizeof(dstT1) * cn\n"
"#endif\n"
"#define noconvert\n"
"struct RectCoords\n"
"{\n"
"int x1, y1, x2, y2;\n"
"};\n"
"inline WT readSrcPixel(int2 pos, __global const uchar * srcptr, int src_step, const struct RectCoords srcCoords)\n"
"{\n"
"#ifdef BORDER_ISOLATED\n"
"if (pos.x >= srcCoords.x1 && pos.y >= srcCoords.y1 && pos.x < srcCoords.x2 && pos.y < srcCoords.y2)\n"
"#else\n"
"if (pos.x >= 0 && pos.y >= 0 && pos.x < srcCoords.x2 && pos.y < srcCoords.y2)\n"
"#endif\n"
"{\n"
"return convertToWT(loadpix(srcptr + mad24(pos.y, src_step, pos.x * SRCSIZE)));\n"
"}\n"
"else\n"
"{\n"
"#ifdef BORDER_CONSTANT\n"
"return (WT)(0);\n"
"#else\n"
"int selected_col = pos.x, selected_row = pos.y;\n"
"EXTRAPOLATE(selected_col, selected_row,\n"
"#ifdef BORDER_ISOLATED\n"
"srcCoords.x1, srcCoords.y1,\n"
"#else\n"
"0, 0,\n"
"#endif\n"
"srcCoords.x2, srcCoords.y2\n"
");\n"
"return convertToWT(loadpix(srcptr + mad24(selected_row, src_step, selected_col * SRCSIZE)));\n"
"#endif\n"
"}\n"
"}\n"
"#define DIG(a) a,\n"
"__constant WT1 kernelData[] = { COEFF };\n"
"__kernel void filter2D(__global const uchar * srcptr, int src_step, int srcOffsetX, int srcOffsetY, int srcEndX, int srcEndY,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int rows, int cols, float delta)\n"
"{\n"
"const struct RectCoords srcCoords = { srcOffsetX, srcOffsetY, srcEndX, srcEndY };\n"
"int local_id = get_local_id(0);\n"
"int x = local_id + (LOCAL_SIZE - (KERNEL_SIZE_X - 1)) * get_group_id(0) - ANCHOR_X;\n"
"int y = get_global_id(1) * BLOCK_SIZE_Y;\n"
"WT data[KERNEL_SIZE_Y];\n"
"__local WT sumOfCols[LOCAL_SIZE];\n"
"int2 srcPos = (int2)(srcCoords.x1 + x, srcCoords.y1 + y - ANCHOR_Y);\n"
"int2 pos = (int2)(x, y);\n"
"__global dstT * dst = (__global dstT *)(dstptr + mad24(pos.y, dst_step, mad24(pos.x, DSTSIZE, dst_offset)));\n"
"bool writeResult = local_id >= ANCHOR_X && local_id < LOCAL_SIZE - (KERNEL_SIZE_X - 1 - ANCHOR_X) &&\n"
"pos.x >= 0 && pos.x < cols;\n"
"#if BLOCK_SIZE_Y > 1\n"
"bool readAllpixels = true;\n"
"int sy_index = 0;\n"
"dstRowsMax = min(rows, pos.y + BLOCK_SIZE_Y);\n"
"for ( ;\n"
"pos.y < dstRowsMax;\n"
"pos.y++, dst = (__global dstT *)((__global uchar *)dst + dst_step))\n"
"#endif\n"
"{\n"
"for (\n"
"#if BLOCK_SIZE_Y > 1\n"
"int sy = readAllpixels ? 0 : -1; sy < (readAllpixels ? KERNEL_SIZE_Y : 0);\n"
"#else\n"
"int sy = 0, sy_index = 0; sy < KERNEL_SIZE_Y;\n"
"#endif\n"
"sy++, srcPos.y++)\n"
"{\n"
"data[sy + sy_index] = readSrcPixel(srcPos, srcptr, src_step, srcCoords);\n"
"}\n"
"WT total_sum = 0;\n"
"for (int sx = 0; sx < KERNEL_SIZE_X; sx++)\n"
"{\n"
"{\n"
"__constant WT1 * k = &kernelData[KERNEL_SIZE_Y2_ALIGNED * sx\n"
"#if BLOCK_SIZE_Y > 1\n"
"+ KERNEL_SIZE_Y - sy_index\n"
"#endif\n"
"];\n"
"WT tmp_sum = 0;\n"
"for (int sy = 0; sy < KERNEL_SIZE_Y; sy++)\n"
"tmp_sum += data[sy] * k[sy];\n"
"sumOfCols[local_id] = tmp_sum;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"int id = local_id + sx - ANCHOR_X;\n"
"if (id >= 0 && id < LOCAL_SIZE)\n"
"total_sum += sumOfCols[id];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if (writeResult)\n"
"storepix(convertToDstT(total_sum + (WT)(delta)), dst);\n"
"#if BLOCK_SIZE_Y > 1\n"
"readAllpixels = false;\n"
"#if BLOCK_SIZE_Y > KERNEL_SIZE_Y\n"
"sy_index = sy_index + 1 <= KERNEL_SIZE_Y ? sy_index + 1 : 1;\n"
"#else\n"
"sy_index++;\n"
"#endif\n"
"#endif\n"
"}\n"
"}\n"
, "96cab7639e982016a54e69b132ac28b0"};
ProgramSource filter2D_oclsrc(filter2D.programStr);
const struct ProgramEntry filterSepCol={"filterSepCol",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#define READ_TIMES_COL ((2*(RADIUSY+LSIZE1)-1)/LSIZE1)\n"
"#define RADIUS 1\n"
"#define noconvert\n"
"#if CN != 3\n"
"#define loadpix(addr) *(__global const srcT *)(addr)\n"
"#define storepix(val, addr)  *(__global dstT *)(addr) = val\n"
"#define SRCSIZE (int)sizeof(srcT)\n"
"#define DSTSIZE (int)sizeof(dstT)\n"
"#else\n"
"#define loadpix(addr)  vload3(0, (__global const srcT1 *)(addr))\n"
"#define storepix(val, addr) vstore3(val, 0, (__global dstT1 *)(addr))\n"
"#define SRCSIZE (int)sizeof(srcT1)*3\n"
"#define DSTSIZE (int)sizeof(dstT1)*3\n"
"#endif\n"
"#define DIG(a) a,\n"
"__constant srcT1 mat_kernel[] = { COEFF };\n"
"__kernel void col_filter(__global const uchar * src, int src_step, int src_offset, int src_whole_rows, int src_whole_cols,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols, float delta)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int start_addr = mad24(y, src_step, x * SRCSIZE);\n"
"int end_addr = mad24(src_whole_rows - 1, src_step, src_whole_cols * SRCSIZE);\n"
"srcT sum, temp[READ_TIMES_COL];\n"
"__local srcT LDS_DAT[LSIZE1 * READ_TIMES_COL][LSIZE0 + 1];\n"
"for (int i = 0; i < READ_TIMES_COL; ++i)\n"
"{\n"
"int current_addr = mad24(i, LSIZE1 * src_step, start_addr);\n"
"current_addr = current_addr < end_addr ? current_addr : 0;\n"
"temp[i] = loadpix(src + current_addr);\n"
"}\n"
"for (int i = 0; i < READ_TIMES_COL; ++i)\n"
"LDS_DAT[mad24(i, LSIZE1, l_y)][l_x] = temp[i];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum = LDS_DAT[l_y + RADIUSY][l_x] * mat_kernel[RADIUSY];\n"
"for (int i = 1; i <= RADIUSY; ++i)\n"
"{\n"
"temp[0] = LDS_DAT[l_y + RADIUSY - i][l_x];\n"
"temp[1] = LDS_DAT[l_y + RADIUSY + i][l_x];\n"
"#ifndef INTEGER_ARITHMETIC\n"
"sum += mad(temp[0], mat_kernel[RADIUSY - i], temp[1] * mat_kernel[RADIUSY + i]);\n"
"#else\n"
"sum += mad24(temp[0],mat_kernel[RADIUSY - i], temp[1] * mat_kernel[RADIUSY + i]);\n"
"#endif\n"
"}\n"
"#ifdef INTEGER_ARITHMETIC\n"
"sum = (sum + (1 << (SHIFT_BITS-1))) >> SHIFT_BITS;\n"
"#endif\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"start_addr = mad24(y, dst_step, mad24(DSTSIZE, x, dst_offset));\n"
"storepix(convertToDstT(sum + (srcT)(delta)), dst + start_addr);\n"
"}\n"
"}\n"
, "8bc38767c678673264dfafc84e5e01d0"};
ProgramSource filterSepCol_oclsrc(filterSepCol.programStr);
const struct ProgramEntry filterSepRow={"filterSepRow",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#define READ_TIMES_ROW ((2*(RADIUSX+LSIZE0)-1)/LSIZE0)\n"
"#define RADIUS 1\n"
"#ifdef BORDER_REPLICATE\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (l_edge)   : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (r_edge)-1 : (addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)-1               : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-1+((r_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_REFLECT_101\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? -(i)                 : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? -(i)-2+((r_edge)<<1) : (addr))\n"
"#endif\n"
"#ifdef BORDER_WRAP\n"
"#define ADDR_L(i, l_edge, r_edge)  ((i) <  (l_edge) ? (i)+(r_edge) : (i))\n"
"#define ADDR_R(i, r_edge, addr)    ((i) >= (r_edge) ? (i)-(r_edge) : (addr))\n"
"#endif\n"
"#ifdef EXTRA_EXTRAPOLATION\n"
"#ifdef BORDER_CONSTANT\n"
"#define ELEM(i,l_edge,r_edge,elem1,elem2) (i)<(l_edge) | (i) >= (r_edge) ? (elem1) : (elem2)\n"
"#elif defined BORDER_REPLICATE\n"
"#define EXTRAPOLATE(t, minT, maxT) \\\n"
"{ \\\n"
"t = max(min(t, (maxT) - 1), (minT)); \\\n"
"}\n"
"#elif defined BORDER_WRAP\n"
"#define EXTRAPOLATE(x, minT, maxT) \\\n"
"{ \\\n"
"if (t < (minT)) \\\n"
"t -= ((t - (maxT) + 1) / (maxT)) * (maxT); \\\n"
"if (t >= (maxT)) \\\n"
"t %= (maxT); \\\n"
"}\n"
"#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT_101)\n"
"#define EXTRAPOLATE_(t, minT, maxT, delta) \\\n"
"{ \\\n"
"if ((maxT) - (minT) == 1) \\\n"
"t = (minT); \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if (t < (minT)) \\\n"
"t = (minT) - (t - (minT)) - 1 + delta; \\\n"
"else \\\n"
"t = (maxT) - 1 - (t - (maxT)) - delta; \\\n"
"} \\\n"
"while (t >= (maxT) || t < (minT)); \\\n"
"\\\n"
"}\n"
"#ifdef BORDER_REFLECT\n"
"#define EXTRAPOLATE(t, minT, maxT) EXTRAPOLATE_(t, minT, maxT, 0)\n"
"#elif defined(BORDER_REFLECT_101)\n"
"#define EXTRAPOLATE(t, minT, maxT) EXTRAPOLATE_(t, minT, maxT, 1)\n"
"#endif\n"
"#else\n"
"#error No extrapolation method\n"
"#endif\n"
"#else\n"
"#ifdef BORDER_CONSTANT\n"
"#define ELEM(i,l_edge,r_edge,elem1,elem2) (i)<(l_edge) | (i) >= (r_edge) ? (elem1) : (elem2)\n"
"#else\n"
"#define EXTRAPOLATE(t, minT, maxT) \\\n"
"{ \\\n"
"int _delta = t - (minT); \\\n"
"_delta = ADDR_L(_delta, 0, (maxT) - (minT)); \\\n"
"_delta = ADDR_R(_delta, (maxT) - (minT), _delta); \\\n"
"t = _delta + (minT); \\\n"
"}\n"
"#endif\n"
"#endif\n"
"#define noconvert\n"
"#if CN != 3\n"
"#define loadpix(addr) *(__global const srcT *)(addr)\n"
"#define storepix(val, addr)  *(__global dstT *)(addr) = val\n"
"#define SRCSIZE (int)sizeof(srcT)\n"
"#define DSTSIZE (int)sizeof(dstT)\n"
"#else\n"
"#define loadpix(addr)  vload3(0, (__global const srcT1 *)(addr))\n"
"#define storepix(val, addr) vstore3(val, 0, (__global dstT1 *)(addr))\n"
"#define SRCSIZE (int)sizeof(srcT1)*3\n"
"#define DSTSIZE (int)sizeof(dstT1)*3\n"
"#endif\n"
"#define DIG(a) a,\n"
"__constant dstT1 mat_kernel[] = { COEFF };\n"
"#ifndef INTEGER_ARITHMETIC\n"
"#define dstT4 float4\n"
"#define convertDstVec convert_float4\n"
"#else\n"
"#define dstT4 int4\n"
"#define convertDstVec convert_int4\n"
"#endif\n"
"__kernel void row_filter_C1_D0(__global const uchar * src, int src_step_in_pixel, int src_offset_x, int src_offset_y,\n"
"int src_cols, int src_rows, int src_whole_cols, int src_whole_rows,\n"
"__global float * dst, int dst_step_in_pixel, int dst_cols, int dst_rows,\n"
"int radiusy)\n"
"{\n"
"int x = get_global_id(0)<<2;\n"
"int y = get_global_id(1);\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int start_x = x + src_offset_x - RADIUSX & 0xfffffffc;\n"
"int offset = src_offset_x - RADIUSX & 3;\n"
"int start_y = y + src_offset_y - radiusy;\n"
"int start_addr = mad24(start_y, src_step_in_pixel, start_x);\n"
"dstT4 sum;\n"
"uchar4 temp[READ_TIMES_ROW];\n"
"__local uchar4 LDS_DAT[LSIZE1][READ_TIMES_ROW * LSIZE0 + 1];\n"
"#ifdef BORDER_CONSTANT\n"
"int end_addr = mad24(src_whole_rows - 1, src_step_in_pixel, src_whole_cols);\n"
"for (int i = 0; i < READ_TIMES_ROW; ++i)\n"
"{\n"
"int current_addr = mad24(i, LSIZE0 << 2, start_addr);\n"
"current_addr = current_addr < end_addr && current_addr > 0 ? current_addr : 0;\n"
"temp[i] = *(__global const uchar4 *)&src[current_addr];\n"
"}\n"
"#ifdef BORDER_ISOLATED\n"
"for (int i = 0; i < READ_TIMES_ROW; ++i)\n"
"{\n"
"temp[i].x = ELEM(start_x+i*LSIZE0*4,   src_offset_x, src_offset_x + src_cols, 0,         temp[i].x);\n"
"temp[i].y = ELEM(start_x+i*LSIZE0*4+1, src_offset_x, src_offset_x + src_cols, 0,         temp[i].y);\n"
"temp[i].z = ELEM(start_x+i*LSIZE0*4+2, src_offset_x, src_offset_x + src_cols, 0,         temp[i].z);\n"
"temp[i].w = ELEM(start_x+i*LSIZE0*4+3, src_offset_x, src_offset_x + src_cols, 0,         temp[i].w);\n"
"temp[i]   = ELEM(start_y,              src_offset_y, src_offset_y + src_rows, (uchar4)0, temp[i]);\n"
"}\n"
"#else\n"
"for (int i = 0; i < READ_TIMES_ROW; ++i)\n"
"{\n"
"temp[i].x = ELEM(start_x+i*LSIZE0*4,   0, src_whole_cols, 0,         temp[i].x);\n"
"temp[i].y = ELEM(start_x+i*LSIZE0*4+1, 0, src_whole_cols, 0,         temp[i].y);\n"
"temp[i].z = ELEM(start_x+i*LSIZE0*4+2, 0, src_whole_cols, 0,         temp[i].z);\n"
"temp[i].w = ELEM(start_x+i*LSIZE0*4+3, 0, src_whole_cols, 0,         temp[i].w);\n"
"temp[i]   = ELEM(start_y,              0, src_whole_rows, (uchar4)0, temp[i]);\n"
"}\n"
"#endif\n"
"#else\n"
"#ifdef BORDER_ISOLATED\n"
"int not_all_in_range = (start_x<src_offset_x) | (start_x + READ_TIMES_ROW*LSIZE0*4+4>src_offset_x + src_cols)| (start_y<src_offset_y) | (start_y >= src_offset_y + src_rows);\n"
"#else\n"
"int not_all_in_range = (start_x<0) | (start_x + READ_TIMES_ROW*LSIZE0*4+4>src_whole_cols)| (start_y<0) | (start_y >= src_whole_rows);\n"
"#endif\n"
"int4 index[READ_TIMES_ROW], addr;\n"
"int s_y;\n"
"if (not_all_in_range)\n"
"{\n"
"for (int i = 0; i < READ_TIMES_ROW; ++i)\n"
"{\n"
"index[i] = (int4)(mad24(i, LSIZE0 << 2, start_x)) + (int4)(0, 1, 2, 3);\n"
"#ifdef BORDER_ISOLATED\n"
"EXTRAPOLATE(index[i].x, src_offset_x, src_offset_x + src_cols);\n"
"EXTRAPOLATE(index[i].y, src_offset_x, src_offset_x + src_cols);\n"
"EXTRAPOLATE(index[i].z, src_offset_x, src_offset_x + src_cols);\n"
"EXTRAPOLATE(index[i].w, src_offset_x, src_offset_x + src_cols);\n"
"#else\n"
"EXTRAPOLATE(index[i].x, 0, src_whole_cols);\n"
"EXTRAPOLATE(index[i].y, 0, src_whole_cols);\n"
"EXTRAPOLATE(index[i].z, 0, src_whole_cols);\n"
"EXTRAPOLATE(index[i].w, 0, src_whole_cols);\n"
"#endif\n"
"}\n"
"s_y = start_y;\n"
"#ifdef BORDER_ISOLATED\n"
"EXTRAPOLATE(s_y, src_offset_y, src_offset_y + src_rows);\n"
"#else\n"
"EXTRAPOLATE(s_y, 0, src_whole_rows);\n"
"#endif\n"
"for (int i = 0; i < READ_TIMES_ROW; ++i)\n"
"{\n"
"addr = mad24((int4)s_y, (int4)src_step_in_pixel, index[i]);\n"
"temp[i].x = src[addr.x];\n"
"temp[i].y = src[addr.y];\n"
"temp[i].z = src[addr.z];\n"
"temp[i].w = src[addr.w];\n"
"}\n"
"}\n"
"else\n"
"{\n"
"for (int i = 0; i < READ_TIMES_ROW; ++i)\n"
"temp[i] = *(__global uchar4*)&src[mad24(i, LSIZE0 << 2, start_addr)];\n"
"}\n"
"#endif\n"
"for (int i = 0; i < READ_TIMES_ROW; ++i)\n"
"LDS_DAT[l_y][mad24(i, LSIZE0, l_x)] = temp[i];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum = convertDstVec(vload4(0,(__local uchar *)&LDS_DAT[l_y][l_x]+RADIUSX+offset)) * mat_kernel[RADIUSX];\n"
"for (int i = 1; i <= RADIUSX; ++i)\n"
"{\n"
"temp[0] = vload4(0, (__local uchar*)&LDS_DAT[l_y][l_x] + RADIUSX + offset - i);\n"
"temp[1] = vload4(0, (__local uchar*)&LDS_DAT[l_y][l_x] + RADIUSX + offset + i);\n"
"#ifndef INTEGER_ARITHMETIC\n"
"sum += mad(convertDstVec(temp[0]), mat_kernel[RADIUSX-i], convertDstVec(temp[1]) * mat_kernel[RADIUSX + i]);\n"
"#else\n"
"sum += mad24(convertDstVec(temp[0]), mat_kernel[RADIUSX-i], convertDstVec(temp[1]) * mat_kernel[RADIUSX + i]);\n"
"#endif\n"
"}\n"
"start_addr = mad24(y, dst_step_in_pixel, x);\n"
"if ((x+3<dst_cols) & (y<dst_rows))\n"
"*(__global dstT4*)&dst[start_addr] = sum;\n"
"else if ((x+2<dst_cols) && (y<dst_rows))\n"
"{\n"
"dst[start_addr] = sum.x;\n"
"dst[start_addr+1] = sum.y;\n"
"dst[start_addr+2] = sum.z;\n"
"}\n"
"else if ((x+1<dst_cols) && (y<dst_rows))\n"
"{\n"
"dst[start_addr] = sum.x;\n"
"dst[start_addr+1] = sum.y;\n"
"}\n"
"else if (x<dst_cols && y<dst_rows)\n"
"dst[start_addr] = sum.x;\n"
"}\n"
"__kernel void row_filter(__global const uchar * src, int src_step, int src_offset_x, int src_offset_y,\n"
"int src_cols, int src_rows, int src_whole_cols, int src_whole_rows,\n"
"__global uchar * dst, int dst_step, int dst_cols, int dst_rows,\n"
"int radiusy)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"int l_x = get_local_id(0);\n"
"int l_y = get_local_id(1);\n"
"int start_x = x + src_offset_x - RADIUSX;\n"
"int start_y = y + src_offset_y - radiusy;\n"
"int start_addr = mad24(start_y, src_step, start_x * SRCSIZE);\n"
"dstT sum;\n"
"srcT temp[READ_TIMES_ROW];\n"
"__local srcT LDS_DAT[LSIZE1][READ_TIMES_ROW * LSIZE0 + 1];\n"
"#ifdef BORDER_CONSTANT\n"
"int end_addr = mad24(src_whole_rows - 1, src_step, src_whole_cols * SRCSIZE);\n"
"for (int i = 0; i < READ_TIMES_ROW; i++)\n"
"{\n"
"int current_addr = mad24(i, LSIZE0 * SRCSIZE, start_addr);\n"
"current_addr = current_addr < end_addr && current_addr >= 0 ? current_addr : 0;\n"
"temp[i] = loadpix(src + current_addr);\n"
"}\n"
"#ifdef BORDER_ISOLATED\n"
"for (int i = 0; i < READ_TIMES_ROW; ++i)\n"
"{\n"
"temp[i] = ELEM(mad24(i, LSIZE0, start_x), src_offset_x, src_offset_x + src_cols, (srcT)(0), temp[i]);\n"
"temp[i] = ELEM(start_y,                   src_offset_y, src_offset_y + src_rows, (srcT)(0), temp[i]);\n"
"}\n"
"#else\n"
"for (int i = 0; i < READ_TIMES_ROW; ++i)\n"
"{\n"
"temp[i] = ELEM(mad24(i, LSIZE0, start_x), 0, src_whole_cols, (srcT)(0), temp[i]);\n"
"temp[i] = ELEM(start_y,                   0, src_whole_rows, (srcT)(0), temp[i]);\n"
"}\n"
"#endif\n"
"#else\n"
"int index[READ_TIMES_ROW], s_x, s_y;\n"
"for (int i = 0; i < READ_TIMES_ROW; ++i)\n"
"{\n"
"s_x = mad24(i, LSIZE0, start_x);\n"
"s_y = start_y;\n"
"#ifdef BORDER_ISOLATED\n"
"EXTRAPOLATE(s_x, src_offset_x, src_offset_x + src_cols);\n"
"EXTRAPOLATE(s_y, src_offset_y, src_offset_y + src_rows);\n"
"#else\n"
"EXTRAPOLATE(s_x, 0, src_whole_cols);\n"
"EXTRAPOLATE(s_y, 0, src_whole_rows);\n"
"#endif\n"
"index[i] = mad24(s_y, src_step, s_x * SRCSIZE);\n"
"}\n"
"for (int i = 0; i < READ_TIMES_ROW; ++i)\n"
"temp[i] = loadpix(src + index[i]);\n"
"#endif\n"
"for (int i = 0; i < READ_TIMES_ROW; ++i)\n"
"LDS_DAT[l_y][mad24(i, LSIZE0, l_x)] = temp[i];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum = convertToDstT(LDS_DAT[l_y][l_x + RADIUSX]) * mat_kernel[RADIUSX];\n"
"for (int i = 1; i <= RADIUSX; ++i)\n"
"{\n"
"temp[0] = LDS_DAT[l_y][l_x + RADIUSX - i];\n"
"temp[1] = LDS_DAT[l_y][l_x + RADIUSX + i];\n"
"#ifndef INTEGER_ARITHMETIC\n"
"sum += mad(convertToDstT(temp[0]), mat_kernel[RADIUSX - i], convertToDstT(temp[1]) * mat_kernel[RADIUSX + i]);\n"
"#else\n"
"sum += mad24(convertToDstT(temp[0]), mat_kernel[RADIUSX - i], convertToDstT(temp[1]) * mat_kernel[RADIUSX + i]);\n"
"#endif\n"
"}\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"start_addr = mad24(y, dst_step, x * DSTSIZE);\n"
"storepix(sum, dst + start_addr);\n"
"}\n"
"}\n"
, "8b885edbf692e3167045cf4126e281f9"};
ProgramSource filterSepRow_oclsrc(filterSepRow.programStr);
const struct ProgramEntry filterSep_singlePass={"filterSep_singlePass",
"#ifdef BORDER_CONSTANT\n"
"#define EXTRAPOLATE(x, maxV)\n"
"#elif defined BORDER_REPLICATE\n"
"#define EXTRAPOLATE(x, maxV) \\\n"
"{ \\\n"
"(x) = max(min((x), (maxV) - 1), 0); \\\n"
"}\n"
"#elif defined BORDER_WRAP\n"
"#define EXTRAPOLATE(x, maxV) \\\n"
"{ \\\n"
"(x) = ( (x) + (maxV) ) % (maxV); \\\n"
"}\n"
"#elif defined BORDER_REFLECT\n"
"#define EXTRAPOLATE(x, maxV) \\\n"
"{ \\\n"
"(x) = min(((maxV)-1)*2-(x)+1, max((x),-(x)-1) ); \\\n"
"}\n"
"#elif defined BORDER_REFLECT_101 || defined BORDER_REFLECT101\n"
"#define EXTRAPOLATE(x, maxV) \\\n"
"{ \\\n"
"(x) = min(((maxV)-1)*2-(x), max((x),-(x)) ); \\\n"
"}\n"
"#else\n"
"#error No extrapolation method\n"
"#endif\n"
"#if CN != 3\n"
"#define loadpix(addr) *(__global const srcT *)(addr)\n"
"#define storepix(val, addr)  *(__global dstT *)(addr) = val\n"
"#define SRCSIZE (int)sizeof(srcT)\n"
"#define DSTSIZE (int)sizeof(dstT)\n"
"#else\n"
"#define loadpix(addr)  vload3(0, (__global const srcT1 *)(addr))\n"
"#define storepix(val, addr) vstore3(val, 0, (__global dstT1 *)(addr))\n"
"#define SRCSIZE (int)sizeof(srcT1)*3\n"
"#define DSTSIZE (int)sizeof(dstT1)*3\n"
"#endif\n"
"#define SRC(_x,_y) convertToWT(loadpix(Src + mad24(_y, src_step, SRCSIZE * _x)))\n"
"#ifdef BORDER_CONSTANT\n"
"#define ELEM(_x,_y,r_edge,t_edge,const_v) (_x)<0 | (_x) >= (r_edge) | (_y)<0 | (_y) >= (t_edge) ? (const_v) : SRC((_x),(_y))\n"
"#else\n"
"#define ELEM(_x,_y,r_edge,t_edge,const_v) SRC((_x),(_y))\n"
"#endif\n"
"#define noconvert\n"
"#define DIG(a) a,\n"
"__constant WT1 mat_kernelX[] = { KERNEL_MATRIX_X };\n"
"__constant WT1 mat_kernelY[] = { KERNEL_MATRIX_Y };\n"
"__kernel void sep_filter(__global uchar* Src, int src_step, int srcOffsetX, int srcOffsetY, int height, int width,\n"
"__global uchar* Dst, int dst_step, int dst_offset, int dst_rows, int dst_cols, float delta)\n"
"{\n"
"__local WT lsmem[BLK_Y + 2 * RADIUSY][BLK_X + 2 * RADIUSX];\n"
"__local WT lsmemDy[BLK_Y][BLK_X + 2 * RADIUSX];\n"
"int lix = get_local_id(0);\n"
"int liy = get_local_id(1);\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"int srcX = x + srcOffsetX - RADIUSX;\n"
"int srcY = y + srcOffsetY - RADIUSY;\n"
"int clocY = liy;\n"
"int cSrcY = srcY;\n"
"do\n"
"{\n"
"int yb = cSrcY;\n"
"EXTRAPOLATE(yb, (height));\n"
"int clocX = lix;\n"
"int cSrcX = srcX;\n"
"do\n"
"{\n"
"int xb = cSrcX;\n"
"EXTRAPOLATE(xb,(width));\n"
"lsmem[clocY][clocX] = ELEM(xb, yb, (width), (height), 0 );\n"
"clocX += BLK_X;\n"
"cSrcX += BLK_X;\n"
"}\n"
"while(clocX < BLK_X+(RADIUSX*2));\n"
"clocY += BLK_Y;\n"
"cSrcY += BLK_Y;\n"
"}\n"
"while (clocY < BLK_Y+(RADIUSY*2));\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int i, clocX = lix;\n"
"WT sum = (WT) 0;\n"
"do\n"
"{\n"
"sum = (WT) 0;\n"
"for (i=0; i<=2*RADIUSY; i++)\n"
"#ifndef INTEGER_ARITHMETIC\n"
"sum = mad(lsmem[liy+i][clocX], mat_kernelY[i], sum);\n"
"#else\n"
"sum = mad24(lsmem[liy+i][clocX], mat_kernelY[i], sum);\n"
"#endif\n"
"lsmemDy[liy][clocX] = sum;\n"
"clocX += BLK_X;\n"
"}\n"
"while(clocX < BLK_X+(RADIUSX*2));\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if( x >= dst_cols || y >=dst_rows )\n"
"return;\n"
"sum = 0.0f;\n"
"for (i=0; i<=2*RADIUSX; i++)\n"
"#ifndef INTEGER_ARITHMETIC\n"
"sum = mad(lsmemDy[liy][lix+i], mat_kernelX[i], sum);\n"
"#else\n"
"sum = mad24(lsmemDy[liy][lix+i], mat_kernelX[i], sum);\n"
"sum = (sum + (1 << (SHIFT_BITS-1))) >> SHIFT_BITS;\n"
"#endif\n"
"storepix(convertToDstT(sum + (WT)(delta)), Dst + mad24(y, dst_step, mad24(x, DSTSIZE, dst_offset)));\n"
"}\n"
, "04128926110b3d227bbb0e4bac98dbdb"};
ProgramSource filterSep_singlePass_oclsrc(filterSep_singlePass.programStr);
const struct ProgramEntry gftt={"gftt",
"#ifdef OP_MAX_EIGEN_VAL\n"
"__kernel void maxEigenVal(__global const uchar * srcptr, int src_step, int src_offset, int cols,\n"
"int total, __global uchar * dstptr\n"
"#ifdef HAVE_MASK\n"
", __global const uchar * maskptr, int mask_step, int mask_offset\n"
"#endif\n"
")\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"int  id = get_global_id(0);\n"
"__local float localmem_max[WGS2_ALIGNED];\n"
"float maxval = -FLT_MAX;\n"
"for (int grain = groupnum * WGS; id < total; id += grain)\n"
"{\n"
"int src_index = mad24(id / cols, src_step, mad24((id % cols), (int)sizeof(float), src_offset));\n"
"#ifdef HAVE_MASK\n"
"int mask_index = mad24(id / cols, mask_step, id % cols + mask_offset);\n"
"if (mask[mask_index])\n"
"#endif\n"
"maxval = max(maxval, *(__global const float *)(srcptr + src_index));\n"
"}\n"
"if (lid < WGS2_ALIGNED)\n"
"localmem_max[lid] = maxval;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (lid >= WGS2_ALIGNED && total >= WGS2_ALIGNED)\n"
"localmem_max[lid - WGS2_ALIGNED] = max(maxval, localmem_max[lid - WGS2_ALIGNED]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for (int lsize = WGS2_ALIGNED >> 1; lsize > 0; lsize >>= 1)\n"
"{\n"
"if (lid < lsize)\n"
"{\n"
"int lid2 = lsize + lid;\n"
"localmem_max[lid] = max(localmem_max[lid], localmem_max[lid2]);\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if (lid == 0)\n"
"*(__global float *)(dstptr + (int)sizeof(float) * gid) = localmem_max[0];\n"
"}\n"
"__kernel void maxEigenValTask(__global float * dst, float qualityLevel)\n"
"{\n"
"float maxval = -FLT_MAX;\n"
"#pragma unroll\n"
"for (int x = 0; x < groupnum; ++x)\n"
"maxval = max(maxval, dst[x]);\n"
"dst[0] = maxval * qualityLevel;\n"
"}\n"
"#elif OP_FIND_CORNERS\n"
"#define GET_SRC_32F(_y, _x) *(__global const float *)(eigptr + (_y) * eig_step + (_x) * (int)sizeof(float) )\n"
"__kernel void findCorners(__global const uchar * eigptr, int eig_step, int eig_offset,\n"
"#ifdef HAVE_MASK\n"
"__global const uchar * mask, int mask_step, int mask_offset,\n"
"#endif\n"
"__global uchar * cornersptr, __global int * counter,\n"
"int rows, int cols, __constant float * threshold, int max_corners)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < rows && x < cols\n"
"#ifdef HAVE_MASK\n"
"&& mask[mad24(y, mask_step, x + mask_offset)]\n"
"#endif\n"
")\n"
"{\n"
"++x, ++y;\n"
"float val = GET_SRC_32F(y, x);\n"
"if (val > threshold[0])\n"
"{\n"
"float maxVal = val;\n"
"maxVal = max(GET_SRC_32F(y - 1, x - 1), maxVal);\n"
"maxVal = max(GET_SRC_32F(y - 1, x    ), maxVal);\n"
"maxVal = max(GET_SRC_32F(y - 1, x + 1), maxVal);\n"
"maxVal = max(GET_SRC_32F(y    , x - 1), maxVal);\n"
"maxVal = max(GET_SRC_32F(y    , x + 1), maxVal);\n"
"maxVal = max(GET_SRC_32F(y + 1, x - 1), maxVal);\n"
"maxVal = max(GET_SRC_32F(y + 1, x    ), maxVal);\n"
"maxVal = max(GET_SRC_32F(y + 1, x + 1), maxVal);\n"
"if (val == maxVal)\n"
"{\n"
"int ind = atomic_inc(counter);\n"
"if (ind < max_corners)\n"
"{\n"
"__global float2 * corners = (__global float2 *)(cornersptr + ind * (int)sizeof(float2));\n"
"corners[0].x = val;\n"
"corners[0].y = as_float(y | (x << 16));\n"
"}\n"
"}\n"
"}\n"
"}\n"
"}\n"
"#endif\n"
, "21d5c35c76056e4cab9c248a40f0ee13"};
ProgramSource gftt_oclsrc(gftt.programStr);
const struct ProgramEntry histogram={"histogram",
"#ifndef cn\n"
"#define cn 1\n"
"#endif\n"
"#if cn == 16\n"
"#define T uchar16\n"
"#else\n"
"#define T uchar\n"
"#endif\n"
"__kernel void calculate_histogram(__global const uchar * src, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * hist, int total)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int id = get_global_id(0) * cn;\n"
"int gid = get_group_id(0);\n"
"__local int localhist[BINS];\n"
"for (int i = lid; i < BINS; i += WGS)\n"
"localhist[i] = 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for (int grain = HISTS_COUNT * WGS * cn; id < total; id += grain)\n"
"{\n"
"int src_index = mad24(id / src_cols, src_step, src_offset + id % src_cols);\n"
"#if cn == 1\n"
"atomic_inc(localhist + convert_int(src[src_index]));\n"
"#else\n"
"T value = *(__global const T *)(src + src_index);\n"
"atomic_inc(localhist + convert_int(value.s0));\n"
"atomic_inc(localhist + convert_int(value.s1));\n"
"atomic_inc(localhist + convert_int(value.s2));\n"
"atomic_inc(localhist + convert_int(value.s3));\n"
"atomic_inc(localhist + convert_int(value.s4));\n"
"atomic_inc(localhist + convert_int(value.s5));\n"
"atomic_inc(localhist + convert_int(value.s6));\n"
"atomic_inc(localhist + convert_int(value.s7));\n"
"atomic_inc(localhist + convert_int(value.s8));\n"
"atomic_inc(localhist + convert_int(value.s9));\n"
"atomic_inc(localhist + convert_int(value.sA));\n"
"atomic_inc(localhist + convert_int(value.sB));\n"
"atomic_inc(localhist + convert_int(value.sC));\n"
"atomic_inc(localhist + convert_int(value.sD));\n"
"atomic_inc(localhist + convert_int(value.sE));\n"
"atomic_inc(localhist + convert_int(value.sF));\n"
"#endif\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for (int i = lid; i < BINS; i += WGS)\n"
"*(__global int *)(hist + mad24(gid, BINS * (int)sizeof(int), i * (int)sizeof(int))) = localhist[i];\n"
"}\n"
"__kernel void merge_histogram(__global const int * ghist, __global int * hist)\n"
"{\n"
"int lid = get_local_id(0);\n"
"#pragma unroll\n"
"for (int i = lid; i < BINS; i += WGS)\n"
"hist[i] = 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#pragma unroll\n"
"for (int i = 0; i < HISTS_COUNT; ++i)\n"
"{\n"
"#pragma unroll\n"
"for (int j = lid; j < BINS; j += WGS)\n"
"hist[j] += ghist[mad24(i, BINS, j)];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"__kernel void calcLUT(__global uchar * dst, __constant int * hist, int total)\n"
"{\n"
"int lid = get_local_id(0);\n"
"__local int sumhist[BINS];\n"
"__local float scale;\n"
"sumhist[lid] = hist[lid];\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (lid == 0)\n"
"{\n"
"int sum = 0, i = 0;\n"
"while (!sumhist[i])\n"
"++i;\n"
"if (total == sumhist[i])\n"
"{\n"
"scale = 1;\n"
"for (int j = 0; j < BINS; ++j)\n"
"sumhist[i] = i;\n"
"}\n"
"else\n"
"{\n"
"scale = 255.f / (total - sumhist[i]);\n"
"for (sumhist[i++] = 0; i < BINS; i++)\n"
"{\n"
"sum += sumhist[i];\n"
"sumhist[i] = sum;\n"
"}\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#pragma unroll\n"
"for (int i = lid; i < BINS; i += WGS)\n"
"dst[i]= convert_uchar_sat_rte(convert_float(sumhist[i]) * scale);\n"
"}\n"
, "2d2d6ca5a69c91e7f658c8b0605b68d8"};
ProgramSource histogram_oclsrc(histogram.programStr);
const struct ProgramEntry integral_sqrsum={"integral_sqrsum",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#if sqdepth == 6\n"
"#define CONVERT(step) ((step)>>1)\n"
"#else\n"
"#define CONVERT(step) ((step))\n"
"#endif\n"
"#define LSIZE 256\n"
"#define LSIZE_1 255\n"
"#define LSIZE_2 254\n"
"#define HF_LSIZE 128\n"
"#define LOG_LSIZE 8\n"
"#define LOG_NUM_BANKS 5\n"
"#define NUM_BANKS 32\n"
"#define GET_CONFLICT_OFFSET(lid) ((lid) >> LOG_NUM_BANKS)\n"
"#define noconvert\n"
"#if sdepth == 4\n"
"kernel void integral_cols(__global uchar4 *src, __global int *sum, __global TYPE *sqsum,\n"
"int src_offset, int pre_invalid, int rows, int cols, int src_step, int dst_step, int dst1_step)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"int4 src_t[2], sum_t[2];\n"
"TYPE4 sqsum_t[2];\n"
"__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local TYPE4 lm_sqsum[2][LSIZE + LOG_LSIZE];\n"
"__local int* sum_p;\n"
"__local TYPE* sqsum_p;\n"
"src_step = src_step >> 2;\n"
"gid = gid << 1;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + min(gid, cols - 1)]) : 0);\n"
"src_t[1] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + min(gid + 1, cols - 1)]) : 0);\n"
"sum_t[0] = (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[0] = (i == 0 ? (TYPE4)0 : lm_sqsum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[1] =  (i == 0 ? (TYPE4)0 : lm_sqsum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sqsum[0][bf_loc] = convert_TYPE4(src_t[0] * src_t[0]);\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"lm_sqsum[1][bf_loc] = convert_TYPE4(src_t[1] * src_t[1]);\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi]  +=  lm_sqsum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"lm_sqsum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi] += lm_sqsum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][ai] = lm_sqsum[lid >> 7][bi] - lm_sqsum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int loc_s0 = gid * dst_step  + i + lid - 1 - pre_invalid * dst_step /4, loc_s1 = loc_s0 + dst_step ;\n"
"int loc_sq0 = gid * CONVERT(dst1_step) + i + lid - 1 - pre_invalid * dst1_step / sizeof(TYPE),loc_sq1 = loc_sq0 + CONVERT(dst1_step);\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"lm_sqsum[0][bf_loc] += sqsum_t[0];\n"
"lm_sqsum[1][bf_loc] += sqsum_t[1];\n"
"sum_p = (__local int*)(&(lm_sum[0][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k >= cols + pre_invalid || gid * 4 + k < pre_invalid) continue;\n"
"sum[loc_s0 + k * dst_step / 4] = sum_p[k];\n"
"sqsum[loc_sq0 + k * dst1_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"sum_p = (__local int*)(&(lm_sum[1][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k + 4 >= cols + pre_invalid) break;\n"
"sum[loc_s1 + k * dst_step / 4] = sum_p[k];\n"
"sqsum[loc_sq1 + k * dst1_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"kernel void integral_rows(__global int4 *srcsum, __global TYPE4 * srcsqsum,__global int *sum,\n"
"__global TYPE *sqsum, int rows, int cols, int src_step, int src1_step, int sum_step,\n"
"int sqsum_step, int sum_offset, int sqsum_offset)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"int4 src_t[2], sum_t[2];\n"
"TYPE4 sqsrc_t[2],sqsum_t[2];\n"
"__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local TYPE4 lm_sqsum[2][LSIZE + LOG_LSIZE];\n"
"__local int *sum_p;\n"
"__local TYPE *sqsum_p;\n"
"src_step = src_step >> 4;\n"
"src1_step = (src1_step / sizeof(TYPE)) >> 2 ;\n"
"gid <<= 1;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = i + lid < rows ? srcsum[(lid+i) * src_step + gid ] : (int4)0;\n"
"sqsrc_t[0] = i + lid < rows ? srcsqsum[(lid+i) * src1_step + gid ] : (TYPE4)0;\n"
"src_t[1] = i + lid < rows ? srcsum[(lid+i) * src_step + gid  + 1] : (int4)0;\n"
"sqsrc_t[1] = i + lid < rows ? srcsqsum[(lid+i) * src1_step + gid  + 1] : (TYPE4)0;\n"
"sum_t[0] =  (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[0] =  (i == 0 ? (TYPE4)0 : lm_sqsum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[1] =  (i == 0 ? (TYPE4)0 : lm_sqsum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sqsum[0][bf_loc] = sqsrc_t[0];\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"lm_sqsum[1][bf_loc] = sqsrc_t[1];\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi]  +=  lm_sqsum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"lm_sqsum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi] += lm_sqsum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][ai] = lm_sqsum[lid >> 7][bi] - lm_sqsum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gid == 0 && (i + lid) <= rows)\n"
"{\n"
"sum[sum_offset + i + lid] = 0;\n"
"sqsum[sqsum_offset + i + lid] = 0;\n"
"}\n"
"if(i + lid == 0)\n"
"{\n"
"int loc0 = gid  * sum_step;\n"
"int loc1 = gid  * CONVERT(sqsum_step);\n"
"for(int k = 1; k <= 8; k++)\n"
"{\n"
"if(gid * 4 + k > cols) break;\n"
"sum[sum_offset + loc0 + k * sum_step / 4] = 0;\n"
"sqsum[sqsum_offset + loc1 + k * sqsum_step / sizeof(TYPE)] = 0;\n"
"}\n"
"}\n"
"int loc_s0 = sum_offset + gid  * sum_step + sum_step / 4 + i + lid, loc_s1 = loc_s0 + sum_step ;\n"
"int loc_sq0 = sqsum_offset + gid  * CONVERT(sqsum_step) + sqsum_step / sizeof(TYPE) + i + lid, loc_sq1 = loc_sq0 + CONVERT(sqsum_step) ;\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"lm_sqsum[0][bf_loc] += sqsum_t[0];\n"
"lm_sqsum[1][bf_loc] += sqsum_t[1];\n"
"sum_p = (__local int*)(&(lm_sum[0][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k >= cols) break;\n"
"sum[loc_s0 + k * sum_step / 4] = sum_p[k];\n"
"sqsum[loc_sq0 + k * sqsum_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"sum_p = (__local int*)(&(lm_sum[1][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + 4 + k >= cols) break;\n"
"sum[loc_s1 + k * sum_step / 4] = sum_p[k];\n"
"sqsum[loc_sq1 + k * sqsum_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"#elif sdepth == 5\n"
"kernel void integral_cols(__global uchar4 *src, __global float *sum, __global TYPE *sqsum,\n"
"int src_offset, int pre_invalid, int rows, int cols, int src_step, int dst_step, int dst1_step)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"float4 src_t[2], sum_t[2];\n"
"TYPE4 sqsum_t[2];\n"
"__local float4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local TYPE4 lm_sqsum[2][LSIZE + LOG_LSIZE];\n"
"__local float* sum_p;\n"
"__local TYPE* sqsum_p;\n"
"src_step = src_step >> 2;\n"
"gid = gid << 1;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = (i + lid < rows ? convert_float4(src[src_offset + (lid+i) * src_step + min(gid, cols - 1)]) : (float4)0);\n"
"src_t[1] = (i + lid < rows ? convert_float4(src[src_offset + (lid+i) * src_step + min(gid + 1, cols - 1)]) : (float4)0);\n"
"sum_t[0] = (i == 0 ? (float4)0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[0] = (i == 0 ? (TYPE4)0 : lm_sqsum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? (float4)0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[1] =  (i == 0 ? (TYPE4)0 : lm_sqsum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sqsum[0][bf_loc] = convert_TYPE4(src_t[0] * src_t[0]);\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"lm_sqsum[1][bf_loc] = convert_TYPE4(src_t[1] * src_t[1]);\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi]  +=  lm_sqsum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"lm_sqsum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi] += lm_sqsum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][ai] = lm_sqsum[lid >> 7][bi] - lm_sqsum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int loc_s0 = gid * dst_step + i + lid - 1 - pre_invalid * dst_step / 4, loc_s1 = loc_s0 + dst_step ;\n"
"int loc_sq0 = gid * CONVERT(dst1_step) + i + lid - 1 - pre_invalid * dst1_step / sizeof(TYPE), loc_sq1 = loc_sq0 + CONVERT(dst1_step);\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"lm_sqsum[0][bf_loc] += sqsum_t[0];\n"
"lm_sqsum[1][bf_loc] += sqsum_t[1];\n"
"sum_p = (__local float*)(&(lm_sum[0][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k >= cols + pre_invalid || gid * 4 + k < pre_invalid) continue;\n"
"sum[loc_s0 + k * dst_step / 4] = sum_p[k];\n"
"sqsum[loc_sq0 + k * dst1_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"sum_p = (__local float*)(&(lm_sum[1][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k + 4 >= cols + pre_invalid) break;\n"
"sum[loc_s1 + k * dst_step / 4] = sum_p[k];\n"
"sqsum[loc_sq1 + k * dst1_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"kernel void integral_rows(__global float4 *srcsum, __global TYPE4 * srcsqsum, __global float *sum ,\n"
"__global TYPE *sqsum, int rows, int cols, int src_step, int src1_step, int sum_step,\n"
"int sqsum_step, int sum_offset, int sqsum_offset)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"float4 src_t[2], sum_t[2];\n"
"TYPE4 sqsrc_t[2],sqsum_t[2];\n"
"__local float4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local TYPE4 lm_sqsum[2][LSIZE + LOG_LSIZE];\n"
"__local float *sum_p;\n"
"__local TYPE *sqsum_p;\n"
"src_step = src_step >> 4;\n"
"src1_step = (src1_step / sizeof(TYPE)) >> 2;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2] : (float4)0;\n"
"sqsrc_t[0] = i + lid < rows ? srcsqsum[(lid+i) * src1_step + gid * 2] : (TYPE4)0;\n"
"src_t[1] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2 + 1] : (float4)0;\n"
"sqsrc_t[1] = i + lid < rows ? srcsqsum[(lid+i) * src1_step + gid * 2 + 1] : (TYPE4)0;\n"
"sum_t[0] =  (i == 0 ? (float4)0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[0] =  (i == 0 ? (TYPE4)0 : lm_sqsum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? (float4)0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"sqsum_t[1] =  (i == 0 ? (TYPE4)0 : lm_sqsum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sqsum[0][bf_loc] = sqsrc_t[0];\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"lm_sqsum[1][bf_loc] = sqsrc_t[1];\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi]  +=  lm_sqsum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"lm_sqsum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][bi] += lm_sqsum[lid >> 7][ai];\n"
"lm_sqsum[lid >> 7][ai] = lm_sqsum[lid >> 7][bi] - lm_sqsum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gid == 0 && (i + lid) <= rows)\n"
"{\n"
"sum[sum_offset + i + lid] = 0;\n"
"sqsum[sqsum_offset + i + lid] = 0;\n"
"}\n"
"if(i + lid == 0)\n"
"{\n"
"int loc0 = gid * 2 * sum_step;\n"
"int loc1 = gid * 2 * CONVERT(sqsum_step);\n"
"for(int k = 1; k <= 8; k++)\n"
"{\n"
"if(gid * 8 + k > cols) break;\n"
"sum[sum_offset + loc0 + k * sum_step / 4] = 0;\n"
"sqsum[sqsum_offset + loc1 + k * sqsum_step / sizeof(TYPE)] = 0;\n"
"}\n"
"}\n"
"int loc_s0 = sum_offset + gid * 2 * sum_step + sum_step / 4 + i + lid, loc_s1 = loc_s0 + sum_step ;\n"
"int loc_sq0 = sqsum_offset + gid * 2 * CONVERT(sqsum_step) + sqsum_step / sizeof(TYPE) + i + lid, loc_sq1 = loc_sq0 + CONVERT(sqsum_step) ;\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"lm_sqsum[0][bf_loc] += sqsum_t[0];\n"
"lm_sqsum[1][bf_loc] += sqsum_t[1];\n"
"sum_p = (__local float*)(&(lm_sum[0][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + k >= cols) break;\n"
"sum[loc_s0 + k * sum_step / 4] = sum_p[k];\n"
"sqsum[loc_sq0 + k * sqsum_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"sum_p = (__local float*)(&(lm_sum[1][bf_loc]));\n"
"sqsum_p = (__local TYPE*)(&(lm_sqsum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + 4 + k >= cols) break;\n"
"sum[loc_s1 + k * sum_step / 4] = sum_p[k];\n"
"sqsum[loc_sq1 + k * sqsum_step / sizeof(TYPE)] = sqsum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"#endif\n"
, "584d5cd32272585a35804b7891b06893"};
ProgramSource integral_sqrsum_oclsrc(integral_sqrsum.programStr);
const struct ProgramEntry integral_sum={"integral_sum",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#define LSIZE 256\n"
"#define LSIZE_1 255\n"
"#define LSIZE_2 254\n"
"#define HF_LSIZE 128\n"
"#define LOG_LSIZE 8\n"
"#define LOG_NUM_BANKS 5\n"
"#define NUM_BANKS 32\n"
"#define GET_CONFLICT_OFFSET(lid) ((lid) >> LOG_NUM_BANKS)\n"
"#if sdepth == 4\n"
"kernel void integral_sum_cols(__global uchar4 *src, __global int *sum,\n"
"int src_offset, int pre_invalid, int rows, int cols, int src_step, int dst_step)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"int4 src_t[2], sum_t[2];\n"
"__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local int* sum_p;\n"
"src_step = src_step >> 2;\n"
"gid = gid << 1;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + gid]) : 0);\n"
"src_t[1] = (i + lid < rows ? convert_int4(src[src_offset + (lid+i) * src_step + gid + 1]) : 0);\n"
"sum_t[0] =  (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"int loc_s0 = gid * dst_step + i + lid - 1 - pre_invalid * dst_step / 4, loc_s1 = loc_s0 + dst_step ;\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"sum_p = (__local int*)(&(lm_sum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k >= cols + pre_invalid || gid * 4 + k < pre_invalid) continue;\n"
"sum[loc_s0 + k * dst_step / 4] = sum_p[k];\n"
"}\n"
"sum_p = (__local int*)(&(lm_sum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k + 4 >= cols + pre_invalid) break;\n"
"sum[loc_s1 + k * dst_step / 4] = sum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"kernel void integral_sum_rows(__global int4 *srcsum, __global int *sum,\n"
"int rows, int cols, int src_step, int sum_step, int sum_offset)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"int4 src_t[2], sum_t[2];\n"
"__local int4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local int *sum_p;\n"
"src_step = src_step >> 4;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2] : 0;\n"
"src_t[1] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2 + 1] : 0;\n"
"sum_t[0] =  (i == 0 ? 0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? 0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gid == 0 && (i + lid) <= rows)\n"
"{\n"
"sum[sum_offset + i + lid] = 0;\n"
"}\n"
"if(i + lid == 0)\n"
"{\n"
"int loc0 = gid * 2 * sum_step;\n"
"for(int k = 1; k <= 8; k++)\n"
"{\n"
"if(gid * 8 + k > cols) break;\n"
"sum[sum_offset + loc0 + k * sum_step / 4] = 0;\n"
"}\n"
"}\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"int loc_s0 = sum_offset + gid * 2 * sum_step + sum_step / 4 + i + lid, loc_s1 = loc_s0 + sum_step ;\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"sum_p = (__local int*)(&(lm_sum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + k >= cols) break;\n"
"sum[loc_s0 + k * sum_step / 4] = sum_p[k];\n"
"}\n"
"sum_p = (__local int*)(&(lm_sum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + 4 + k >= cols) break;\n"
"sum[loc_s1 + k * sum_step / 4] = sum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"#elif sdepth == 5\n"
"kernel void integral_sum_cols(__global uchar4 *src, __global float *sum,\n"
"int src_offset, int pre_invalid, int rows, int cols, int src_step, int dst_step)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"float4 src_t[2], sum_t[2];\n"
"__local float4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local float* sum_p;\n"
"src_step = src_step >> 2;\n"
"gid = gid << 1;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = (i + lid < rows ? convert_float4(src[src_offset + (lid+i) * src_step + gid]) : (float4)0);\n"
"src_t[1] = (i + lid < rows ? convert_float4(src[src_offset + (lid+i) * src_step + gid + 1]) : (float4)0);\n"
"sum_t[0] =  (i == 0 ? (float4)0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? (float4)0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"int loc_s0 = gid * dst_step + i + lid - 1 - pre_invalid * dst_step / 4, loc_s1 = loc_s0 + dst_step ;\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"sum_p = (__local float*)(&(lm_sum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k >= cols + pre_invalid || gid * 4 + k < pre_invalid) continue;\n"
"sum[loc_s0 + k * dst_step / 4] = sum_p[k];\n"
"}\n"
"sum_p = (__local float*)(&(lm_sum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 4 + k + 4 >= cols + pre_invalid) break;\n"
"sum[loc_s1 + k * dst_step / 4] = sum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"kernel void integral_sum_rows(__global float4 *srcsum, __global float *sum,\n"
"int rows, int cols, int src_step, int sum_step, int sum_offset)\n"
"{\n"
"int lid = get_local_id(0);\n"
"int gid = get_group_id(0);\n"
"float4 src_t[2], sum_t[2];\n"
"__local float4 lm_sum[2][LSIZE + LOG_LSIZE];\n"
"__local float *sum_p;\n"
"src_step = src_step >> 4;\n"
"for(int i = 0; i < rows; i =i + LSIZE_1)\n"
"{\n"
"src_t[0] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2] : (float4)0;\n"
"src_t[1] = i + lid < rows ? srcsum[(lid+i) * src_step + gid * 2 + 1] : (float4)0;\n"
"sum_t[0] =  (i == 0 ? (float4)0 : lm_sum[0][LSIZE_2 + LOG_LSIZE]);\n"
"sum_t[1] =  (i == 0 ? (float4)0 : lm_sum[1][LSIZE_2 + LOG_LSIZE]);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int bf_loc = lid + GET_CONFLICT_OFFSET(lid);\n"
"lm_sum[0][bf_loc] = src_t[0];\n"
"lm_sum[1][bf_loc] = src_t[1];\n"
"int offset = 1;\n"
"for(int d = LSIZE >> 1 ;  d > 0; d>>=1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi]  +=  lm_sum[lid >> 7][ai];\n"
"}\n"
"offset <<= 1;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(lid < 2)\n"
"{\n"
"lm_sum[lid][LSIZE_2 + LOG_LSIZE] = 0;\n"
"}\n"
"for(int d = 1;  d < LSIZE; d <<= 1)\n"
"{\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"offset >>= 1;\n"
"int ai = offset * (((lid & 127)<<1) +1) - 1,bi = ai + offset;\n"
"ai += GET_CONFLICT_OFFSET(ai);\n"
"bi += GET_CONFLICT_OFFSET(bi);\n"
"if((lid & 127) < d)\n"
"{\n"
"lm_sum[lid >> 7][bi] += lm_sum[lid >> 7][ai];\n"
"lm_sum[lid >> 7][ai] = lm_sum[lid >> 7][bi] - lm_sum[lid >> 7][ai];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if(gid == 0 && (i + lid) <= rows)\n"
"{\n"
"sum[sum_offset + i + lid] = 0;\n"
"}\n"
"if(i + lid == 0)\n"
"{\n"
"int loc0 = gid * 2 * sum_step;\n"
"for(int k = 1; k <= 8; k++)\n"
"{\n"
"if(gid * 8 + k > cols) break;\n"
"sum[sum_offset + loc0 + k * sum_step / 4] = 0;\n"
"}\n"
"}\n"
"if(lid > 0 && (i+lid) <= rows)\n"
"{\n"
"int loc_s0 = sum_offset + gid * 2 * sum_step + sum_step / 4 + i + lid, loc_s1 = loc_s0 + sum_step ;\n"
"lm_sum[0][bf_loc] += sum_t[0];\n"
"lm_sum[1][bf_loc] += sum_t[1];\n"
"sum_p = (__local float*)(&(lm_sum[0][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + k >= cols) break;\n"
"sum[loc_s0 + k * sum_step / 4] = sum_p[k];\n"
"}\n"
"sum_p = (__local float*)(&(lm_sum[1][bf_loc]));\n"
"for(int k = 0; k < 4; k++)\n"
"{\n"
"if(gid * 8 + 4 + k >= cols) break;\n"
"sum[loc_s1 + k * sum_step / 4] = sum_p[k];\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"}\n"
"#endif\n"
, "982fe063570bb84a5d4d82a633951813"};
ProgramSource integral_sum_oclsrc(integral_sum.programStr);
const struct ProgramEntry laplacian5={"laplacian5",
"#define noconvert\n"
"__kernel void sumConvert(__global const uchar * src1ptr, int src1_step, int src1_offset,\n"
"__global const uchar * src2ptr, int src2_step, int src2_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"coeffT scale, coeffT delta)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (y < dst_rows && x < dst_cols)\n"
"{\n"
"int src1_index = mad24(y, src1_step, mad24(x, (int)sizeof(srcT), src1_offset));\n"
"int src2_index = mad24(y, src2_step, mad24(x, (int)sizeof(srcT), src2_offset));\n"
"int dst_index = mad24(y, dst_step, mad24(x, (int)sizeof(dstT), dst_offset));\n"
"__global const srcT * src1 = (__global const srcT *)(src1ptr + src1_index);\n"
"__global const srcT * src2 = (__global const srcT *)(src2ptr + src2_index);\n"
"__global dstT * dst = (__global dstT *)(dstptr + dst_index);\n"
"#if wdepth <= 4\n"
"dst[0] = convertToDT( mad24((WT)(scale), convertToWT(src1[0]) + convertToWT(src2[0]), (WT)(delta)) );\n"
"#else\n"
"dst[0] = convertToDT( mad((WT)(scale), convertToWT(src1[0]) + convertToWT(src2[0]), (WT)(delta)) );\n"
"#endif\n"
"}\n"
"}\n"
, "7f685231a56f17c9cc2fd6cc4080e9d2"};
ProgramSource laplacian5_oclsrc(laplacian5.programStr);
const struct ProgramEntry match_template={"match_template",
"#define DATA_SIZE ((int)sizeof(type))\n"
"#define ELEM_TYPE elem_type\n"
"#define ELEM_SIZE ((int)sizeof(elem_type))\n"
"#define SQSUMS_PTR(ox, oy) mad24(y + oy, src_sqsums_step, mad24(x + ox, cn, src_sqsums_offset))\n"
"#define SUMS_PTR(ox, oy) mad24(y + oy, src_sums_step, mad24(x + ox, cn, src_sums_offset))\n"
"inline float normAcc(float num, float denum)\n"
"{\n"
"if (fabs(num) < denum)\n"
"return num / denum;\n"
"if (fabs(num) < denum * 1.125f)\n"
"return num > 0 ? 1 : -1;\n"
"return 0;\n"
"}\n"
"inline float normAcc_SQDIFF(float num, float denum)\n"
"{\n"
"if (fabs(num) < denum)\n"
"return num / denum;\n"
"if (fabs(num) < denum * 1.125f)\n"
"return num > 0 ? 1 : -1;\n"
"return 1;\n"
"}\n"
"#define noconvert\n"
"#if cn == 1\n"
"#define convertToDT(value) (float)(value)\n"
"#elif cn == 2\n"
"#define convertToDT(value) (float)(value.x + value.y)\n"
"#elif cn == 4\n"
"#define convertToDT(value) (float)(value.x + value.y + value.z + value.w)\n"
"#else\n"
"#error \"cn should be 1, 2 or 4\"\n"
"#endif\n"
"#ifdef CALC_SUM\n"
"__kernel void calcSum(__global const uchar * srcptr, int src_step, int src_offset,\n"
"int cols, int total, __global float * dst)\n"
"{\n"
"int lid = get_local_id(0), id = get_global_id(0);\n"
"__local WT localmem[WGS2_ALIGNED];\n"
"WT accumulator = (WT)(0), tmp;\n"
"for ( ; id < total; id += WGS)\n"
"{\n"
"int src_index = mad24(id / cols, src_step, mad24(id % cols, (int)sizeof(T), src_offset));\n"
"__global const T * src = (__global const T *)(srcptr + src_index);\n"
"tmp = convertToWT(src[0]);\n"
"#if wdepth == 4\n"
"accumulator = mad24(tmp, tmp, accumulator);\n"
"#else\n"
"accumulator = mad(tmp, tmp, accumulator);\n"
"#endif\n"
"}\n"
"if (lid < WGS2_ALIGNED)\n"
"localmem[lid] = accumulator;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (lid >= WGS2_ALIGNED && total >= WGS2_ALIGNED)\n"
"localmem[lid - WGS2_ALIGNED] += accumulator;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"for (int lsize = WGS2_ALIGNED >> 1; lsize > 0; lsize >>= 1)\n"
"{\n"
"if (lid < lsize)\n"
"{\n"
"int lid2 = lsize + lid;\n"
"localmem[lid] += localmem[lid2];\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"if (lid == 0)\n"
"dst[0] = convertToDT(localmem[0]);\n"
"}\n"
"#elif defined CCORR\n"
"__kernel void matchTemplate_Naive_CCORR(__global const uchar * srcptr, int src_step, int src_offset,\n"
"__global const uchar * templateptr, int template_step, int template_offset, int template_rows, int template_cols,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"WT sum = (WT)(0);\n"
"__global const T * src = (__global const T *)(srcptr + mad24(y, src_step, mad24(x, (int)sizeof(T), src_offset)));\n"
"__global const T * template = (__global const T *)(templateptr + template_offset);\n"
"for (int i = 0; i < template_rows; ++i)\n"
"{\n"
"for (int j = 0; j < template_cols; ++j)\n"
"#if wdepth == 4\n"
"sum = mad24(convertToWT(src[j]), convertToWT(template[j]), sum);\n"
"#else\n"
"sum = mad(convertToWT(src[j]), convertToWT(template[j]), sum);\n"
"#endif\n"
"src = (__global const T *)((__global const uchar *)src + src_step);\n"
"template = (__global const T *)((__global const uchar *)template + template_step);\n"
"}\n"
"int dst_idx = mad24(y, dst_step, mad24(x, (int)sizeof(float), dst_offset));\n"
"*(__global float *)(dst + dst_idx) = convertToDT(sum);\n"
"}\n"
"}\n"
"#elif defined CCORR_NORMED\n"
"__kernel void matchTemplate_CCORR_NORMED(__global const uchar * src_sqsums, int src_sqsums_step, int src_sqsums_offset,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"int template_rows, int template_cols, __global const float * template_sqsum)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"__global const float * sqsum = (__global const float *)(src_sqsums);\n"
"src_sqsums_step /= sizeof(float);\n"
"src_sqsums_offset /= sizeof(float);\n"
"float image_sqsum_ = (float)(sqsum[SQSUMS_PTR(template_cols, template_rows)] - sqsum[SQSUMS_PTR(template_cols, 0)] -\n"
"sqsum[SQSUMS_PTR(0, template_rows)] + sqsum[SQSUMS_PTR(0, 0)]);\n"
"int dst_idx = mad24(y, dst_step, mad24(x, (int)sizeof(float), dst_offset));\n"
"__global float * dstult = (__global float *)(dst + dst_idx);\n"
"*dstult = normAcc(*dstult, sqrt(image_sqsum_ * template_sqsum[0]));\n"
"}\n"
"}\n"
"#elif defined SQDIFF\n"
"__kernel void matchTemplate_Naive_SQDIFF(__global const uchar * srcptr, int src_step, int src_offset,\n"
"__global const uchar * templateptr, int template_step, int template_offset, int template_rows, int template_cols,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"__global const T * src = (__global const T *)(srcptr + mad24(y, src_step, mad24(x, (int)sizeof(T), src_offset)));\n"
"__global const T * template = (__global const T *)(templateptr + template_offset);\n"
"WT sum = (WT)(0), value;\n"
"for (int i = 0; i < template_rows; ++i)\n"
"{\n"
"for (int j = 0; j < template_cols; ++j)\n"
"{\n"
"value = convertToWT(src[j]) - convertToWT(template[j]);\n"
"#if wdepth == 4\n"
"sum = mad24(value, value, sum);\n"
"#else\n"
"sum = mad(value, value, sum);\n"
"#endif\n"
"}\n"
"src = (__global const T *)((__global const uchar *)src + src_step);\n"
"template = (__global const T *)((__global const uchar *)template + template_step);\n"
"}\n"
"int dst_idx = mad24(y, dst_step, mad24(x, (int)sizeof(float), dst_offset));\n"
"*(__global float *)(dst + dst_idx) = convertToDT(sum);\n"
"}\n"
"}\n"
"#elif defined SQDIFF_NORMED\n"
"__kernel void matchTemplate_SQDIFF_NORMED(__global const uchar * src_sqsums, int src_sqsums_step, int src_sqsums_offset,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"int template_rows, int template_cols, __global const float * template_sqsum)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"src_sqsums_step /= sizeof(float);\n"
"src_sqsums_offset /= sizeof(float);\n"
"__global const float * sqsum = (__global const float *)(src_sqsums);\n"
"float image_sqsum_ = (float)(\n"
"(sqsum[SQSUMS_PTR(template_cols, template_rows)] - sqsum[SQSUMS_PTR(template_cols, 0)]) -\n"
"(sqsum[SQSUMS_PTR(0, template_rows)] - sqsum[SQSUMS_PTR(0, 0)]));\n"
"float template_sqsum_value = template_sqsum[0];\n"
"int dst_idx = mad24(y, dst_step, mad24(x, (int)sizeof(float), dst_offset));\n"
"__global float * dstult = (__global float *)(dst + dst_idx);\n"
"*dstult = normAcc_SQDIFF(image_sqsum_ - 2.0f * dstult[0] + template_sqsum_value, sqrt(image_sqsum_ * template_sqsum_value));\n"
"}\n"
"}\n"
"#elif defined CCOEFF\n"
"#if cn == 1\n"
"__kernel void matchTemplate_Prepared_CCOEFF(__global const uchar * src_sums, int src_sums_step, int src_sums_offset,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"int template_rows, int template_cols, float template_sum)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"__global ELEM_TYPE* sum = (__global ELEM_TYPE*)(src_sums);\n"
"src_sums_step /= ELEM_SIZE;\n"
"src_sums_offset /= ELEM_SIZE;\n"
"float image_sum_ = (float)((sum[SUMS_PTR(template_cols, template_rows)] - sum[SUMS_PTR(template_cols, 0)])-\n"
"(sum[SUMS_PTR(0, template_rows)] - sum[SUMS_PTR(0, 0)])) * template_sum;\n"
"int dst_idx = mad24(y, dst_step, mad24(x, (int)sizeof(float), dst_offset));\n"
"__global float * dstult = (__global float *)(dst + dst_idx);\n"
"*dstult -= image_sum_;\n"
"}\n"
"}\n"
"#elif cn == 2\n"
"__kernel void matchTemplate_Prepared_CCOEFF(__global const uchar * src_sums, int src_sums_step, int src_sums_offset,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"int template_rows, int template_cols, float template_sum_0, float template_sum_1)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"src_sums_step /= ELEM_SIZE;\n"
"src_sums_offset /= ELEM_SIZE;\n"
"__global ELEM_TYPE* sum = (__global ELEM_TYPE*)(src_sums);\n"
"float image_sum_ = template_sum_0 * (float)((sum[SUMS_PTR(template_cols, template_rows)] - sum[SUMS_PTR(template_cols, 0)])    -(sum[SUMS_PTR(0, template_rows)] - sum[SUMS_PTR(0, 0)]));\n"
"image_sum_ += template_sum_1 * (float)((sum[SUMS_PTR(template_cols, template_rows)+1] - sum[SUMS_PTR(template_cols, 0)+1])-(sum[SUMS_PTR(0, template_rows)+1] - sum[SUMS_PTR(0, 0)+1]));\n"
"int dst_idx = mad24(y, dst_step, mad24(x, (int)sizeof(float), dst_offset));\n"
"__global float * dstult = (__global float *)(dst+dst_idx);\n"
"*dstult -= image_sum_;\n"
"}\n"
"}\n"
"#elif cn == 4\n"
"__kernel void matchTemplate_Prepared_CCOEFF(__global const uchar * src_sums, int src_sums_step, int src_sums_offset,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"int template_rows, int template_cols, float template_sum_0, float template_sum_1, float template_sum_2, float template_sum_3)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"src_sums_step /= ELEM_SIZE;\n"
"src_sums_offset /= ELEM_SIZE;\n"
"__global ELEM_TYPE* sum = (__global ELEM_TYPE*)(src_sums);\n"
"int c_r = SUMS_PTR(template_cols, template_rows);\n"
"int c_o = SUMS_PTR(template_cols, 0);\n"
"int o_r = SUMS_PTR(0,template_rows);\n"
"int oo = SUMS_PTR(0, 0);\n"
"float image_sum_ = template_sum_0 * (float)((sum[c_r]   - sum[c_o])  -(sum[o_r]   - sum[oo]));\n"
"image_sum_ += template_sum_1 * (float)((sum[c_r+1] - sum[c_o+1])-(sum[o_r+1] - sum[oo+1]));\n"
"image_sum_ += template_sum_2 * (float)((sum[c_r+2] - sum[c_o+2])-(sum[o_r+2] - sum[oo+2]));\n"
"image_sum_ += template_sum_3 * (float)((sum[c_r+3] - sum[c_o+3])-(sum[o_r+3] - sum[oo+3]));\n"
"int dst_idx = mad24(y, dst_step, mad24(x, (int)sizeof(float), dst_offset));\n"
"__global float * dstult = (__global float *)(dst+dst_idx);\n"
"*dstult -= image_sum_;\n"
"}\n"
"}\n"
"#else\n"
"#error \"cn should be 1, 2 or 4\"\n"
"#endif\n"
"#elif defined CCOEFF_NORMED\n"
"#if cn == 1\n"
"__kernel void matchTemplate_CCOEFF_NORMED(__global const uchar * src_sums, int src_sums_step, int src_sums_offset,\n"
"__global const uchar * src_sqsums, int src_sqsums_step, int src_sqsums_offset,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"int t_rows, int t_cols, float weight, float template_sum, float template_sqsum)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"src_sums_offset   /= ELEM_SIZE;\n"
"src_sums_step     /= ELEM_SIZE;\n"
"src_sqsums_step   /= sizeof(float);\n"
"src_sqsums_offset /= sizeof(float);\n"
"__global ELEM_TYPE* sum = (__global ELEM_TYPE*)(src_sums);\n"
"__global float * sqsum = (__global float*)(src_sqsums);\n"
"float image_sum_ =  (float)((sum[SUMS_PTR(t_cols, t_rows)] - sum[SUMS_PTR(t_cols, 0)]) -\n"
"(sum[SUMS_PTR(0, t_rows)] - sum[SUMS_PTR(0, 0)]));\n"
"float image_sqsum_ = (float)((sqsum[SQSUMS_PTR(t_cols, t_rows)] - sqsum[SQSUMS_PTR(t_cols, 0)]) -\n"
"(sqsum[SQSUMS_PTR(0, t_rows)] - sqsum[SQSUMS_PTR(0, 0)]));\n"
"int dst_idx = mad24(y, dst_step, mad24(x, (int)sizeof(float), dst_offset));\n"
"__global float * dstult = (__global float *)(dst+dst_idx);\n"
"*dstult = normAcc((*dstult) - image_sum_ * template_sum,\n"
"sqrt(template_sqsum * (image_sqsum_ - weight * image_sum_ * image_sum_)));\n"
"}\n"
"}\n"
"#elif cn == 2\n"
"__kernel void matchTemplate_CCOEFF_NORMED(__global const uchar * src_sums, int src_sums_step, int src_sums_offset,\n"
"__global const uchar * src_sqsums, int src_sqsums_step, int src_sqsums_offset,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"int t_rows, int t_cols, float weight, float template_sum_0, float template_sum_1, float template_sqsum)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"float sum_[2];\n"
"float sqsum_[2];\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"src_sums_offset   /= ELEM_SIZE;\n"
"src_sums_step     /= ELEM_SIZE;\n"
"src_sqsums_step   /= sizeof(float);\n"
"src_sqsums_offset /= sizeof(float);\n"
"__global ELEM_TYPE* sum = (__global ELEM_TYPE*)(src_sums);\n"
"__global float * sqsum = (__global float*)(src_sqsums);\n"
"sum_[0] =  (float)((sum[SUMS_PTR(t_cols, t_rows)] - sum[SUMS_PTR(t_cols, 0)])-(sum[SUMS_PTR(0, t_rows)] - sum[SUMS_PTR(0, 0)]));\n"
"sum_[1] =  (float)((sum[SUMS_PTR(t_cols, t_rows)+1] - sum[SUMS_PTR(t_cols, 0)+1])-(sum[SUMS_PTR(0, t_rows)+1] - sum[SUMS_PTR(0, 0)+1]));\n"
"sqsum_[0] = (float)((sqsum[SQSUMS_PTR(t_cols, t_rows)] - sqsum[SQSUMS_PTR(t_cols, 0)])-(sqsum[SQSUMS_PTR(0, t_rows)] - sqsum[SQSUMS_PTR(0, 0)]));\n"
"sqsum_[1] = (float)((sqsum[SQSUMS_PTR(t_cols, t_rows)+1] - sqsum[SQSUMS_PTR(t_cols, 0)+1])-(sqsum[SQSUMS_PTR(0, t_rows)+1] - sqsum[SQSUMS_PTR(0, 0)+1]));\n"
"float num = sum_[0]*template_sum_0 + sum_[1]*template_sum_1;\n"
"float denum = sqrt( template_sqsum * (sqsum_[0] - weight * sum_[0]* sum_[0] +\n"
"sqsum_[1] - weight * sum_[1]* sum_[1]));\n"
"int dst_idx = mad24(y, dst_step, mad24(x, (int)sizeof(float), dst_offset));\n"
"__global float * dstult = (__global float *)(dst+dst_idx);\n"
"*dstult = normAcc((*dstult) - num, denum);\n"
"}\n"
"}\n"
"#elif cn == 4\n"
"__kernel void matchTemplate_CCOEFF_NORMED(__global const uchar * src_sums, int src_sums_step, int src_sums_offset,\n"
"__global const uchar * src_sqsums, int src_sqsums_step, int src_sqsums_offset,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"int t_rows, int t_cols, float weight,\n"
"float template_sum_0, float template_sum_1, float template_sum_2, float template_sum_3,\n"
"float template_sqsum)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"float sum_[4];\n"
"float sqsum_[4];\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"src_sums_offset   /= ELEM_SIZE;\n"
"src_sums_step     /= ELEM_SIZE;\n"
"src_sqsums_step   /= sizeof(float);\n"
"src_sqsums_offset /= sizeof(float);\n"
"__global ELEM_TYPE* sum = (__global ELEM_TYPE*)(src_sums);\n"
"__global float * sqsum = (__global float*)(src_sqsums);\n"
"int c_r = SUMS_PTR(t_cols, t_rows);\n"
"int c_o = SUMS_PTR(t_cols, 0);\n"
"int o_r = SUMS_PTR(0, t_rows);\n"
"int o_o = SUMS_PTR(0, 0);\n"
"sum_[0] =  (float)((sum[c_r]   - sum[c_o])  -(sum[o_r]   - sum[o_o ]));\n"
"sum_[1] =  (float)((sum[c_r+1] - sum[c_o+1])-(sum[o_r+1] - sum[o_o +1]));\n"
"sum_[2] =  (float)((sum[c_r+2] - sum[c_o+2])-(sum[o_r+2] - sum[o_o +2]));\n"
"sum_[3] =  (float)((sum[c_r+3] - sum[c_o+3])-(sum[o_r+3] - sum[o_o +3]));\n"
"c_r = SQSUMS_PTR(t_cols, t_rows);\n"
"c_o = SQSUMS_PTR(t_cols, 0);\n"
"o_r = SQSUMS_PTR(0, t_rows);\n"
"o_o = SQSUMS_PTR(0, 0);\n"
"sqsum_[0] = (float)((sqsum[c_r]   - sqsum[c_o])  -(sqsum[o_r]   - sqsum[o_o]));\n"
"sqsum_[1] = (float)((sqsum[c_r+1] - sqsum[c_o+1])-(sqsum[o_r+1] - sqsum[o_o+1]));\n"
"sqsum_[2] = (float)((sqsum[c_r+2] - sqsum[c_o+2])-(sqsum[o_r+2] - sqsum[o_o+2]));\n"
"sqsum_[3] = (float)((sqsum[c_r+3] - sqsum[c_o+3])-(sqsum[o_r+3] - sqsum[o_o+3]));\n"
"float num = sum_[0]*template_sum_0 + sum_[1]*template_sum_1 + sum_[2]*template_sum_2 + sum_[3]*template_sum_3;\n"
"float denum = sqrt( template_sqsum * (\n"
"sqsum_[0] - weight * sum_[0]* sum_[0] +\n"
"sqsum_[1] - weight * sum_[1]* sum_[1] +\n"
"sqsum_[2] - weight * sum_[2]* sum_[2] +\n"
"sqsum_[3] - weight * sum_[3]* sum_[3] ));\n"
"int dst_idx = mad24(y, dst_step, mad24(x, (int)sizeof(float), dst_offset));\n"
"__global float * dstult = (__global float *)(dst+dst_idx);\n"
"*dstult = normAcc((*dstult) - num, denum);\n"
"}\n"
"}\n"
"#else\n"
"#error \"cn should be 1, 2 or 4\"\n"
"#endif\n"
"#endif\n"
, "e59cd827a206815a0fd2be3142745583"};
ProgramSource match_template_oclsrc(match_template.programStr);
const struct ProgramEntry medianFilter={"medianFilter",
"#if cn != 3\n"
"#define loadpix(addr) *(__global const T *)(addr)\n"
"#define storepix(val, addr)  *(__global T *)(addr) = val\n"
"#define TSIZE (int)sizeof(T)\n"
"#else\n"
"#define loadpix(addr) vload3(0, (__global const T1 *)(addr))\n"
"#define storepix(val, addr) vstore3(val, 0, (__global T1 *)(addr))\n"
"#define TSIZE (int)sizeof(T1) * cn\n"
"#endif\n"
"#define op(a, b) { mid = a; a = min(a, b); b = max(mid, b); }\n"
"__kernel void medianFilter3(__global const uchar * srcptr, int src_step, int src_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n"
"{\n"
"__local T data[18][18];\n"
"int x = get_local_id(0);\n"
"int y = get_local_id(1);\n"
"int gx = get_global_id(0);\n"
"int gy = get_global_id(1);\n"
"int dx = gx - x - 1;\n"
"int dy = gy - y - 1;\n"
"int id = min(mad24(x, 16, y), 9*18-1);\n"
"int dr = id / 18;\n"
"int dc = id % 18;\n"
"int c = clamp(dx + dc, 0, dst_cols - 1);\n"
"int r = clamp(dy + dr, 0, dst_rows - 1);\n"
"int index1 = mad24(r, src_step, mad24(c, TSIZE, src_offset));\n"
"r = clamp(dy + dr + 9, 0, dst_rows - 1);\n"
"int index9 = mad24(r, src_step, mad24(c, TSIZE, src_offset));\n"
"data[dr][dc] = loadpix(srcptr + index1);\n"
"data[dr+9][dc] = loadpix(srcptr + index9);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"T p0 = data[y][x], p1 = data[y][(x+1)], p2 = data[y][(x+2)];\n"
"T p3 = data[y+1][x], p4 = data[y+1][(x+1)], p5 = data[y+1][(x+2)];\n"
"T p6 = data[y+2][x], p7 = data[y+2][(x+1)], p8 = data[y+2][(x+2)];\n"
"T mid;\n"
"op(p1, p2); op(p4, p5); op(p7, p8); op(p0, p1);\n"
"op(p3, p4); op(p6, p7); op(p1, p2); op(p4, p5);\n"
"op(p7, p8); op(p0, p3); op(p5, p8); op(p4, p7);\n"
"op(p3, p6); op(p1, p4); op(p2, p5); op(p4, p7);\n"
"op(p4, p2); op(p6, p4); op(p4, p2);\n"
"int dst_index = mad24( gy, dst_step, mad24(gx, TSIZE, dst_offset));\n"
"if (gy < dst_rows && gx < dst_cols)\n"
"storepix(p4, dstptr + dst_index);\n"
"}\n"
"__kernel void medianFilter5(__global const uchar * srcptr, int src_step, int src_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n"
"{\n"
"__local T data[20][20];\n"
"int x = get_local_id(0);\n"
"int y = get_local_id(1);\n"
"int gx = get_global_id(0);\n"
"int gy = get_global_id(1);\n"
"int dx = gx - x - 2;\n"
"int dy = gy - y - 2;\n"
"int id = min(mad24(x, 16, y), 10*20-1);\n"
"int dr = id / 20;\n"
"int dc = id % 20;\n"
"int c = clamp(dx + dc, 0, dst_cols - 1);\n"
"int r = clamp(dy + dr, 0, dst_rows - 1);\n"
"int index1 = mad24(r, src_step, mad24(c, TSIZE, src_offset));\n"
"r = clamp(dy + dr + 10, 0, dst_rows - 1);\n"
"int index10 = mad24(r, src_step, mad24(c, TSIZE, src_offset));\n"
"data[dr][dc] = loadpix(srcptr + index1);\n"
"data[dr+10][dc] = loadpix(srcptr + index10);\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"T p0 = data[y][x], p1 = data[y][x+1], p2 = data[y][x+2], p3 = data[y][x+3], p4 = data[y][x+4];\n"
"T p5 = data[y+1][x], p6 = data[y+1][x+1], p7 = data[y+1][x+2], p8 = data[y+1][x+3], p9 = data[y+1][x+4];\n"
"T p10 = data[y+2][x], p11 = data[y+2][x+1], p12 = data[y+2][x+2], p13 = data[y+2][x+3], p14 = data[y+2][x+4];\n"
"T p15 = data[y+3][x], p16 = data[y+3][x+1], p17 = data[y+3][x+2], p18 = data[y+3][x+3], p19 = data[y+3][x+4];\n"
"T p20 = data[y+4][x], p21 = data[y+4][x+1], p22 = data[y+4][x+2], p23 = data[y+4][x+3], p24 = data[y+4][x+4];\n"
"T mid;\n"
"op(p1, p2); op(p0, p1); op(p1, p2); op(p4, p5); op(p3, p4);\n"
"op(p4, p5); op(p0, p3); op(p2, p5); op(p2, p3); op(p1, p4);\n"
"op(p1, p2); op(p3, p4); op(p7, p8); op(p6, p7); op(p7, p8);\n"
"op(p10, p11); op(p9, p10); op(p10, p11); op(p6, p9); op(p8, p11);\n"
"op(p8, p9); op(p7, p10); op(p7, p8); op(p9, p10); op(p0, p6);\n"
"op(p4, p10); op(p4, p6); op(p2, p8); op(p2, p4); op(p6, p8);\n"
"op(p1, p7); op(p5, p11); op(p5, p7); op(p3, p9); op(p3, p5);\n"
"op(p7, p9); op(p1, p2); op(p3, p4); op(p5, p6); op(p7, p8);\n"
"op(p9, p10); op(p13, p14); op(p12, p13); op(p13, p14); op(p16, p17);\n"
"op(p15, p16); op(p16, p17); op(p12, p15); op(p14, p17); op(p14, p15);\n"
"op(p13, p16); op(p13, p14); op(p15, p16); op(p19, p20); op(p18, p19);\n"
"op(p19, p20); op(p21, p22); op(p23, p24); op(p21, p23); op(p22, p24);\n"
"op(p22, p23); op(p18, p21); op(p20, p23); op(p20, p21); op(p19, p22);\n"
"op(p22, p24); op(p19, p20); op(p21, p22); op(p23, p24); op(p12, p18);\n"
"op(p16, p22); op(p16, p18); op(p14, p20); op(p20, p24); op(p14, p16);\n"
"op(p18, p20); op(p22, p24); op(p13, p19); op(p17, p23); op(p17, p19);\n"
"op(p15, p21); op(p15, p17); op(p19, p21); op(p13, p14); op(p15, p16);\n"
"op(p17, p18); op(p19, p20); op(p21, p22); op(p23, p24); op(p0, p12);\n"
"op(p8, p20); op(p8, p12); op(p4, p16); op(p16, p24); op(p12, p16);\n"
"op(p2, p14); op(p10, p22); op(p10, p14); op(p6, p18); op(p6, p10);\n"
"op(p10, p12); op(p1, p13); op(p9, p21); op(p9, p13); op(p5, p17);\n"
"op(p13, p17); op(p3, p15); op(p11, p23); op(p11, p15); op(p7, p19);\n"
"op(p7, p11); op(p11, p13); op(p11, p12);\n"
"int dst_index = mad24(gy, dst_step, mad24(gx, TSIZE, dst_offset));\n"
"if (gy < dst_rows && gx < dst_cols)\n"
"storepix(p12, dstptr + dst_index);\n"
"}\n"
, "b856bb902c1a5e7f76f87e44dda12946"};
ProgramSource medianFilter_oclsrc(medianFilter.programStr);
const struct ProgramEntry moments={"moments",
"#if TILE_SIZE != 32\n"
"#error \"TILE SIZE should be 32\"\n"
"#endif\n"
"__kernel void moments(__global const uchar* src, int src_step, int src_offset,\n"
"int src_rows, int src_cols, __global int* mom0, int xtiles)\n"
"{\n"
"int x0 = get_global_id(0);\n"
"int y0 = get_group_id(1);\n"
"int x, y = get_local_id(1);\n"
"int x_min = x0*TILE_SIZE;\n"
"int ypix = y0*TILE_SIZE + y;\n"
"__local int mom[TILE_SIZE][10];\n"
"if( x_min < src_cols && y0*TILE_SIZE < src_rows )\n"
"{\n"
"if( ypix < src_rows )\n"
"{\n"
"int x_max = min(src_cols - x_min, TILE_SIZE);\n"
"__global const uchar* ptr = src + src_offset + ypix*src_step + x_min;\n"
"int4 S = (int4)(0,0,0,0), p;\n"
"#define SUM_ELEM(elem, ofs) \\\n"
"(int4)(1, (ofs), (ofs)*(ofs), (ofs)*(ofs)*(ofs))*elem\n"
"x = x_max & -4;\n"
"if( x_max >= 4 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr));\n"
"S += SUM_ELEM(p.s0, 0) + SUM_ELEM(p.s1, 1) + SUM_ELEM(p.s2, 2) + SUM_ELEM(p.s3, 3);\n"
"if( x_max >= 8 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr+4));\n"
"S += SUM_ELEM(p.s0, 4) + SUM_ELEM(p.s1, 5) + SUM_ELEM(p.s2, 6) + SUM_ELEM(p.s3, 7);\n"
"if( x_max >= 12 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr+8));\n"
"S += SUM_ELEM(p.s0, 8) + SUM_ELEM(p.s1, 9) + SUM_ELEM(p.s2, 10) + SUM_ELEM(p.s3, 11);\n"
"if( x_max >= 16 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr+12));\n"
"S += SUM_ELEM(p.s0, 12) + SUM_ELEM(p.s1, 13) + SUM_ELEM(p.s2, 14) + SUM_ELEM(p.s3, 15);\n"
"}\n"
"}\n"
"}\n"
"}\n"
"if( x_max >= 20 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr+16));\n"
"S += SUM_ELEM(p.s0, 16) + SUM_ELEM(p.s1, 17) + SUM_ELEM(p.s2, 18) + SUM_ELEM(p.s3, 19);\n"
"if( x_max >= 24 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr+20));\n"
"S += SUM_ELEM(p.s0, 20) + SUM_ELEM(p.s1, 21) + SUM_ELEM(p.s2, 22) + SUM_ELEM(p.s3, 23);\n"
"if( x_max >= 28 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr+24));\n"
"S += SUM_ELEM(p.s0, 24) + SUM_ELEM(p.s1, 25) + SUM_ELEM(p.s2, 26) + SUM_ELEM(p.s3, 27);\n"
"if( x_max >= 32 )\n"
"{\n"
"p = convert_int4(vload4(0, ptr+28));\n"
"S += SUM_ELEM(p.s0, 28) + SUM_ELEM(p.s1, 29) + SUM_ELEM(p.s2, 30) + SUM_ELEM(p.s3, 31);\n"
"}\n"
"}\n"
"}\n"
"}\n"
"if( x < x_max )\n"
"{\n"
"int ps = ptr[x];\n"
"S += SUM_ELEM(ps, x);\n"
"if( x+1 < x_max )\n"
"{\n"
"ps = ptr[x+1];\n"
"S += SUM_ELEM(ps, x+1);\n"
"if( x+2 < x_max )\n"
"{\n"
"ps = ptr[x+2];\n"
"S += SUM_ELEM(ps, x+2);\n"
"}\n"
"}\n"
"}\n"
"int sy = y*y;\n"
"mom[y][0] = S.s0;\n"
"mom[y][1] = S.s1;\n"
"mom[y][2] = y*S.s0;\n"
"mom[y][3] = S.s2;\n"
"mom[y][4] = y*S.s1;\n"
"mom[y][5] = sy*S.s0;\n"
"mom[y][6] = S.s3;\n"
"mom[y][7] = y*S.s2;\n"
"mom[y][8] = sy*S.s1;\n"
"mom[y][9] = y*sy*S.s0;\n"
"}\n"
"else\n"
"mom[y][0] = mom[y][1] = mom[y][2] = mom[y][3] = mom[y][4] =\n"
"mom[y][5] = mom[y][6] = mom[y][7] = mom[y][8] = mom[y][9] = 0;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"#define REDUCE(d) \\\n"
"if( y < d ) \\\n"
"{ \\\n"
"mom[y][0] += mom[y+d][0]; \\\n"
"mom[y][1] += mom[y+d][1]; \\\n"
"mom[y][2] += mom[y+d][2]; \\\n"
"mom[y][3] += mom[y+d][3]; \\\n"
"mom[y][4] += mom[y+d][4]; \\\n"
"mom[y][5] += mom[y+d][5]; \\\n"
"mom[y][6] += mom[y+d][6]; \\\n"
"mom[y][7] += mom[y+d][7]; \\\n"
"mom[y][8] += mom[y+d][8]; \\\n"
"mom[y][9] += mom[y+d][9]; \\\n"
"} \\\n"
"barrier(CLK_LOCAL_MEM_FENCE)\n"
"REDUCE(16);\n"
"REDUCE(8);\n"
"REDUCE(4);\n"
"REDUCE(2);\n"
"if( y == 0 )\n"
"{\n"
"__global int* momout = mom0 + (y0*xtiles + x0)*10;\n"
"momout[0] = mom[0][0] + mom[1][0];\n"
"momout[1] = mom[0][1] + mom[1][1];\n"
"momout[2] = mom[0][2] + mom[1][2];\n"
"momout[3] = mom[0][3] + mom[1][3];\n"
"momout[4] = mom[0][4] + mom[1][4];\n"
"momout[5] = mom[0][5] + mom[1][5];\n"
"momout[6] = mom[0][6] + mom[1][6];\n"
"momout[7] = mom[0][7] + mom[1][7];\n"
"momout[8] = mom[0][8] + mom[1][8];\n"
"momout[9] = mom[0][9] + mom[1][9];\n"
"}\n"
"}\n"
"}\n"
, "be1de12b5a5f3107088ae3f80818d51b"};
ProgramSource moments_oclsrc(moments.programStr);
const struct ProgramEntry morph={"morph",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#if cn != 3\n"
"#define loadpix(addr) *(__global const T *)(addr)\n"
"#define storepix(val, addr)  *(__global T *)(addr) = val\n"
"#define TSIZE (int)sizeof(T)\n"
"#else\n"
"#define loadpix(addr) vload3(0, (__global const T1 *)(addr))\n"
"#define storepix(val, addr) vstore3(val, 0, (__global T1 *)(addr))\n"
"#define TSIZE ((int)sizeof(T1)*3)\n"
"#endif\n"
"#ifdef DEPTH_0\n"
"#ifdef ERODE\n"
"#define VAL 255\n"
"#endif\n"
"#ifdef DILATE\n"
"#define VAL 0\n"
"#endif\n"
"#elif defined DEPTH_5\n"
"#ifdef ERODE\n"
"#define VAL FLT_MAX\n"
"#endif\n"
"#ifdef DILATE\n"
"#define VAL -FLT_MAX\n"
"#endif\n"
"#elif defined DEPTH_6\n"
"#ifdef ERODE\n"
"#define VAL DBL_MAX\n"
"#endif\n"
"#ifdef DILATE\n"
"#define VAL -DBL_MAX\n"
"#endif\n"
"#endif\n"
"#ifdef ERODE\n"
"#ifdef INTEL_DEVICE\n"
"#define MORPH_OP(A,B) ((A) < (B) ? (A) : (B))\n"
"#else\n"
"#define MORPH_OP(A,B) min((A),(B))\n"
"#endif\n"
"#endif\n"
"#ifdef DILATE\n"
"#define MORPH_OP(A,B) max((A),(B))\n"
"#endif\n"
"#define ELEM(i, l_edge, r_edge, elem1, elem2) (i) < (l_edge) | (i) >= (r_edge) ? (elem1) : (elem2)\n"
"__kernel void morph(__global const uchar * srcptr, int src_step, int src_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset,\n"
"int src_offset_x, int src_offset_y, int cols, int rows,\n"
"__constant uchar * mat_kernel, int src_whole_cols, int src_whole_rows)\n"
"{\n"
"int gidx = get_global_id(0), gidy = get_global_id(1);\n"
"int l_x = get_local_id(0), l_y = get_local_id(1);\n"
"int x = get_group_id(0) * LSIZE0, y = get_group_id(1) * LSIZE1;\n"
"int start_x = x + src_offset_x - RADIUSX;\n"
"int end_x = x + src_offset_x + LSIZE0 + RADIUSX;\n"
"int width = end_x - (x + src_offset_x - RADIUSX) + 1;\n"
"int start_y = y + src_offset_y - RADIUSY;\n"
"int point1 = mad24(l_y, LSIZE0, l_x);\n"
"int point2 = point1 + LSIZE0 * LSIZE1;\n"
"int tl_x = point1 % width, tl_y = point1 / width;\n"
"int tl_x2 = point2 % width, tl_y2 = point2 / width;\n"
"int cur_x = start_x + tl_x, cur_y = start_y + tl_y;\n"
"int cur_x2 = start_x + tl_x2, cur_y2 = start_y + tl_y2;\n"
"int start_addr = mad24(cur_y, src_step, cur_x * TSIZE);\n"
"int start_addr2 = mad24(cur_y2, src_step, cur_x2 * TSIZE);\n"
"__local T LDS_DAT[2*LSIZE1*LSIZE0];\n"
"int end_addr = mad24(src_whole_rows - 1, src_step, src_whole_cols * TSIZE);\n"
"start_addr = start_addr < end_addr && start_addr > 0 ? start_addr : 0;\n"
"start_addr2 = start_addr2 < end_addr && start_addr2 > 0 ? start_addr2 : 0;\n"
"T temp0 = loadpix(srcptr + start_addr);\n"
"T temp1 = loadpix(srcptr + start_addr2);\n"
"temp0 = ELEM(cur_x, 0, src_whole_cols, (T)(VAL),temp0);\n"
"temp0 = ELEM(cur_y, 0, src_whole_rows, (T)(VAL),temp0);\n"
"temp1 = ELEM(cur_x2, 0, src_whole_cols, (T)(VAL), temp1);\n"
"temp1 = ELEM(cur_y2, 0, src_whole_rows, (T)(VAL), temp1);\n"
"LDS_DAT[point1] = temp0;\n"
"LDS_DAT[point2] = temp1;\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"T res = (T)(VAL);\n"
"for (int i = 0, sizey = 2 * RADIUSY + 1; i < sizey; i++)\n"
"for (int j = 0, sizex = 2 * RADIUSX + 1; j < sizex; j++)\n"
"{\n"
"res =\n"
"#ifndef RECTKERNEL\n"
"mat_kernel[i*(2*RADIUSX+1)+j] ?\n"
"#endif\n"
"MORPH_OP(res, LDS_DAT[mad24(l_y + i, width, l_x + j)])\n"
"#ifndef RECTKERNEL\n"
": res\n"
"#endif\n"
";\n"
"}\n"
"if (gidx < cols && gidy < rows)\n"
"{\n"
"int dst_index = mad24(gidy, dst_step, mad24(gidx, TSIZE, dst_offset));\n"
"storepix(res, dstptr + dst_index);\n"
"}\n"
"}\n"
, "1c1a55fb3c470a52a9030c8610216f50"};
ProgramSource morph_oclsrc(morph.programStr);
const struct ProgramEntry precornerdetect={"precornerdetect",
"__kernel void preCornerDetect(__global const uchar * Dxptr, int dx_step, int dx_offset,\n"
"__global const uchar * Dyptr, int dy_step, int dy_offset,\n"
"__global const uchar * D2xptr, int d2x_step, int d2x_offset,\n"
"__global const uchar * D2yptr, int d2y_step, int d2y_offset,\n"
"__global const uchar * Dxyptr, int dxy_step, int dxy_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset,\n"
"int dst_rows, int dst_cols, float factor)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int dx_index = mad24(dx_step, y, (int)sizeof(float) * x + dx_offset);\n"
"int dy_index = mad24(dy_step, y, (int)sizeof(float) * x + dy_offset);\n"
"int d2x_index = mad24(d2x_step, y, (int)sizeof(float) * x + d2x_offset);\n"
"int d2y_index = mad24(d2y_step, y, (int)sizeof(float) * x + d2y_offset);\n"
"int dxy_index = mad24(dxy_step, y, (int)sizeof(float) * x + dxy_offset);\n"
"int dst_index = mad24(dst_step, y, (int)sizeof(float) * x + dst_offset);\n"
"float dx = *(__global const float *)(Dxptr + dx_index);\n"
"float dy = *(__global const float *)(Dyptr + dy_index);\n"
"float d2x = *(__global const float *)(D2xptr + d2x_index);\n"
"float d2y = *(__global const float *)(D2yptr + d2y_index);\n"
"float dxy = *(__global const float *)(Dxyptr + dxy_index);\n"
"__global float * dst = (__global float *)(dstptr + dst_index);\n"
"dst[0] = factor * (dx*dx*d2y + dy*dy*d2x - 2*dx*dy*dxy);\n"
"}\n"
"}\n"
, "14a94db70b88aa76ff8840f03f3ad556"};
ProgramSource precornerdetect_oclsrc(precornerdetect.programStr);
const struct ProgramEntry pyr_down={"pyr_down",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#if cn != 3\n"
"#define loadpix(addr)  *(__global const T*)(addr)\n"
"#define storepix(val, addr)  *(__global T*)(addr) = (val)\n"
"#define PIXSIZE ((int)sizeof(T))\n"
"#else\n"
"#define loadpix(addr)  vload3(0, (__global const T1*)(addr))\n"
"#define storepix(val, addr) vstore3((val), 0, (__global T1*)(addr))\n"
"#define PIXSIZE ((int)sizeof(T1)*3)\n"
"#endif\n"
"#define noconvert\n"
"inline int idx_row_low(int y, int last_row)\n"
"{\n"
"return abs(y) % (last_row + 1);\n"
"}\n"
"inline int idx_row_high(int y, int last_row)\n"
"{\n"
"return abs(last_row - (int)abs(last_row - y)) % (last_row + 1);\n"
"}\n"
"inline int idx_row(int y, int last_row)\n"
"{\n"
"return idx_row_low(idx_row_high(y, last_row), last_row);\n"
"}\n"
"inline int idx_col_low(int x, int last_col)\n"
"{\n"
"return abs(x) % (last_col + 1);\n"
"}\n"
"inline int idx_col_high(int x, int last_col)\n"
"{\n"
"return abs(last_col - (int)abs(last_col - x)) % (last_col + 1);\n"
"}\n"
"inline int idx_col(int x, int last_col)\n"
"{\n"
"return idx_col_low(idx_col_high(x, last_col), last_col);\n"
"}\n"
"__kernel void pyrDown(__global const uchar * src, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_group_id(1);\n"
"__local FT smem[256 + 4];\n"
"__global uchar * dstData = dst + dst_offset;\n"
"__global const uchar * srcData = src + src_offset;\n"
"FT sum;\n"
"FT co1 = 0.375f;\n"
"FT co2 = 0.25f;\n"
"FT co3 = 0.0625f;\n"
"const int src_y = 2*y;\n"
"const int last_row = src_rows - 1;\n"
"const int last_col = src_cols - 1;\n"
"if (src_y >= 2 && src_y < src_rows - 2 && x >= 2 && x < src_cols - 2)\n"
"{\n"
"sum =       co3 * convertToFT(loadpix(srcData + (src_y - 2) * src_step + x * PIXSIZE));\n"
"sum = sum + co2 * convertToFT(loadpix(srcData + (src_y - 1) * src_step + x * PIXSIZE));\n"
"sum = sum + co1 * convertToFT(loadpix(srcData + (src_y    ) * src_step + x * PIXSIZE));\n"
"sum = sum + co2 * convertToFT(loadpix(srcData + (src_y + 1) * src_step + x * PIXSIZE));\n"
"sum = sum + co3 * convertToFT(loadpix(srcData + (src_y + 2) * src_step + x * PIXSIZE));\n"
"smem[2 + get_local_id(0)] = sum;\n"
"if (get_local_id(0) < 2)\n"
"{\n"
"const int left_x = x - 2;\n"
"sum =       co3 * convertToFT(loadpix(srcData + (src_y - 2) * src_step + left_x * PIXSIZE));\n"
"sum = sum + co2 * convertToFT(loadpix(srcData + (src_y - 1) * src_step + left_x * PIXSIZE));\n"
"sum = sum + co1 * convertToFT(loadpix(srcData + (src_y    ) * src_step + left_x * PIXSIZE));\n"
"sum = sum + co2 * convertToFT(loadpix(srcData + (src_y + 1) * src_step + left_x * PIXSIZE));\n"
"sum = sum + co3 * convertToFT(loadpix(srcData + (src_y + 2) * src_step + left_x * PIXSIZE));\n"
"smem[get_local_id(0)] = sum;\n"
"}\n"
"if (get_local_id(0) > 253)\n"
"{\n"
"const int right_x = x + 2;\n"
"sum =       co3 * convertToFT(loadpix(srcData + (src_y - 2) * src_step + right_x * PIXSIZE));\n"
"sum = sum + co2 * convertToFT(loadpix(srcData + (src_y - 1) * src_step + right_x * PIXSIZE));\n"
"sum = sum + co1 * convertToFT(loadpix(srcData + (src_y    ) * src_step + right_x * PIXSIZE));\n"
"sum = sum + co2 * convertToFT(loadpix(srcData + (src_y + 1) * src_step + right_x * PIXSIZE));\n"
"sum = sum + co3 * convertToFT(loadpix(srcData + (src_y + 2) * src_step + right_x * PIXSIZE));\n"
"smem[4 + get_local_id(0)] = sum;\n"
"}\n"
"}\n"
"else\n"
"{\n"
"int col = idx_col(x, last_col);\n"
"sum =       co3 * convertToFT(loadpix(srcData + idx_row(src_y - 2, last_row) * src_step + col * PIXSIZE));\n"
"sum = sum + co2 * convertToFT(loadpix(srcData + idx_row(src_y - 1, last_row) * src_step + col * PIXSIZE));\n"
"sum = sum + co1 * convertToFT(loadpix(srcData + idx_row(src_y    , last_row) * src_step + col * PIXSIZE));\n"
"sum = sum + co2 * convertToFT(loadpix(srcData + idx_row(src_y + 1, last_row) * src_step + col * PIXSIZE));\n"
"sum = sum + co3 * convertToFT(loadpix(srcData + idx_row(src_y + 2, last_row) * src_step + col * PIXSIZE));\n"
"smem[2 + get_local_id(0)] = sum;\n"
"if (get_local_id(0) < 2)\n"
"{\n"
"const int left_x = x - 2;\n"
"col = idx_col(left_x, last_col);\n"
"sum =       co3 * convertToFT(loadpix(srcData + idx_row(src_y - 2, last_row) * src_step + col * PIXSIZE));\n"
"sum = sum + co2 * convertToFT(loadpix(srcData + idx_row(src_y - 1, last_row) * src_step + col * PIXSIZE));\n"
"sum = sum + co1 * convertToFT(loadpix(srcData + idx_row(src_y    , last_row) * src_step + col * PIXSIZE));\n"
"sum = sum + co2 * convertToFT(loadpix(srcData + idx_row(src_y + 1, last_row) * src_step + col * PIXSIZE));\n"
"sum = sum + co3 * convertToFT(loadpix(srcData + idx_row(src_y + 2, last_row) * src_step + col * PIXSIZE));\n"
"smem[get_local_id(0)] = sum;\n"
"}\n"
"if (get_local_id(0) > 253)\n"
"{\n"
"const int right_x = x + 2;\n"
"col = idx_col(right_x, last_col);\n"
"sum =       co3 * convertToFT(loadpix(srcData + idx_row(src_y - 2, last_row) * src_step + col * PIXSIZE));\n"
"sum = sum + co2 * convertToFT(loadpix(srcData + idx_row(src_y - 1, last_row) * src_step + col * PIXSIZE));\n"
"sum = sum + co1 * convertToFT(loadpix(srcData + idx_row(src_y    , last_row) * src_step + col * PIXSIZE));\n"
"sum = sum + co2 * convertToFT(loadpix(srcData + idx_row(src_y + 1, last_row) * src_step + col * PIXSIZE));\n"
"sum = sum + co3 * convertToFT(loadpix(srcData + idx_row(src_y + 2, last_row) * src_step + col * PIXSIZE));\n"
"smem[4 + get_local_id(0)] = sum;\n"
"}\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"if (get_local_id(0) < 128)\n"
"{\n"
"const int tid2 = get_local_id(0) * 2;\n"
"sum =       co3 * smem[2 + tid2 - 2];\n"
"sum = sum + co2 * smem[2 + tid2 - 1];\n"
"sum = sum + co1 * smem[2 + tid2    ];\n"
"sum = sum + co2 * smem[2 + tid2 + 1];\n"
"sum = sum + co3 * smem[2 + tid2 + 2];\n"
"const int dst_x = (get_group_id(0) * get_local_size(0) + tid2) / 2;\n"
"if (dst_x < dst_cols)\n"
"storepix(convertToT(sum), dstData + y * dst_step + dst_x * PIXSIZE);\n"
"}\n"
"}\n"
, "7c98a8abc769ca4cf0362ff51e36a495"};
ProgramSource pyr_down_oclsrc(pyr_down.programStr);
const struct ProgramEntry pyr_up={"pyr_up",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#if cn != 3\n"
"#define loadpix(addr)  *(__global const T*)(addr)\n"
"#define storepix(val, addr)  *(__global T*)(addr) = (val)\n"
"#define PIXSIZE ((int)sizeof(T))\n"
"#else\n"
"#define loadpix(addr)  vload3(0, (__global const T1*)(addr))\n"
"#define storepix(val, addr) vstore3((val), 0, (__global T1*)(addr))\n"
"#define PIXSIZE ((int)sizeof(T1)*3)\n"
"#endif\n"
"#define noconvert\n"
"__kernel void pyrUp(__global const uchar * src, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n"
"{\n"
"const int x = get_global_id(0);\n"
"const int y = get_global_id(1);\n"
"const int lsizex = get_local_size(0);\n"
"const int lsizey = get_local_size(1);\n"
"const int tidx = get_local_id(0);\n"
"const int tidy = get_local_id(1);\n"
"__local FT s_srcPatch[10][10];\n"
"__local FT s_dstPatch[20][16];\n"
"__global uchar * dstData = dst + dst_offset;\n"
"__global const uchar * srcData = src + src_offset;\n"
"if( tidx < 10 && tidy < 10 )\n"
"{\n"
"int srcx = mad24((int)get_group_id(0), lsizex>>1, tidx) - 1;\n"
"int srcy = mad24((int)get_group_id(1), lsizey>>1, tidy) - 1;\n"
"srcx = abs(srcx);\n"
"srcx = min(src_cols - 1, srcx);\n"
"srcy = abs(srcy);\n"
"srcy = min(src_rows - 1, srcy);\n"
"s_srcPatch[tidy][tidx] = convertToFT(loadpix(srcData + srcy * src_step + srcx * PIXSIZE));\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"FT sum = 0.f;\n"
"const FT evenFlag = (FT)((tidx & 1) == 0);\n"
"const FT  oddFlag = (FT)((tidx & 1) != 0);\n"
"const bool  eveny = ((tidy & 1) == 0);\n"
"const FT co1 = 0.375f;\n"
"const FT co2 = 0.25f;\n"
"const FT co3 = 0.0625f;\n"
"if(eveny)\n"
"{\n"
"sum =       ( evenFlag* co3 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * co2 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + ( evenFlag* co1 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * co2 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + ( evenFlag* co3 ) * s_srcPatch[1 + (tidy >> 1)][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[2 + tidy][tidx] = sum;\n"
"if (tidy < 2)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum =       (evenFlag * co3 ) * s_srcPatch[lsizey-16][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * co2 ) * s_srcPatch[lsizey-16][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * co1 ) * s_srcPatch[lsizey-16][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * co2 ) * s_srcPatch[lsizey-16][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * co3 ) * s_srcPatch[lsizey-16][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[tidy][tidx] = sum;\n"
"}\n"
"if (tidy > 13)\n"
"{\n"
"sum = 0;\n"
"if (eveny)\n"
"{\n"
"sum =       (evenFlag * co3) * s_srcPatch[lsizey-7][1 + ((tidx - 2) >> 1)];\n"
"sum = sum + ( oddFlag * co2) * s_srcPatch[lsizey-7][1 + ((tidx - 1) >> 1)];\n"
"sum = sum + (evenFlag * co1) * s_srcPatch[lsizey-7][1 + ((tidx    ) >> 1)];\n"
"sum = sum + ( oddFlag * co2) * s_srcPatch[lsizey-7][1 + ((tidx + 1) >> 1)];\n"
"sum = sum + (evenFlag * co3) * s_srcPatch[lsizey-7][1 + ((tidx + 2) >> 1)];\n"
"}\n"
"s_dstPatch[4 + tidy][tidx] = sum;\n"
"}\n"
"barrier(CLK_LOCAL_MEM_FENCE);\n"
"sum =       co3 * s_dstPatch[2 + tidy - 2][tidx];\n"
"sum = sum + co2 * s_dstPatch[2 + tidy - 1][tidx];\n"
"sum = sum + co1 * s_dstPatch[2 + tidy    ][tidx];\n"
"sum = sum + co2 * s_dstPatch[2 + tidy + 1][tidx];\n"
"sum = sum + co3 * s_dstPatch[2 + tidy + 2][tidx];\n"
"if ((x < dst_cols) && (y < dst_rows))\n"
"storepix(convertToT(4.0f * sum), dstData + y * dst_step + x * PIXSIZE);\n"
"}\n"
, "b8d56cf3e343ba0e91552e4055049b2f"};
ProgramSource pyr_up_oclsrc(pyr_up.programStr);
const struct ProgramEntry remap={"remap",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#define noconvert\n"
"#if cn != 3\n"
"#define loadpix(addr)  *(__global const T*)(addr)\n"
"#define storepix(val, addr)  *(__global T*)(addr) = val\n"
"#define TSIZE ((int)sizeof(T))\n"
"#define convertScalar(a) (a)\n"
"#else\n"
"#define loadpix(addr)  vload3(0, (__global const T1*)(addr))\n"
"#define storepix(val, addr) vstore3(val, 0, (__global T1*)(addr))\n"
"#define TSIZE ((int)sizeof(T1)*3)\n"
"#define convertScalar(a) (T)(a.x, a.y, a.z)\n"
"#endif\n"
"enum\n"
"{\n"
"INTER_BITS = 5,\n"
"INTER_TAB_SIZE = 1 << INTER_BITS,\n"
"INTER_TAB_SIZE2 = INTER_TAB_SIZE * INTER_TAB_SIZE\n"
"};\n"
"#ifdef INTER_NEAREST\n"
"#define convertToWT\n"
"#endif\n"
"#ifdef BORDER_CONSTANT\n"
"#define EXTRAPOLATE(v2, v) v = scalar;\n"
"#elif defined BORDER_REPLICATE\n"
"#define EXTRAPOLATE(v2, v) \\\n"
"{ \\\n"
"v2 = max(min(v2, (int2)(src_cols - 1, src_rows - 1)), (int2)(0)); \\\n"
"v = convertToWT(loadpix((__global const T*)(srcptr + mad24(v2.y, src_step, v2.x * TSIZE + src_offset)))); \\\n"
"}\n"
"#elif defined BORDER_WRAP\n"
"#define EXTRAPOLATE(v2, v) \\\n"
"{ \\\n"
"if (v2.x < 0) \\\n"
"v2.x -= ((v2.x - src_cols + 1) / src_cols) * src_cols; \\\n"
"if (v2.x >= src_cols) \\\n"
"v2.x %= src_cols; \\\n"
"\\\n"
"if (v2.y < 0) \\\n"
"v2.y -= ((v2.y - src_rows + 1) / src_rows) * src_rows; \\\n"
"if( v2.y >= src_rows ) \\\n"
"v2.y %= src_rows; \\\n"
"v = convertToWT(loadpix((__global const T*)(srcptr + mad24(v2.y, src_step, v2.x * TSIZE + src_offset)))); \\\n"
"}\n"
"#elif defined(BORDER_REFLECT) || defined(BORDER_REFLECT_101)\n"
"#ifdef BORDER_REFLECT\n"
"#define DELTA int delta = 0\n"
"#else\n"
"#define DELTA int delta = 1\n"
"#endif\n"
"#define EXTRAPOLATE(v2, v) \\\n"
"{ \\\n"
"DELTA; \\\n"
"if (src_cols == 1) \\\n"
"v2.x = 0; \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if( v2.x < 0 ) \\\n"
"v2.x = -v2.x - 1 + delta; \\\n"
"else \\\n"
"v2.x = src_cols - 1 - (v2.x - src_cols) - delta; \\\n"
"} \\\n"
"while (v2.x >= src_cols || v2.x < 0); \\\n"
"\\\n"
"if (src_rows == 1) \\\n"
"v2.y = 0; \\\n"
"else \\\n"
"do \\\n"
"{ \\\n"
"if( v2.y < 0 ) \\\n"
"v2.y = -v2.y - 1 + delta; \\\n"
"else \\\n"
"v2.y = src_rows - 1 - (v2.y - src_rows) - delta; \\\n"
"} \\\n"
"while (v2.y >= src_rows || v2.y < 0); \\\n"
"v = convertToWT(loadpix((__global const T*)(srcptr + mad24(v2.y, src_step, v2.x * TSIZE + src_offset)))); \\\n"
"}\n"
"#else\n"
"#error No extrapolation method\n"
"#endif\n"
"#define NEED_EXTRAPOLATION(gx, gy) (gx >= src_cols || gy >= src_rows || gx < 0 || gy < 0)\n"
"#ifdef INTER_NEAREST\n"
"__kernel void remap_2_32FC1(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const uchar * map1ptr, int map1_step, int map1_offset,\n"
"__global const uchar * map2ptr, int map2_step, int map2_offset,\n"
"ST nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"T scalar = convertScalar(nVal);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int map1_index = mad24(y, map1_step, x * (int)sizeof(float) + map1_offset);\n"
"int map2_index = mad24(y, map2_step, x * (int)sizeof(float) + map2_offset);\n"
"int dst_index = mad24(y, dst_step, x * TSIZE + dst_offset);\n"
"__global const float * map1 = (__global const float *)(map1ptr + map1_index);\n"
"__global const float * map2 = (__global const float *)(map2ptr + map2_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"int gx = convert_int_sat_rte(map1[0]);\n"
"int gy = convert_int_sat_rte(map2[0]);\n"
"if (NEED_EXTRAPOLATION(gx, gy))\n"
"{\n"
"#ifndef BORDER_CONSTANT\n"
"int2 gxy = (int2)(gx, gy);\n"
"#endif\n"
"T v;\n"
"EXTRAPOLATE(gxy, v)\n"
"storepix(v, dst);\n"
"}\n"
"else\n"
"{\n"
"int src_index = mad24(gy, src_step, gx * TSIZE + src_offset);\n"
"storepix(loadpix((__global const T*)(srcptr + src_index)), dst);\n"
"}\n"
"}\n"
"}\n"
"__kernel void remap_32FC2(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const uchar * mapptr, int map_step, int map_offset,\n"
"ST nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"T scalar = convertScalar(nVal);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int dst_index = mad24(y, dst_step, x * TSIZE + dst_offset);\n"
"int map_index = mad24(y, map_step, x * (int)sizeof(float2) + map_offset);\n"
"__global const float2 * map = (__global const float2 *)(mapptr + map_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"int2 gxy = convert_int2_sat_rte(map[0]);\n"
"int gx = gxy.x, gy = gxy.y;\n"
"if (NEED_EXTRAPOLATION(gx, gy))\n"
"{\n"
"T v;\n"
"EXTRAPOLATE(gxy, v)\n"
"storepix(v, dst);\n"
"}\n"
"else\n"
"{\n"
"int src_index = mad24(gy, src_step, gx * TSIZE + src_offset);\n"
"storepix(loadpix((__global const T *)(srcptr + src_index)), dst);\n"
"}\n"
"}\n"
"}\n"
"__kernel void remap_16SC2(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const uchar * mapptr, int map_step, int map_offset,\n"
"ST nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"T scalar = convertScalar(nVal);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int dst_index = mad24(y, dst_step, x * TSIZE + dst_offset);\n"
"int map_index = mad24(y, map_step, x * (int)sizeof(short2) + map_offset);\n"
"__global const short2 * map = (__global const short2 *)(mapptr + map_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"int2 gxy = convert_int2(map[0]);\n"
"int gx = gxy.x, gy = gxy.y;\n"
"if (NEED_EXTRAPOLATION(gx, gy))\n"
"{\n"
"T v;\n"
"EXTRAPOLATE(gxy, v)\n"
"storepix(v, dst);\n"
"}\n"
"else\n"
"{\n"
"int src_index = mad24(gy, src_step, gx * TSIZE + src_offset);\n"
"storepix(loadpix((__global const T *)(srcptr + src_index)), dst);\n"
"}\n"
"}\n"
"}\n"
"__kernel void remap_16SC2_16UC1(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const uchar * map1ptr, int map1_step, int map1_offset,\n"
"__global const uchar * map2ptr, int map2_step, int map2_offset,\n"
"ST nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"T scalar = convertScalar(nVal);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int dst_index = mad24(y, dst_step, x * TSIZE + dst_offset);\n"
"int map1_index = mad24(y, map1_step, x * (int)sizeof(short2) + map1_offset);\n"
"int map2_index = mad24(y, map2_step, x * (int)sizeof(ushort) + map2_offset);\n"
"__global const short2 * map1 = (__global const short2 *)(map1ptr + map1_index);\n"
"__global const ushort * map2 = (__global const ushort *)(map2ptr + map2_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"int map2Value = convert_int(map2[0]) & (INTER_TAB_SIZE2 - 1);\n"
"int dx = (map2Value & (INTER_TAB_SIZE - 1)) < (INTER_TAB_SIZE >> 1) ? 1 : 0;\n"
"int dy = (map2Value >> INTER_BITS) < (INTER_TAB_SIZE >> 1) ? 1 : 0;\n"
"int2 gxy = convert_int2(map1[0]) + (int2)(dx, dy);\n"
"int gx = gxy.x, gy = gxy.y;\n"
"if (NEED_EXTRAPOLATION(gx, gy))\n"
"{\n"
"T v;\n"
"EXTRAPOLATE(gxy, v)\n"
"storepix(v, dst);\n"
"}\n"
"else\n"
"{\n"
"int src_index = mad24(gy, src_step, gx * TSIZE + src_offset);\n"
"storepix(loadpix((__global const T *)(srcptr + src_index)), dst);\n"
"}\n"
"}\n"
"}\n"
"#elif INTER_LINEAR\n"
"__kernel void remap_16SC2_16UC1(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const uchar * map1ptr, int map1_step, int map1_offset,\n"
"__global const uchar * map2ptr, int map2_step, int map2_offset,\n"
"ST nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int dst_index = mad24(y, dst_step, x * TSIZE + dst_offset);\n"
"int map1_index = mad24(y, map1_step, x * (int)sizeof(short2) + map1_offset);\n"
"int map2_index = mad24(y, map2_step, x * (int)sizeof(ushort) + map2_offset);\n"
"__global const short2 * map1 = (__global const short2 *)(map1ptr + map1_index);\n"
"__global const ushort * map2 = (__global const ushort *)(map2ptr + map2_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"int2 map_dataA = convert_int2(map1[0]);\n"
"int2 map_dataB = (int2)(map_dataA.x + 1, map_dataA.y);\n"
"int2 map_dataC = (int2)(map_dataA.x, map_dataA.y + 1);\n"
"int2 map_dataD = (int2)(map_dataA.x + 1, map_dataA.y + 1);\n"
"ushort map2Value = (ushort)(map2[0] & (INTER_TAB_SIZE2 - 1));\n"
"WT2 u = (WT2)(map2Value & (INTER_TAB_SIZE - 1), map2Value >> INTER_BITS) / (WT2)(INTER_TAB_SIZE);\n"
"WT scalar = convertToWT(convertScalar(nVal));\n"
"WT a = scalar, b = scalar, c = scalar, d = scalar;\n"
"if (!NEED_EXTRAPOLATION(map_dataA.x, map_dataA.y))\n"
"a = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataA.y, src_step, map_dataA.x * TSIZE + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataA, a);\n"
"if (!NEED_EXTRAPOLATION(map_dataB.x, map_dataB.y))\n"
"b = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataB.y, src_step, map_dataB.x * TSIZE + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataB, b);\n"
"if (!NEED_EXTRAPOLATION(map_dataC.x, map_dataC.y))\n"
"c = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataC.y, src_step, map_dataC.x * TSIZE + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataC, c);\n"
"if (!NEED_EXTRAPOLATION(map_dataD.x, map_dataD.y))\n"
"d = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataD.y, src_step, map_dataD.x * TSIZE + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataD, d);\n"
"WT dst_data = a * (1 - u.x) * (1 - u.y) +\n"
"b * (u.x)     * (1 - u.y) +\n"
"c * (1 - u.x) * (u.y) +\n"
"d * (u.x)     * (u.y);\n"
"storepix(convertToT(dst_data), dst);\n"
"}\n"
"}\n"
"__kernel void remap_2_32FC1(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const uchar * map1ptr, int map1_step, int map1_offset,\n"
"__global const uchar * map2ptr, int map2_step, int map2_offset,\n"
"ST nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int dst_index = mad24(y, dst_step, x * TSIZE + dst_offset);\n"
"int map1_index = mad24(y, map1_step, x * (int)sizeof(float) + map1_offset);\n"
"int map2_index = mad24(y, map2_step, x * (int)sizeof(float) + map2_offset);\n"
"__global const float * map1 = (__global const float *)(map1ptr + map1_index);\n"
"__global const float * map2 = (__global const float *)(map2ptr + map2_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"float2 map_data = (float2)(map1[0], map2[0]);\n"
"int2 map_dataA = convert_int2_sat_rtn(map_data);\n"
"int2 map_dataB = (int2)(map_dataA.x + 1, map_dataA.y);\n"
"int2 map_dataC = (int2)(map_dataA.x, map_dataA.y + 1);\n"
"int2 map_dataD = (int2)(map_dataA.x + 1, map_dataA.y + 1);\n"
"float2 _u = map_data - convert_float2(map_dataA);\n"
"WT2 u = convertToWT2(convert_int2_rte(convertToWT2(_u) * (WT2)INTER_TAB_SIZE)) / (WT2)INTER_TAB_SIZE;\n"
"WT scalar = convertToWT(convertScalar(nVal));\n"
"WT a = scalar, b = scalar, c = scalar, d = scalar;\n"
"if (!NEED_EXTRAPOLATION(map_dataA.x, map_dataA.y))\n"
"a = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataA.y, src_step, map_dataA.x * TSIZE + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataA, a);\n"
"if (!NEED_EXTRAPOLATION(map_dataB.x, map_dataB.y))\n"
"b = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataB.y, src_step, map_dataB.x * TSIZE + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataB, b);\n"
"if (!NEED_EXTRAPOLATION(map_dataC.x, map_dataC.y))\n"
"c = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataC.y, src_step, map_dataC.x * TSIZE + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataC, c);\n"
"if (!NEED_EXTRAPOLATION(map_dataD.x, map_dataD.y))\n"
"d = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataD.y, src_step, map_dataD.x * TSIZE + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataD, d);\n"
"WT dst_data = a * (1 - u.x) * (1 - u.y) +\n"
"b * (u.x)     * (1 - u.y) +\n"
"c * (1 - u.x) * (u.y) +\n"
"d * (u.x)     * (u.y);\n"
"storepix(convertToT(dst_data), dst);\n"
"}\n"
"}\n"
"__kernel void remap_32FC2(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const uchar * mapptr, int map_step, int map_offset,\n"
"ST nVal)\n"
"{\n"
"int x = get_global_id(0);\n"
"int y = get_global_id(1);\n"
"if (x < dst_cols && y < dst_rows)\n"
"{\n"
"int dst_index = mad24(y, dst_step, x * TSIZE + dst_offset);\n"
"int map_index = mad24(y, map_step, x * (int)sizeof(float2) + map_offset);\n"
"__global const float2 * map = (__global const float2 *)(mapptr + map_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"float2 map_data = map[0];\n"
"int2 map_dataA = convert_int2_sat_rtn(map_data);\n"
"int2 map_dataB = (int2)(map_dataA.x + 1, map_dataA.y);\n"
"int2 map_dataC = (int2)(map_dataA.x, map_dataA.y + 1);\n"
"int2 map_dataD = (int2)(map_dataA.x + 1, map_dataA.y + 1);\n"
"float2 _u = map_data - convert_float2(map_dataA);\n"
"WT2 u = convertToWT2(convert_int2_rte(convertToWT2(_u) * (WT2)INTER_TAB_SIZE)) / (WT2)INTER_TAB_SIZE;\n"
"WT scalar = convertToWT(convertScalar(nVal));\n"
"WT a = scalar, b = scalar, c = scalar, d = scalar;\n"
"if (!NEED_EXTRAPOLATION(map_dataA.x, map_dataA.y))\n"
"a = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataA.y, src_step, map_dataA.x * TSIZE + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataA, a);\n"
"if (!NEED_EXTRAPOLATION(map_dataB.x, map_dataB.y))\n"
"b = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataB.y, src_step, map_dataB.x * TSIZE + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataB, b);\n"
"if (!NEED_EXTRAPOLATION(map_dataC.x, map_dataC.y))\n"
"c = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataC.y, src_step, map_dataC.x * TSIZE + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataC, c);\n"
"if (!NEED_EXTRAPOLATION(map_dataD.x, map_dataD.y))\n"
"d = convertToWT(loadpix((__global const T *)(srcptr + mad24(map_dataD.y, src_step, map_dataD.x * TSIZE + src_offset))));\n"
"else\n"
"EXTRAPOLATE(map_dataD, d);\n"
"WT dst_data = a * (1 - u.x) * (1 - u.y) +\n"
"b * (u.x)     * (1 - u.y) +\n"
"c * (1 - u.x) * (u.y) +\n"
"d * (u.x)     * (u.y);\n"
"storepix(convertToT(dst_data), dst);\n"
"}\n"
"}\n"
"#endif\n"
, "667abe5786e34f948e065435d9010a7a"};
ProgramSource remap_oclsrc(remap.programStr);
const struct ProgramEntry resize={"resize",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"#define INTER_RESIZE_COEF_SCALE (1 << INTER_RESIZE_COEF_BITS)\n"
"#define CAST_BITS (INTER_RESIZE_COEF_BITS << 1)\n"
"#define INC(x,l) min(x+1,l-1)\n"
"#define noconvert\n"
"#if cn != 3\n"
"#define loadpix(addr)  *(__global const T *)(addr)\n"
"#define storepix(val, addr)  *(__global T *)(addr) = val\n"
"#define TSIZE (int)sizeof(T)\n"
"#else\n"
"#define loadpix(addr)  vload3(0, (__global const T1 *)(addr))\n"
"#define storepix(val, addr) vstore3(val, 0, (__global T1 *)(addr))\n"
"#define TSIZE (int)sizeof(T1)*cn\n"
"#endif\n"
"#if defined USE_SAMPLER\n"
"#if cn == 1\n"
"#define READ_IMAGE(X,Y,Z)  read_imagef(X,Y,Z).x\n"
"#elif cn == 2\n"
"#define READ_IMAGE(X,Y,Z)  read_imagef(X,Y,Z).xy\n"
"#elif cn == 3\n"
"#define READ_IMAGE(X,Y,Z)  read_imagef(X,Y,Z).xyz\n"
"#elif cn == 4\n"
"#define READ_IMAGE(X,Y,Z)  read_imagef(X,Y,Z)\n"
"#endif\n"
"#define __CAT(x, y) x##y\n"
"#define CAT(x, y) __CAT(x, y)\n"
"#define INTERMEDIATE_TYPE CAT(float, cn)\n"
"#define float1 float\n"
"#if depth == 0\n"
"#define RESULT_SCALE    255.0f\n"
"#elif depth == 1\n"
"#define RESULT_SCALE    127.0f\n"
"#elif depth == 2\n"
"#define RESULT_SCALE    65535.0f\n"
"#elif depth == 3\n"
"#define RESULT_SCALE    32767.0f\n"
"#else\n"
"#define RESULT_SCALE    1.0f\n"
"#endif\n"
"__kernel void resizeSampler(__read_only image2d_t srcImage,\n"
"__global uchar* dstptr, int dststep, int dstoffset,\n"
"int dstrows, int dstcols,\n"
"float ifx, float ify)\n"
"{\n"
"const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE |\n"
"CLK_ADDRESS_CLAMP_TO_EDGE |\n"
"CLK_FILTER_LINEAR;\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"float sx = ((dx+0.5f) * ifx), sy = ((dy+0.5f) * ify);\n"
"INTERMEDIATE_TYPE intermediate = READ_IMAGE(srcImage, sampler, (float2)(sx, sy));\n"
"#if depth <= 4\n"
"T uval = convertToDT(round(intermediate * RESULT_SCALE));\n"
"#else\n"
"T uval = convertToDT(intermediate * RESULT_SCALE);\n"
"#endif\n"
"if(dx < dstcols && dy < dstrows)\n"
"{\n"
"storepix(uval, dstptr + mad24(dy, dststep, dstoffset + dx*TSIZE));\n"
"}\n"
"}\n"
"#elif defined INTER_LINEAR_INTEGER\n"
"__kernel void resizeLN(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__global const uchar * buffer)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"__global const int * xofs = (__global const int *)(buffer), * yofs = xofs + dst_cols;\n"
"__global const short * ialpha = (__global const short *)(yofs + dst_rows);\n"
"__global const short * ibeta = ialpha + ((dst_cols + dy) << 1);\n"
"ialpha += dx << 1;\n"
"int sx0 = xofs[dx], sy0 = clamp(yofs[dy], 0, src_rows - 1),\n"
"sy1 = clamp(yofs[dy] + 1, 0, src_rows - 1);\n"
"short a0 = ialpha[0], a1 = ialpha[1];\n"
"short b0 = ibeta[0], b1 = ibeta[1];\n"
"int src_index0 = mad24(sy0, src_step, mad24(sx0, TSIZE, src_offset)),\n"
"src_index1 = mad24(sy1, src_step, mad24(sx0, TSIZE, src_offset));\n"
"WT data0 = convertToWT(loadpix(srcptr + src_index0));\n"
"WT data1 = convertToWT(loadpix(srcptr + src_index0 + TSIZE));\n"
"WT data2 = convertToWT(loadpix(srcptr + src_index1));\n"
"WT data3 = convertToWT(loadpix(srcptr + src_index1 + TSIZE));\n"
"WT val = ( (((data0 * a0 + data1 * a1) >> 4) * b0) >> 16) +\n"
"( (((data2 * a0 + data3 * a1) >> 4) * b1) >> 16);\n"
"storepix(convertToDT((val + 2) >> 2),\n"
"dstptr + mad24(dy, dst_step, mad24(dx, TSIZE, dst_offset)));\n"
"}\n"
"}\n"
"#elif defined INTER_LINEAR\n"
"__kernel void resizeLN(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"float ifx, float ify)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"float sx = ((dx+0.5f) * ifx - 0.5f), sy = ((dy+0.5f) * ify - 0.5f);\n"
"int x = floor(sx), y = floor(sy);\n"
"float u = sx - x, v = sy - y;\n"
"if ( x<0 ) x=0,u=0;\n"
"if ( x>=src_cols ) x=src_cols-1,u=0;\n"
"if ( y<0 ) y=0,v=0;\n"
"if ( y>=src_rows ) y=src_rows-1,v=0;\n"
"int y_ = INC(y, src_rows);\n"
"int x_ = INC(x, src_cols);\n"
"#if depth <= 4\n"
"u = u * INTER_RESIZE_COEF_SCALE;\n"
"v = v * INTER_RESIZE_COEF_SCALE;\n"
"int U = rint(u);\n"
"int V = rint(v);\n"
"int U1 = rint(INTER_RESIZE_COEF_SCALE - u);\n"
"int V1 = rint(INTER_RESIZE_COEF_SCALE - v);\n"
"WT data0 = convertToWT(loadpix(srcptr + mad24(y, src_step, mad24(x, TSIZE, src_offset))));\n"
"WT data1 = convertToWT(loadpix(srcptr + mad24(y, src_step, mad24(x_, TSIZE, src_offset))));\n"
"WT data2 = convertToWT(loadpix(srcptr + mad24(y_, src_step, mad24(x, TSIZE, src_offset))));\n"
"WT data3 = convertToWT(loadpix(srcptr + mad24(y_, src_step, mad24(x_, TSIZE, src_offset))));\n"
"WT val = mul24((WT)mul24(U1, V1), data0) + mul24((WT)mul24(U, V1), data1) +\n"
"mul24((WT)mul24(U1, V), data2) + mul24((WT)mul24(U, V), data3);\n"
"T uval = convertToDT((val + (1<<(CAST_BITS-1)))>>CAST_BITS);\n"
"#else\n"
"float u1 = 1.f - u;\n"
"float v1 = 1.f - v;\n"
"WT data0 = convertToWT(loadpix(srcptr + mad24(y, src_step, mad24(x, TSIZE, src_offset))));\n"
"WT data1 = convertToWT(loadpix(srcptr + mad24(y, src_step, mad24(x_, TSIZE, src_offset))));\n"
"WT data2 = convertToWT(loadpix(srcptr + mad24(y_, src_step, mad24(x, TSIZE, src_offset))));\n"
"WT data3 = convertToWT(loadpix(srcptr + mad24(y_, src_step, mad24(x_, TSIZE, src_offset))));\n"
"T uval = u1 * v1 * data0 + u * v1 * data1 + u1 * v *data2 + u * v *data3;\n"
"#endif\n"
"storepix(uval, dstptr + mad24(dy, dst_step, mad24(dx, TSIZE, dst_offset)));\n"
"}\n"
"}\n"
"#elif defined INTER_NEAREST\n"
"__kernel void resizeNN(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"float ifx, float ify)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"float s1 = dx * ifx;\n"
"float s2 = dy * ify;\n"
"int sx = min(convert_int_rtz(s1), src_cols - 1);\n"
"int sy = min(convert_int_rtz(s2), src_rows - 1);\n"
"storepix(loadpix(srcptr + mad24(sy, src_step, mad24(sx, TSIZE, src_offset))),\n"
"dstptr + mad24(dy, dst_step, mad24(dx, TSIZE, dst_offset)));\n"
"}\n"
"}\n"
"#elif defined INTER_AREA\n"
"#ifdef INTER_AREA_FAST\n"
"__kernel void resizeAREA_FAST(__global const uchar * src, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"int dst_index = mad24(dy, dst_step, dst_offset);\n"
"int sx = XSCALE * dx;\n"
"int sy = YSCALE * dy;\n"
"WTV sum = (WTV)(0);\n"
"#pragma unroll\n"
"for (int py = 0; py < YSCALE; ++py)\n"
"{\n"
"int y = min(sy + py, src_rows - 1);\n"
"int src_index = mad24(y, src_step, src_offset);\n"
"#pragma unroll\n"
"for (int px = 0; px < XSCALE; ++px)\n"
"{\n"
"int x = min(sx + px, src_cols - 1);\n"
"sum += convertToWTV(loadpix(src + src_index + x*TSIZE));\n"
"}\n"
"}\n"
"storepix(convertToT(convertToWT2V(sum) * (WT2V)(SCALE)), dst + mad24(dx, TSIZE, dst_index));\n"
"}\n"
"}\n"
"#else\n"
"__kernel void resizeAREA(__global const uchar * src, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dst, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"float ifx, float ify, __global const int * ofs_tab,\n"
"__global const int * map_tab, __global const float * alpha_tab)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"int dst_index = mad24(dy, dst_step, dst_offset);\n"
"__global const int * xmap_tab = map_tab;\n"
"__global const int * ymap_tab = (__global const int *)(map_tab + (src_cols << 1));\n"
"__global const float * xalpha_tab = alpha_tab;\n"
"__global const float * yalpha_tab = (__global const float *)(alpha_tab + (src_cols << 1));\n"
"__global const int * xofs_tab = ofs_tab;\n"
"__global const int * yofs_tab = (__global const int *)(ofs_tab + dst_cols + 1);\n"
"int xk0 = xofs_tab[dx], xk1 = xofs_tab[dx + 1];\n"
"int yk0 = yofs_tab[dy], yk1 = yofs_tab[dy + 1];\n"
"int sy0 = ymap_tab[yk0], sy1 = ymap_tab[yk1 - 1];\n"
"int sx0 = xmap_tab[xk0], sx1 = xmap_tab[xk1 - 1];\n"
"WTV sum = (WTV)(0), buf;\n"
"int src_index = mad24(sy0, src_step, src_offset);\n"
"for (int sy = sy0, yk = yk0; sy <= sy1; ++sy, src_index += src_step, ++yk)\n"
"{\n"
"WTV beta = (WTV)(yalpha_tab[yk]);\n"
"buf = (WTV)(0);\n"
"for (int sx = sx0, xk = xk0; sx <= sx1; ++sx, ++xk)\n"
"{\n"
"WTV alpha = (WTV)(xalpha_tab[xk]);\n"
"buf += convertToWTV(loadpix(src + mad24(sx, TSIZE, src_index))) * alpha;\n"
"}\n"
"sum += buf * beta;\n"
"}\n"
"storepix(convertToT(sum), dst + mad24(dx, TSIZE, dst_index));\n"
"}\n"
"}\n"
"#endif\n"
"#endif\n"
, "275dd837fbf7fc95a7f871e6bdc3fe8d"};
ProgramSource resize_oclsrc(resize.programStr);
const struct ProgramEntry threshold={"threshold",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#endif\n"
"__kernel void threshold(__global const uchar * srcptr, int src_step, int src_offset,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int rows, int cols,\n"
"T1 thresh, T1 max_val)\n"
"{\n"
"int gx = get_global_id(0);\n"
"int gy = get_global_id(1);\n"
"if (gx < cols && gy < rows)\n"
"{\n"
"int src_index = mad24(gy, src_step, mad24(gx, (int)sizeof(T), src_offset));\n"
"int dst_index = mad24(gy, dst_step, mad24(gx, (int)sizeof(T), dst_offset));\n"
"T sdata = *(__global const T *)(srcptr + src_index);\n"
"__global T * dst = (__global T *)(dstptr + dst_index);\n"
"#ifdef THRESH_BINARY\n"
"dst[0] = sdata > (T)(thresh) ? (T)(max_val) : (T)(0);\n"
"#elif defined THRESH_BINARY_INV\n"
"dst[0] = sdata > (T)(thresh) ? (T)(0) : (T)(max_val);\n"
"#elif defined THRESH_TRUNC\n"
"dst[0] = sdata > (T)(thresh) ? (T)(thresh) : sdata;\n"
"#elif defined THRESH_TOZERO\n"
"dst[0] = sdata > (T)(thresh) ? sdata : (T)(0);\n"
"#elif defined THRESH_TOZERO_INV\n"
"dst[0] = sdata > (T)(thresh) ? (T)(0) : sdata;\n"
"#endif\n"
"}\n"
"}\n"
, "2b01a5dc23f6e14deceff0a854f32b5b"};
ProgramSource threshold_oclsrc(threshold.programStr);
const struct ProgramEntry warp_affine={"warp_affine",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#define CT double\n"
"#else\n"
"#define CT float\n"
"#endif\n"
"#define INTER_BITS 5\n"
"#define INTER_TAB_SIZE (1 << INTER_BITS)\n"
"#define INTER_SCALE 1.f/INTER_TAB_SIZE\n"
"#define AB_BITS max(10, (int)INTER_BITS)\n"
"#define AB_SCALE (1 << AB_BITS)\n"
"#define INTER_REMAP_COEF_BITS 15\n"
"#define INTER_REMAP_COEF_SCALE (1 << INTER_REMAP_COEF_BITS)\n"
"#define noconvert\n"
"#ifndef ST\n"
"#define ST T\n"
"#endif\n"
"#if cn != 3\n"
"#define loadpix(addr)  *(__global const T*)(addr)\n"
"#define storepix(val, addr)  *(__global T*)(addr) = val\n"
"#define scalar scalar_\n"
"#define pixsize (int)sizeof(T)\n"
"#else\n"
"#define loadpix(addr)  vload3(0, (__global const T1*)(addr))\n"
"#define storepix(val, addr) vstore3(val, 0, (__global T1*)(addr))\n"
"#ifdef INTER_NEAREST\n"
"#define scalar (T)(scalar_.x, scalar_.y, scalar_.z)\n"
"#else\n"
"#define scalar (WT)(scalar_.x, scalar_.y, scalar_.z)\n"
"#endif\n"
"#define pixsize ((int)sizeof(T1)*3)\n"
"#endif\n"
"#ifdef INTER_NEAREST\n"
"__kernel void warpAffine(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__constant CT * M, ST scalar_)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"int round_delta = (AB_SCALE >> 1);\n"
"int X0 = rint(M[0] * dx * AB_SCALE);\n"
"int Y0 = rint(M[3] * dx * AB_SCALE);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"short sx = convert_short_sat(X0 >> AB_BITS);\n"
"short sy = convert_short_sat(Y0 >> AB_BITS);\n"
"int dst_index = mad24(dy, dst_step, dst_offset + dx * pixsize);\n"
"if (sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows)\n"
"{\n"
"int src_index = mad24(sy, src_step, src_offset + sx * pixsize);\n"
"storepix(loadpix(srcptr + src_index), dstptr + dst_index);\n"
"}\n"
"else\n"
"storepix(scalar, dstptr + dst_index);\n"
"}\n"
"}\n"
"#elif defined INTER_LINEAR\n"
"__kernel void warpAffine(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__constant CT * M, ST scalar_)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"int round_delta = AB_SCALE/INTER_TAB_SIZE/2;\n"
"int tmp = (dx << AB_BITS);\n"
"int X0 = rint(M[0] * tmp);\n"
"int Y0 = rint(M[3] * tmp);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"X0 = X0 >> (AB_BITS - INTER_BITS);\n"
"Y0 = Y0 >> (AB_BITS - INTER_BITS);\n"
"short sx = convert_short_sat(X0 >> INTER_BITS);\n"
"short sy = convert_short_sat(Y0 >> INTER_BITS);\n"
"short ax = convert_short(X0 & (INTER_TAB_SIZE-1));\n"
"short ay = convert_short(Y0 & (INTER_TAB_SIZE-1));\n"
"WT v0 = (sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows) ?\n"
"convertToWT(loadpix(srcptr + mad24(sy, src_step, src_offset + sx * pixsize))) : scalar;\n"
"WT v1 = (sx+1 >= 0 && sx+1 < src_cols && sy >= 0 && sy < src_rows) ?\n"
"convertToWT(loadpix(srcptr + mad24(sy, src_step, src_offset + (sx+1) * pixsize))) : scalar;\n"
"WT v2 = (sx >= 0 && sx < src_cols && sy+1 >= 0 && sy+1 < src_rows) ?\n"
"convertToWT(loadpix(srcptr + mad24(sy+1, src_step, src_offset + sx * pixsize))) : scalar;\n"
"WT v3 = (sx+1 >= 0 && sx+1 < src_cols && sy+1 >= 0 && sy+1 < src_rows) ?\n"
"convertToWT(loadpix(srcptr + mad24(sy+1, src_step, src_offset + (sx+1) * pixsize))) : scalar;\n"
"float taby = 1.f/INTER_TAB_SIZE*ay;\n"
"float tabx = 1.f/INTER_TAB_SIZE*ax;\n"
"int dst_index = mad24(dy, dst_step, dst_offset + dx * pixsize);\n"
"#if depth <= 4\n"
"int itab0 = convert_short_sat_rte( (1.0f-taby)*(1.0f-tabx) * INTER_REMAP_COEF_SCALE );\n"
"int itab1 = convert_short_sat_rte( (1.0f-taby)*tabx * INTER_REMAP_COEF_SCALE );\n"
"int itab2 = convert_short_sat_rte( taby*(1.0f-tabx) * INTER_REMAP_COEF_SCALE );\n"
"int itab3 = convert_short_sat_rte( taby*tabx * INTER_REMAP_COEF_SCALE );\n"
"WT val = v0 * itab0 +  v1 * itab1 + v2 * itab2 + v3 * itab3;\n"
"storepix(convertToT((val + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS), dstptr + dst_index);\n"
"#else\n"
"float tabx2 = 1.0f - tabx, taby2 = 1.0f - taby;\n"
"WT val = v0 * tabx2 * taby2 +  v1 * tabx * taby2 + v2 * tabx2 * taby + v3 * tabx * taby;\n"
"storepix(convertToT(val), dstptr + dst_index);\n"
"#endif\n"
"}\n"
"}\n"
"#elif defined INTER_CUBIC\n"
"inline void interpolateCubic( float x, float* coeffs )\n"
"{\n"
"const float A = -0.75f;\n"
"coeffs[0] = ((A*(x + 1.f) - 5.0f*A)*(x + 1.f) + 8.0f*A)*(x + 1.f) - 4.0f*A;\n"
"coeffs[1] = ((A + 2.f)*x - (A + 3.f))*x*x + 1.f;\n"
"coeffs[2] = ((A + 2.f)*(1.f - x) - (A + 3.f))*(1.f - x)*(1.f - x) + 1.f;\n"
"coeffs[3] = 1.f - coeffs[0] - coeffs[1] - coeffs[2];\n"
"}\n"
"__kernel void warpAffine(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__constant CT * M, ST scalar_)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"int round_delta = ((AB_SCALE>>INTER_BITS)>>1);\n"
"int tmp = (dx << AB_BITS);\n"
"int X0 = rint(M[0] * tmp);\n"
"int Y0 = rint(M[3] * tmp);\n"
"X0 += rint((M[1]*dy + M[2]) * AB_SCALE) + round_delta;\n"
"Y0 += rint((M[4]*dy + M[5]) * AB_SCALE) + round_delta;\n"
"X0 = X0 >> (AB_BITS - INTER_BITS);\n"
"Y0 = Y0 >> (AB_BITS - INTER_BITS);\n"
"int sx = (short)(X0 >> INTER_BITS) - 1;\n"
"int sy = (short)(Y0 >> INTER_BITS) - 1;\n"
"int ay = (short)(Y0 & (INTER_TAB_SIZE-1));\n"
"int ax = (short)(X0 & (INTER_TAB_SIZE-1));\n"
"WT v[16];\n"
"#pragma unroll\n"
"for (int y = 0; y < 4; y++)\n"
"#pragma unroll\n"
"for (int x = 0; x < 4; x++)\n"
"v[mad24(y, 4, x)] = (sx+x >= 0 && sx+x < src_cols && sy+y >= 0 && sy+y < src_rows) ?\n"
"convertToWT(loadpix(srcptr + mad24(sy+y, src_step, src_offset + (sx+x) * pixsize))) : scalar;\n"
"float tab1y[4], tab1x[4];\n"
"float ayy = INTER_SCALE * ay;\n"
"float axx = INTER_SCALE * ax;\n"
"interpolateCubic(ayy, tab1y);\n"
"interpolateCubic(axx, tab1x);\n"
"int dst_index = mad24(dy, dst_step, dst_offset + dx * pixsize);\n"
"WT sum = (WT)(0);\n"
"#if depth <= 4\n"
"int itab[16];\n"
"#pragma unroll\n"
"for (int i = 0; i < 16; i++)\n"
"itab[i] = rint(tab1y[(i>>2)] * tab1x[(i&3)] * INTER_REMAP_COEF_SCALE);\n"
"#pragma unroll\n"
"for (int i = 0; i < 16; i++)\n"
"sum += v[i] * itab[i];\n"
"storepix(convertToT( (sum + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ), dstptr + dst_index);\n"
"#else\n"
"#pragma unroll\n"
"for (int i = 0; i < 16; i++)\n"
"sum += v[i] * tab1y[(i>>2)] * tab1x[(i&3)];\n"
"storepix(convertToT( sum ), dstptr + dst_index);\n"
"#endif\n"
"}\n"
"}\n"
"#endif\n"
, "47003f3c6c6b9bd1061f573fc03ae232"};
ProgramSource warp_affine_oclsrc(warp_affine.programStr);
const struct ProgramEntry warp_perspective={"warp_perspective",
"#ifdef DOUBLE_SUPPORT\n"
"#ifdef cl_amd_fp64\n"
"#pragma OPENCL EXTENSION cl_amd_fp64:enable\n"
"#elif defined (cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64:enable\n"
"#endif\n"
"#define CT double\n"
"#else\n"
"#define CT float\n"
"#endif\n"
"#define INTER_BITS 5\n"
"#define INTER_TAB_SIZE (1 << INTER_BITS)\n"
"#define INTER_SCALE 1.f / INTER_TAB_SIZE\n"
"#define AB_BITS max(10, (int)INTER_BITS)\n"
"#define AB_SCALE (1 << AB_BITS)\n"
"#define INTER_REMAP_COEF_BITS 15\n"
"#define INTER_REMAP_COEF_SCALE (1 << INTER_REMAP_COEF_BITS)\n"
"#define noconvert\n"
"#ifndef ST\n"
"#define ST T\n"
"#endif\n"
"#if cn != 3\n"
"#define loadpix(addr)  *(__global const T*)(addr)\n"
"#define storepix(val, addr)  *(__global T*)(addr) = val\n"
"#define scalar scalar_\n"
"#define pixsize (int)sizeof(T)\n"
"#else\n"
"#define loadpix(addr)  vload3(0, (__global const T1*)(addr))\n"
"#define storepix(val, addr) vstore3(val, 0, (__global T1*)(addr))\n"
"#ifdef INTER_NEAREST\n"
"#define scalar (T)(scalar_.x, scalar_.y, scalar_.z)\n"
"#else\n"
"#define scalar (WT)(scalar_.x, scalar_.y, scalar_.z)\n"
"#endif\n"
"#define pixsize ((int)sizeof(T1)*3)\n"
"#endif\n"
"#ifdef INTER_NEAREST\n"
"__kernel void warpPerspective(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__constant CT * M, ST scalar_)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"CT X0 = M[0] * dx + M[1] * dy + M[2];\n"
"CT Y0 = M[3] * dx + M[4] * dy + M[5];\n"
"CT W = M[6] * dx + M[7] * dy + M[8];\n"
"W = W != 0.0f ? 1.f / W : 0.0f;\n"
"short sx = convert_short_sat_rte(X0*W);\n"
"short sy = convert_short_sat_rte(Y0*W);\n"
"int dst_index = mad24(dy, dst_step, dx * pixsize + dst_offset);\n"
"if (sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows)\n"
"{\n"
"int src_index = mad24(sy, src_step, sx * pixsize + src_offset);\n"
"storepix(loadpix(srcptr + src_index), dstptr + dst_index);\n"
"}\n"
"else\n"
"storepix(scalar, dstptr + dst_index);\n"
"}\n"
"}\n"
"#elif defined INTER_LINEAR\n"
"__kernel void warpPerspective(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__constant CT * M, ST scalar_)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"CT X0 = M[0] * dx + M[1] * dy + M[2];\n"
"CT Y0 = M[3] * dx + M[4] * dy + M[5];\n"
"CT W = M[6] * dx + M[7] * dy + M[8];\n"
"W = W != 0.0f ? INTER_TAB_SIZE / W : 0.0f;\n"
"int X = rint(X0 * W), Y = rint(Y0 * W);\n"
"short sx = convert_short_sat(X >> INTER_BITS);\n"
"short sy = convert_short_sat(Y >> INTER_BITS);\n"
"short ay = (short)(Y & (INTER_TAB_SIZE - 1));\n"
"short ax = (short)(X & (INTER_TAB_SIZE - 1));\n"
"WT v0 = (sx >= 0 && sx < src_cols && sy >= 0 && sy < src_rows) ?\n"
"convertToWT(loadpix(srcptr + mad24(sy, src_step, src_offset + sx * pixsize))) : scalar;\n"
"WT v1 = (sx+1 >= 0 && sx+1 < src_cols && sy >= 0 && sy < src_rows) ?\n"
"convertToWT(loadpix(srcptr + mad24(sy, src_step, src_offset + (sx+1) * pixsize))) : scalar;\n"
"WT v2 = (sx >= 0 && sx < src_cols && sy+1 >= 0 && sy+1 < src_rows) ?\n"
"convertToWT(loadpix(srcptr + mad24(sy+1, src_step, src_offset + sx * pixsize))) : scalar;\n"
"WT v3 = (sx+1 >= 0 && sx+1 < src_cols && sy+1 >= 0 && sy+1 < src_rows) ?\n"
"convertToWT(loadpix(srcptr + mad24(sy+1, src_step, src_offset + (sx+1) * pixsize))) : scalar;\n"
"float taby = 1.f/INTER_TAB_SIZE*ay;\n"
"float tabx = 1.f/INTER_TAB_SIZE*ax;\n"
"int dst_index = mad24(dy, dst_step, dst_offset + dx * pixsize);\n"
"#if depth <= 4\n"
"int itab0 = convert_short_sat_rte( (1.0f-taby)*(1.0f-tabx) * INTER_REMAP_COEF_SCALE );\n"
"int itab1 = convert_short_sat_rte( (1.0f-taby)*tabx * INTER_REMAP_COEF_SCALE );\n"
"int itab2 = convert_short_sat_rte( taby*(1.0f-tabx) * INTER_REMAP_COEF_SCALE );\n"
"int itab3 = convert_short_sat_rte( taby*tabx * INTER_REMAP_COEF_SCALE );\n"
"WT val = v0 * itab0 +  v1 * itab1 + v2 * itab2 + v3 * itab3;\n"
"storepix(convertToT((val + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS), dstptr + dst_index);\n"
"#else\n"
"float tabx2 = 1.0f - tabx, taby2 = 1.0f - taby;\n"
"WT val = v0 * tabx2 * taby2 +  v1 * tabx * taby2 + v2 * tabx2 * taby + v3 * tabx * taby;\n"
"storepix(convertToT(val), dstptr + dst_index);\n"
"#endif\n"
"}\n"
"}\n"
"#elif defined INTER_CUBIC\n"
"inline void interpolateCubic( float x, float* coeffs )\n"
"{\n"
"const float A = -0.75f;\n"
"coeffs[0] = ((A*(x + 1.f) - 5.0f*A)*(x + 1.f) + 8.0f*A)*(x + 1.f) - 4.0f*A;\n"
"coeffs[1] = ((A + 2.f)*x - (A + 3.f))*x*x + 1.f;\n"
"coeffs[2] = ((A + 2.f)*(1.f - x) - (A + 3.f))*(1.f - x)*(1.f - x) + 1.f;\n"
"coeffs[3] = 1.f - coeffs[0] - coeffs[1] - coeffs[2];\n"
"}\n"
"__kernel void warpPerspective(__global const uchar * srcptr, int src_step, int src_offset, int src_rows, int src_cols,\n"
"__global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n"
"__constant CT * M, ST scalar_)\n"
"{\n"
"int dx = get_global_id(0);\n"
"int dy = get_global_id(1);\n"
"if (dx < dst_cols && dy < dst_rows)\n"
"{\n"
"CT X0 = M[0] * dx + M[1] * dy + M[2];\n"
"CT Y0 = M[3] * dx + M[4] * dy + M[5];\n"
"CT W = M[6] * dx + M[7] * dy + M[8];\n"
"W = W != 0.0f ? INTER_TAB_SIZE / W : 0.0f;\n"
"int X = rint(X0 * W), Y = rint(Y0 * W);\n"
"short sx = convert_short_sat(X >> INTER_BITS) - 1;\n"
"short sy = convert_short_sat(Y >> INTER_BITS) - 1;\n"
"short ay = (short)(Y & (INTER_TAB_SIZE-1));\n"
"short ax = (short)(X & (INTER_TAB_SIZE-1));\n"
"WT v[16];\n"
"#pragma unroll\n"
"for (int y = 0; y < 4; y++)\n"
"#pragma unroll\n"
"for (int x = 0; x < 4; x++)\n"
"v[mad24(y, 4, x)] = (sx+x >= 0 && sx+x < src_cols && sy+y >= 0 && sy+y < src_rows) ?\n"
"convertToWT(loadpix(srcptr + mad24(sy+y, src_step, src_offset + (sx+x) * pixsize))) : scalar;\n"
"float tab1y[4], tab1x[4];\n"
"float ayy = INTER_SCALE * ay;\n"
"float axx = INTER_SCALE * ax;\n"
"interpolateCubic(ayy, tab1y);\n"
"interpolateCubic(axx, tab1x);\n"
"int dst_index = mad24(dy, dst_step, dst_offset + dx * pixsize);\n"
"WT sum = (WT)(0);\n"
"#if depth <= 4\n"
"int itab[16];\n"
"#pragma unroll\n"
"for (int i = 0; i < 16; i++)\n"
"itab[i] = rint(tab1y[(i>>2)] * tab1x[(i&3)] * INTER_REMAP_COEF_SCALE);\n"
"#pragma unroll\n"
"for (int i = 0; i < 16; i++)\n"
"sum += v[i] * itab[i];\n"
"storepix(convertToT( (sum + (1 << (INTER_REMAP_COEF_BITS-1))) >> INTER_REMAP_COEF_BITS ), dstptr + dst_index);\n"
"#else\n"
"#pragma unroll\n"
"for (int i = 0; i < 16; i++)\n"
"sum += v[i] * tab1y[(i>>2)] * tab1x[(i&3)];\n"
"storepix(convertToT( sum ), dstptr + dst_index);\n"
"#endif\n"
"}\n"
"}\n"
"#endif\n"
, "1449b5059b082c4595846a86ed5702ad"};
ProgramSource warp_perspective_oclsrc(warp_perspective.programStr);
}
}}
